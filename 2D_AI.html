<!DOCTYPE html>
<html lang="cs">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="theme-color" content="#0a0a0a" />
    <title>Soustru≈æn√≠k - Parametrick√© kreslen√≠ + AI</title>

    <!--
    ‚úÖ DEMO API KL√çƒå JE P≈òEDVYPLNƒöN√ù!
    Aplikace funguje okam≈æitƒõ po otev≈ôen√≠.

    Kl√≠ƒç je rozdƒõlen√Ω na 2 ƒç√°sti (≈ô√°dek ~2695):
    API_KEY_PART1 + API_KEY_PART2 = kompletn√≠ kl√≠ƒç

    Pro vlastn√≠ kl√≠ƒç:
    - Kliknƒõte na ‚ú® AI ‚Üí ‚öôÔ∏è Settings
    - P≈ôidejte sv≈Øj Gemini API kl√≠ƒç
    - Z√≠skejte na: https://aistudio.google.com/app/apikey
    -->

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: #0a0a0a;
        color: #e0e0e0;
        display: flex;
        flex-direction: column;
        height: 100vh;
        height: 100dvh; /* Dynamick√° v√Ω≈°ka pro mobily */
        overflow: hidden;
        margin: 0;
        padding: 0;
      }

      .tool-group {
        margin-bottom: 15px;
        background: #222;
        padding: 12px;
        border-radius: 8px;
        border: 1px solid #333;
      }

      .tool-group h3 {
        color: #6ab0ff;
        margin: 0 0 10px 0;
        font-size: 14px;
        user-select: none;
      }

      .tool-group h3[onclick] {
        transition: color 0.2s;
      }

      .tool-group h3[onclick]:hover {
        color: #8ac0ff;
      }

      .tool-group > div[id$="Section"] {
        overflow: hidden;
        transition: max-height 0.3s ease, opacity 0.3s ease;
      }

      .input-group {
        margin-bottom: 10px;
      }

      .input-group label {
        display: block;
        margin-bottom: 4px;
        color: #b0b0b0;
        font-size: 12px;
      }

      .input-group input,
      .input-group select {
        width: 100%;
        padding: 8px;
        background: #0a0a0a;
        border: 1px solid #444;
        border-radius: 4px;
        color: #e0e0e0;
        font-size: 14px;
      }

      .btn {
        width: 100%;
        padding: 10px;
        background: #3a7bc8;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        margin-top: 8px;
        transition: background 0.2s;
      }

      .btn:active {
        background: #5a9be8;
      }

      .preset-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 6px;
        margin: 8px 0;
      }

      .preset-btn {
        padding: 8px;
        background: #2a4a4a;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }

      .preset-btn:active {
        background: #3a5a5a;
      }

      .calc-result {
        background: #1a2a1a;
        padding: 10px;
        border-radius: 5px;
        margin-top: 10px;
        border: 1px solid #2a4a2a;
        font-size: 11px;
        line-height: 1.5;
      }

      .result-title {
        color: #90ee90;
        font-weight: bold;
        margin-bottom: 5px;
      }

      .canvas-area {
        flex: 1;
        position: relative;
        overflow: hidden;
        background: #0a0a0a;
        width: 100%;
        height: 100%;
      }

      canvas {
        display: block;
        touch-action: none;
        width: 100%;
        height: 100%;
      }

      /* --- TOOLBAR --- */
      .toolbar {
        position: absolute;
        display: flex;
        gap: 15px;
        justify-content: center;
        align-items: center;
        z-index: 1000;

        background: rgba(15, 15, 15, 0.98);
        backdrop-filter: blur(10px);
        border: 1px solid #333;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.6);
      }

      /* Desktop a tablet - dole */
      @media (min-width: 769px) {
        .toolbar {
          bottom: 0;
          left: 0;
          right: 0;
          flex-direction: row;
          border-top: 1px solid #333;
          border-left: none;
          border-right: none;
          border-bottom: none;
          padding: 10px;
          padding-bottom: max(10px, env(safe-area-inset-bottom));
        }
      }

      /* Mobil na ≈°√≠≈ôku - vpravo */
      @media (max-width: 768px) and (orientation: landscape) {
        .toolbar {
          top: 10px;
          bottom: 10px;
          right: 10px;
          left: auto;
          flex-direction: column;
          padding: 10px 8px;
          border-radius: 12px;
          gap: 12px;
          max-height: calc(100vh - 20px);
          overflow-y: auto;
        }
      }

      /* Mobil na v√Ω≈°ku - dole uvnit≈ô canvasu s offsetem */
      @media (max-width: 768px) and (orientation: portrait) {
        .toolbar {
          bottom: max(30px, calc(20px + env(safe-area-inset-bottom)));
          left: 50%;
          right: auto;
          transform: translateX(-50%);
          flex-direction: row;
          flex-wrap: nowrap;
          padding: 5px 3px;
          border-radius: 12px;
          gap: 3px; /* Minim√°ln√≠ mezery */
          width: auto;
          max-width: 98%;
          justify-content: center;
        }
      }

      /* --- SUBMENU NAD TOOLBAREM --- */
      .tool-submenu {
        position: absolute;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        z-index: 999;
        justify-content: center;
        animation: slideUp 0.2s ease-out;
        pointer-events: none;
      }

      .tool-submenu > * {
        pointer-events: auto;
      }

      /* Desktop - nad toolbarem */
      @media (min-width: 769px) {
        .tool-submenu {
          bottom: 70px;
          left: 10px;
          right: 10px;
        }
      }

      /* Mobil na ≈°√≠≈ôku - vlevo od toolbaru */
      @media (max-width: 768px) and (orientation: landscape) {
        .tool-submenu {
          top: 50%;
          right: 80px;
          left: 10px;
          transform: translateY(-50%);
          animation: slideLeft 0.2s ease-out;
        }

        @keyframes slideLeft {
          from {
            transform: translateY(-50%) translateX(10px);
            opacity: 0;
          }
          to {
            transform: translateY(-50%) translateX(0);
            opacity: 1;
          }
        }
      }

      /* Mobil na v√Ω≈°ku - nad toolbarem uvnit≈ô canvasu */
      @media (max-width: 768px) and (orientation: portrait) {
        .tool-submenu {
          bottom: max(
            120px,
            calc(110px + env(safe-area-inset-bottom))
          ); /* Nad toolbarem */
          left: 10px;
          right: 10px;
        }
      }

      /* Zv√Ω≈°en√≠ z-indexu pro AI panel, aby byl nad canvas controls */
      #toolsAi {
        z-index: 1001; /* Nad toolbarem */
      }

      /* --- TOUCH CURSOR (k≈ô√≠≈æek nad prstem na mobilu) --- */
      .touch-cursor {
        position: absolute;
        width: 40px;
        height: 40px;
        pointer-events: none;
        z-index: 10000;
        display: none;
        transform: translate(-50%, -50%);
      }

      .touch-cursor.active {
        display: block;
        animation: touchCursorAppear 0.2s ease-out;
      }

      @keyframes touchCursorAppear {
        from {
          opacity: 0;
          transform: translate(-50%, -50%) scale(0.5);
        }
        to {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1);
        }
      }

      .touch-cursor::before,
      .touch-cursor::after {
        content: "";
        position: absolute;
        background: #ff4444;
        box-shadow: 0 0 10px rgba(255, 68, 68, 0.8),
          0 0 3px rgba(255, 255, 255, 0.9);
      }

      /* Vertik√°ln√≠ ƒç√°ra */
      .touch-cursor::before {
        width: 2px;
        height: 40px;
        left: 50%;
        top: 0;
        transform: translateX(-50%);
      }

      /* Horizont√°ln√≠ ƒç√°ra */
      .touch-cursor::after {
        width: 40px;
        height: 2px;
        top: 50%;
        left: 0;
        transform: translateY(-50%);
      }

      /* St≈ôed k≈ô√≠≈æku - mal√Ω krou≈æek */
      .touch-cursor-center {
        position: absolute;
        width: 8px;
        height: 8px;
        background: #ff4444;
        border: 2px solid white;
        border-radius: 50%;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 5px rgba(255, 68, 68, 0.8);
      }

      .tool-submenu > * {
        pointer-events: auto;
      }

      @keyframes slideUp {
        from {
          transform: translateY(10px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .coords-panel {
        justify-content: center; /* Na mobilu radƒõji na st≈ôed */
        max-width: 500px;
        margin: 0 auto;
      }

      /* --- OVL√ÅD√ÅN√ç PL√ÅTNA (VPRAVO NAHO≈òE) --- */
      .canvas-controls {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 101;
      }

      .canvas-btn {
        background: rgba(42, 42, 42, 0.9);
        border: 1px solid #555;
        color: white;
        width: 48px;
        height: 48px;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(5px);
        transition: all 0.2s;
      }

      .canvas-btn span {
        font-size: 20px;
      }

      .canvas-btn div {
        font-size: 9px;
        margin-top: 2px;
      }

      .canvas-btn:active {
        transform: scale(0.95);
      }

      .canvas-btn.active {
        background: #3a7bc8;
        border-color: #5a9be8;
        box-shadow: 0 0 10px rgba(58, 123, 200, 0.5);
      }

      @media (max-width: 768px) {
        .toolbar {
          gap: 10px;
        }

        /* Mobil na v√Ω≈°ku - men≈°√≠ tlaƒç√≠tka, podobn√© jako Posun/Centr */
        @media (orientation: portrait) {
          .toolbar {
            bottom: max(30px, calc(20px + env(safe-area-inset-bottom)));
            left: 50%;
            right: auto;
            transform: translateX(-50%);
            width: auto;
            max-width: 98%;
          }

          .toolbar .tool-btn {
            min-width: 48px !important;
            max-width: 48px !important;
            min-height: 56px !important;
            width: 48px !important;
            height: auto !important;
            padding: 4px 2px !important;
            flex: 0 0 auto;
          }

          .toolbar .tool-btn span {
            font-size: 20px !important;
            margin: 0 !important;
          }

          .toolbar .tool-btn div {
            font-size: 8px !important;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 48px;
            margin-top: 2px !important;
          }
        }

        /* Mobil na ≈°√≠≈ôku - standardn√≠ velikost */
        @media (orientation: landscape) {
          .tool-btn {
            min-width: 60px;
            min-height: 60px;
            padding: 6px 8px;
          }

          .tool-btn span {
            font-size: 20px !important;
          }

          .tool-btn div {
            font-size: 10px !important;
          }
        }

        /* Controller Modal - Responzivn√≠ pro mobil */
        #controllerModal .modal-window {
          width: 95%;
          max-width: 100%;
          padding: 15px;
          max-height: 90vh;
          overflow-y: auto;
        }

        /* Zmƒõna layoutu na vertik√°ln√≠ pro mobil */
        #controllerLayout {
          display: flex !important;
          flex-direction: column !important;
          gap: 15px !important;
        }

        /* Smƒõrov√© tlaƒç√≠tka - men≈°√≠ na mobilu */
        .controller-btn {
          width: 55px !important;
          height: 55px !important;
        }

        .controller-btn span {
          font-size: 24px !important;
        }

        /* Grid pro smƒõrov√° tlaƒç√≠tka */
        #directionPad {
          grid-template-columns: repeat(3, 55px) !important;
          grid-template-rows: repeat(3, 55px) !important;
          gap: 3px !important;
        }

        /* Mini kl√°vesnice - men≈°√≠ tlaƒç√≠tka */
        .mini-key,
        .mini-key-action,
        .mini-key-back {
          padding: 5px !important;
          font-size: 11px !important;
        }

        .mini-key span,
        .mini-key-action span {
          font-size: 6px !important;
        }

        /* Nadpisy v controlleru men≈°√≠ */
        #controllerModal h2 {
          font-size: 14px !important;
        }

        #controllerModal h4 {
          font-size: 10px !important;
        }

        /* Controller input pole */
        #controllerInput {
          font-size: 13px !important;
          padding: 7px !important;
        }

        /* G90/G91 tlaƒç√≠tka */
        #btnG90,
        #btnG91 {
          padding: 6px 8px !important;
          font-size: 10px !important;
        }

        /* Confirm button */
        #controllerModal button[onclick="confirmControllerInput()"] {
          padding: 8px 12px !important;
          font-size: 14px !important;
        }

        /* Quick Input Keyboard - men≈°√≠ tlaƒç√≠tka */
        .keypad-btn {
          padding: 8px 0 !important;
          font-size: 14px !important;
        }

        .keypad-btn span {
          font-size: 8px !important;
        }

        /* Quick Input Modal */
        #quickInputModal .modal-window {
          width: 95%;
          max-width: 100%;
        }

        /* Canvas controls - men≈°√≠ na mobilu */
        .canvas-btn {
          width: 44px !important;
          height: 44px !important;
        }

        .canvas-btn span {
          font-size: 18px !important;
        }

        .canvas-btn small {
          font-size: 9px !important;
        }
      }

      /* Velmi mal√© displeje (mobily v portr√©tn√≠m m√≥du) */
      @media (max-width: 480px) {
        /* Toolbar - je≈°tƒõ men≈°√≠ tlaƒç√≠tka */
        .toolbar {
          gap: 6px;
          padding: 8px;
        }

        .tool-btn {
          min-width: 50px;
          min-height: 50px;
          padding: 4px 6px;
        }

        .tool-btn span {
          font-size: 18px !important;
        }

        .tool-btn div {
          font-size: 9px !important;
        }

        /* Controller - je≈°tƒõ men≈°√≠ */
        .controller-btn {
          width: 48px !important;
          height: 48px !important;
        }

        .controller-btn span {
          font-size: 20px !important;
        }

        #directionPad {
          grid-template-columns: repeat(3, 48px) !important;
          grid-template-rows: repeat(3, 48px) !important;
          gap: 2px !important;
        }

        /* Controller modal - scrollov√°n√≠ */
        #controllerModal .modal-window {
          max-height: 95vh;
          overflow-y: auto;
        }

        /* Mini kl√°vesnice v controlleru - je≈°tƒõ men≈°√≠ */
        .mini-key,
        .mini-key-action,
        .mini-key-back {
          padding: 4px !important;
          font-size: 10px !important;
        }

        .mini-key span,
        .mini-key-action span {
          font-size: 5px !important;
        }

        /* Controller input a tlaƒç√≠tka */
        #controllerInput {
          font-size: 12px !important;
          padding: 6px !important;
        }

        #btnG90,
        #btnG91 {
          padding: 5px 6px !important;
          font-size: 9px !important;
        }

        #controllerModal h2 {
          font-size: 12px !important;
        }

        #controllerModal h4 {
          font-size: 9px !important;
        }

        /* Mod√°ln√≠ okna - maxim√°ln√≠ vyu≈æit√≠ prostoru */
        .modal-window {
          width: 98%;
          padding: 12px;
        }

        #controllerModal h2 {
          font-size: 13px !important;
        }

        /* Keypad - kompaktnƒõj≈°√≠ */
        .keypad-grid {
          gap: 5px !important;
        }

        .keypad-btn {
          padding: 6px 0 !important;
          font-size: 13px !important;
        }
      }

      .tool-btn {
        background: rgba(42, 42, 42, 1);
        border: 1px solid #444;
        color: white;
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 13px;
        min-width: 65px;
        min-height: 65px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        user-select: none;
        /* Lep≈°√≠ st√≠n pro oddƒõlen√≠ od pozad√≠ */
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      }

      .tool-btn:hover {
        background: rgba(58, 123, 200, 0.8);
        border-color: #5a9be8;
        transform: translateY(-2px);
      }

      .tool-btn:active,
      .tool-btn.active {
        background: #3a7bc8;
        border-color: #5a9be8;
        box-shadow: 0 0 15px rgba(58, 123, 200, 0.6);
        transform: translateY(0);
      }

      /* --- AI STYL --- */
      .tool-btn.ai-btn {
        border-color: #8b5cf6;
        color: #e9d5ff;
      }

      .tool-btn.ai-btn.active {
        background: #7c3aed;
        border-color: #a78bfa;
        box-shadow: 0 0 15px rgba(124, 58, 237, 0.6);
      }

      /* CHAT STYLES */
      .chat-container {
        max-height: 40vh; /* Dynamic height to avoid overlapping top buttons */
        min-height: 150px;
        overflow-y: auto;
        background: #111;
        border: 1px solid #444;
        border-radius: 6px;
        padding: 10px;
        margin-bottom: 10px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .chat-msg {
        padding: 10px 14px;
        border-radius: 12px;
        max-width: 85%;
        font-size: 13px;
        line-height: 1.4;
        word-wrap: break-word;
        position: relative;
      }

      .chat-msg.user {
        align-self: flex-end;
        background: #3a7bc8;
        color: white;
        border-bottom-right-radius: 2px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      .chat-msg.model {
        align-self: flex-start;
        background: #2a2a2a;
        color: #e0e0e0;
        border-bottom-left-radius: 2px;
        border: 1px solid #444;
      }

      .chat-msg .shape-tag {
        display: inline-block;
        background: rgba(0, 0, 0, 0.3);
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 10px;
        margin-right: 4px;
        margin-top: 4px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .loading-dots {
        display: inline-flex;
        gap: 4px;
      }
      .loading-dots div {
        width: 6px;
        height: 6px;
        background: #aaa;
        border-radius: 50%;
        animation: bounce 1.4s infinite ease-in-out both;
      }
      .loading-dots div:nth-child(1) {
        animation-delay: -0.32s;
      }
      .loading-dots div:nth-child(2) {
        animation-delay: -0.16s;
      }

      @keyframes bounce {
        0%,
        80%,
        100% {
          transform: scale(0);
        }
        40% {
          transform: scale(1);
        }
      }

      .loading-spinner {
        width: 14px;
        height: 14px;
        border: 2px solid #fff;
        border-top-color: transparent;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      /* RECORDING ANIMATION */
      .recording-pulse {
        animation: pulse-red 1.5s infinite;
        background: #ef4444 !important;
        border-color: #dc2626 !important;
      }
      @keyframes pulse-red {
        0% {
          box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
        }
      }

      /* SELECTION CHIPS */
      .selection-list {
        display: flex;
        gap: 6px;
        overflow-x: auto;
        padding-bottom: 6px;
        margin-bottom: 8px;
      }

      .selection-chip {
        background: #2a2a2a;
        border: 1px solid #ff66ff;
        color: #ffccff;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 11px;
        white-space: nowrap;
        display: flex;
        align-items: center;
        gap: 4px;
      }
      .selection-chip .letter-badge {
        background: #ff66ff;
        color: #000;
        font-weight: bold;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
      }

      /* --- SETTINGS & QUICK INPUT MODAL STYL --- */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(4px);
        z-index: 2000;
        display: none; /* Default hidden */
        align-items: center;
        justify-content: center;
      }

      .modal-window {
        background: #1a1a1a;
        border: 1px solid #444;
        border-radius: 12px;
        width: 90%;
        max-width: 450px;
        padding: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        color: #e0e0e0;
      }

      /* Quick Input Display inside modal */
      .quick-input-display {
        width: 100%;
        background: #000;
        color: #0f0; /* CNC Screen style */
        font-family: "Courier New", monospace;
        font-size: 16px;
        font-weight: bold;
        padding: 12px;
        border: 1px solid #444;
        border-radius: 6px;
        margin-bottom: 12px;
        resize: none;
        outline: none;
        height: 60px;
      }

      /* KEYPAD GRID */
      .keypad-grid {
        display: grid;
        grid-template-columns: repeat(6, 1fr);
        gap: 8px;
        margin-top: 5px;
      }

      .keypad-btn {
        background: #2a2a2a;
        border: 1px solid #444;
        color: white;
        padding: 10px 0;
        border-radius: 6px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transition: background 0.1s;
      }

      .keypad-btn:active {
        background: #666;
        transform: translateY(2px);
      }

      .keypad-btn span {
        font-size: 9px;
        font-weight: normal;
        color: #888;
        margin-top: 2px;
      }

      .keypad-btn.action {
        background: #333;
        border-color: #555;
      }

      .keypad-btn.cnc-code {
        background: #2d3748; /* Blueish grey for G-code */
        border-color: #4a5568;
        color: #90cdf4;
      }

      .keypad-btn.confirm {
        grid-column: span 3;
        background: #3a7bc8;
        border-color: #5a9be8;
        padding: 12px;
      }

      .keypad-btn.backspace {
        background: #7f1d1d;
        border-color: #991b1b;
      }

      .keypad-btn.help {
        background: #1e3a5f;
        border-color: #2d5a8f;
        color: #90cdf4;
      }

      /* Controller Modal Styles */
      .controller-btn {
        background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
        border: 2px solid #4a5568;
        color: #e2e8f0;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      .controller-btn:hover {
        background: linear-gradient(135deg, #3d4758 0%, #2a303c 100%);
        border-color: #6b7280;
        transform: scale(1.05);
      }

      .controller-btn:active {
        background: linear-gradient(135deg, #4a5568 0%, #374151 100%);
        transform: scale(0.98);
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.4);
      }

      .mini-key,
      .mini-key-action,
      .mini-key-back {
        background: #2d3748;
        border: 1px solid #4a5568;
        color: #e2e8f0;
        border-radius: 6px;
        padding: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        transition: all 0.15s;
      }

      .mini-key:hover,
      .mini-key-action:hover {
        background: #374151;
        border-color: #6b7280;
      }

      .mini-key:active,
      .mini-key-action:active {
        background: #4a5568;
        transform: scale(0.95);
      }

      .mini-key-action {
        background: #1e3a5f;
        border-color: #2d5a8f;
        color: #90cdf4;
      }

      .mini-key-back {
        background: #7f1d1d;
        border-color: #991b1b;
        color: white;
      }

      .mini-key-back:hover {
        background: #991b1b;
      }

      .key-list {
        max-height: 200px;
        overflow-y: auto;
        margin: 10px 0;
        background: #111;
        border: 1px solid #333;
        border-radius: 6px;
      }

      .key-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px;
        border-bottom: 1px solid #333;
        cursor: pointer;
        transition: background 0.2s;
      }

      .key-item:last-child {
        border-bottom: none;
      }

      .key-item:hover {
        background: #252525;
      }

      .key-item.active {
        background: #2a3a2a;
        border-left: 3px solid #4ade80;
      }

      /* Styl pro demo kl√≠ƒç (defaultn√≠) */
      .key-item.demo-active {
        background: #2a2a3a;
        border-left: 3px solid #a78bfa;
      }

      .key-name {
        font-weight: bold;
        font-size: 14px;
        color: #fff;
      }

      .key-val {
        font-size: 11px;
        color: #777;
        font-family: monospace;
      }

      .key-delete {
        padding: 4px 8px;
        background: #991b1b;
        color: white;
        border-radius: 4px;
        font-size: 11px;
        border: none;
        cursor: pointer;
      }

      .key-save {
        padding: 4px 8px;
        background: #3a7bc8;
        color: white;
        border-radius: 4px;
        font-size: 11px;
        border: none;
        cursor: pointer;
      }

      /* --- INFO PANELY NAHO≈òE --- */
      .coords {
        position: absolute;
        top: 10px; /* Naho≈ôe */
        left: 10px; /* Vlevo */
        bottom: auto;

        background: rgba(26, 26, 26, 0.8);
        backdrop-filter: blur(4px);
        padding: 8px 12px;
        border-radius: 5px;
        font-family: "Courier New", monospace;
        font-size: 12px;
        border: 1px solid #444;
        pointer-events: none; /* Aby ≈°lo klikat skrz */
      }

      .snap-info {
        position: absolute;
        top: 45px; /* Pod sou≈ôadnicemi */
        left: 10px;
        bottom: auto;
        right: auto;
        transform: none;

        background: rgba(26, 26, 26, 0.9);
        padding: 8px 12px;
        border-radius: 5px;
        font-family: "Courier New", monospace;
        font-size: 12px;
        font-weight: normal;

        color: #ffd700;
        border: 1px solid #ffd700;

        display: none;
        z-index: 200;
        pointer-events: none;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
      }

      .snap-info.show {
        display: block;
      }

      .mode-info {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(74, 158, 255, 0.9);
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 13px;
        font-weight: 500;
        color: white;
        display: none;
        z-index: 90;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        pointer-events: none;
      }

      .mode-info.show {
        display: block;
      }

      .checkbox-group {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 8px 0;
      }

      .checkbox-group input[type="checkbox"] {
        width: auto;
        margin: 0;
      }

      /* --- DIALOG KRU≈ΩNICE STYL --- */
      .circle-input-row {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
      }
      .circle-input-row label {
        width: 80px;
        font-size: 13px;
        color: #ccc;
      }
      .circle-input-row input {
        flex: 1;
        background: #111;
        border: 1px solid #444;
        color: white;
        padding: 8px;
        border-radius: 4px;
      }
    </style>
    <!-- Import Map for Google GenAI -->
    <script type="importmap">
      {
        "imports": {
          "@google/genai": "https://esm.sh/@google/genai@^1.33.0"
        }
      }
    </script>
  </head>
  <body>
    <div class="canvas-area">
      <!-- Ovl√°d√°n√≠ pl√°tna vpravo naho≈ôe -->
      <div class="canvas-controls">
        <!-- Tlaƒç√≠tko nastaven√≠ odstranƒõno z hlavn√≠ho pohledu a p≈ôesunuto do AI panelu -->
        <button
          class="canvas-btn"
          onclick="window.togglePan()"
          id="btnPanCanvas"
          title="Posun (Klikni pro zapnut√≠/vypnut√≠)"
        >
          <span>‚úã</span>
          <div>Posun</div>
        </button>
        <button
          class="canvas-btn"
          onclick="window.resetView()"
          title="Zobrazit v≈°echny objekty (Fit All)"
        >
          <span>‚åñ</span>
          <div>Fit All</div>
        </button>
        <button
          class="canvas-btn"
          onclick="window.undo()"
          id="btnUndo"
          title="Zpƒõt - vr√°tit posledn√≠ akci (Ctrl+Z)"
        >
          <span>‚Ü∂</span>
          <div>Zpƒõt</div>
        </button>
        <button
          class="canvas-btn"
          onclick="window.redo()"
          id="btnRedo"
          title="Vp≈ôed - obnovit vr√°cenou akci (Ctrl+Y)"
        >
          <span>‚Ü∑</span>
          <div>Vp≈ôed</div>
        </button>
      </div>

      <!-- Submenu se vykresluj√≠ zde (nad toolbarem) -->

      <!-- === AI PANEL (NOV√ù CHAT) === -->
      <div
        class="tool-submenu"
        id="toolsAi"
        style="display: none; justify-content: center; width: 100%"
      >
        <!-- position: relative pro kontejner, aby bylo tlaƒç√≠tko absolutnƒõ k nƒõmu -->
        <div
          id="aiPanelContainer"
          style="
            position: relative;
            background: rgba(26, 26, 26, 0.95);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #555;
            width: 95%;
            max-width: 500px;
            box-shadow: 0 4px 25px rgba(0, 0, 0, 0.6);
          "
        >
          <!-- HEADER ROW (Title + Settings) -->
          <div
            id="aiHeaderRow"
            style="
              display: flex;
              justify-content: space-between;
              align-items: flex-start;
              margin-bottom: 10px;
            "
          >
            <div>
              <h3
                style="
                  color: #a78bfa;
                  margin: 0 0 5px 0;
                  font-weight: bold;
                  display: flex;
                  align-items: center;
                  gap: 8px;
                "
              >
                ‚ú® Gemini Chat
              </h3>
            </div>

            <div style="display: flex; gap: 8px; align-items: center">
              <!-- P≈ôep√≠naƒç modelu -->
              <select
                id="aiModelSelect"
                style="
                  background: #111;
                  color: #888;
                  border: 1px solid #444;
                  padding: 4px 8px;
                  border-radius: 4px;
                  font-size: 11px;
                  cursor: pointer;
                  outline: none;
                "
              >
                <option value="gemini-2.5-flash-lite">
                  ‚ö° Gemini 2.5 Flash-Lite (Vy≈°≈°√≠ limit)
                </option>
                <option value="gemini-2.5-flash" selected>
                  ‚ö° Gemini 2.5 Flash (Rychl√Ω)
                </option>
                <option value="gemini-3-pro-preview">
                  üß™ Gemini 3 Pro (Nejchyt≈ôej≈°√≠)
                </option>
                <option value="gemini-2.0-flash-exp">
                  ‚ö° Gemini 2.0 Flash (Exp)
                </option>
              </select>

              <!-- AI Memory Button -->
              <button
                onclick="showAIMemory()"
                title="AI Pamƒõ≈• - Co se AI nauƒçila"
                style="
                  background: transparent;
                  border: none;
                  cursor: pointer;
                  color: #888;
                  transition: color 0.2s;
                  padding: 4px;
                "
              >
                <span style="font-size: 16px">üß†</span>
              </button>

              <!-- AI Preferences Button (NEW) -->
              <button
                onclick="openAIPreferences()"
                title="Nastavit preference AI (uƒç√≠ se)"
                style="
                  background: transparent;
                  border: none;
                  cursor: pointer;
                  color: #888;
                  transition: color 0.2s;
                  padding: 4px;
                "
              >
                <span style="font-size: 16px">üéì</span>
              </button>

              <!-- Debug Metrics Button -->
              <button
                onclick="showAIMetrics()"
                title="Zobrazit AI statistiky"
                style="
                  background: transparent;
                  border: none;
                  cursor: pointer;
                  color: #888;
                  transition: color 0.2s;
                  padding: 4px;
                "
              >
                <span style="font-size: 16px">üìä</span>
              </button>

              <!-- Settings Button -->
              <button
                onclick="openSettings()"
                title="Nastaven√≠ API kl√≠ƒçe"
                style="
                  background: transparent;
                  border: none;
                  cursor: pointer;
                  color: #888;
                  transition: color 0.2s;
                  padding: 4px;
                "
              >
                <span style="font-size: 18px">‚öôÔ∏è</span>
              </button>
            </div>
          </div>

          <!-- Historie chatu -->
          <div id="aiChatHistory" class="chat-container">
            <div
              style="
                color: #666;
                font-size: 11px;
                text-align: center;
                margin-top: auto;
              "
            >
              Zaƒç√°tek konverzace. Zeptejte se na cokoliv nebo popi≈°te tvar.
            </div>

            <!-- Informace o povolen√≠ pro mobil -->
            <div
              id="permissionInfo"
              style="
                margin: 15px auto;
                padding: 10px;
                background: #1a2332;
                border: 1px solid #2563eb;
                border-radius: 8px;
                max-width: 90%;
                font-size: 10px;
                color: #93c5fd;
              "
            >
              <div
                style="
                  margin-bottom: 6px;
                  font-weight: bold;
                  color: #60a5fa;
                  font-size: 11px;
                "
              >
                ‚ÑπÔ∏è Pro plnou funkƒçnost na mobilu:
              </div>
              <div style="margin-bottom: 4px">
                üì∑ <strong>Kamera</strong> - pro focen√≠ n√°ƒçrt≈Ø
              </div>
              <div>üé§ <strong>Mikrofon</strong> - pro hlasov√© zad√°v√°n√≠</div>
              <div style="margin-top: 6px; font-size: 9px; opacity: 0.7">
                Povolen√≠ se vy≈æ√°daj√≠ p≈ôi prvn√≠m pou≈æit√≠.
              </div>
              <button
                onclick="document.getElementById('permissionInfo').style.display='none'"
                style="
                  margin-top: 8px;
                  padding: 4px 8px;
                  background: #1e40af;
                  border: none;
                  border-radius: 4px;
                  color: white;
                  font-size: 10px;
                  cursor: pointer;
                "
              >
                Rozum√≠m
              </button>
            </div>
          </div>

          <!-- Selection & Tools Toolbar (MOVED TOOLS HERE) -->
          <div
            style="
              display: flex;
              gap: 6px;
              margin-bottom: 8px;
              align-items: center;
              flex-wrap: wrap;
            "
          >
            <button
              id="btnAiSelect"
              onclick="window.toggleAiSelect()"
              style="
                flex: 0 0 70px;
                padding: 8px 4px;
                background: #333;
                border: 1px solid #444;
                border-radius: 6px;
                color: #ccc;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 4px;
                font-size: 11px;
                transition: all 0.2s;
              "
              title="P≈ôepnout re≈æim v√Ωbƒõru"
            >
              <span style="font-size: 14px">üëÜ</span> V√Ωbƒõr
            </button>

            <button
              onclick="window.openQuickInput()"
              style="
                flex: 1;
                padding: 8px 4px;
                background: #333;
                border: 1px solid #444;
                border-radius: 6px;
                color: white;
                cursor: pointer;
                font-size: 11px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 4px;
                min-width: 90px;
              "
              title="Rychl√© zad√°n√≠ (Kl√°vesnice)"
            >
              <span style="font-size: 16px">‚å®Ô∏è</span> Kl√°vesnice
            </button>

            <button
              onclick="window.aiUndo()"
              style="
                flex: 0 0 36px;
                padding: 8px 0;
                background: #333;
                border: 1px solid #444;
                border-radius: 6px;
                color: white;
                cursor: pointer;
                font-size: 16px;
              "
              title="Zpƒõt (Undo posledn√≠ AI akce)"
            >
              ‚Ü∂
            </button>

            <button
              onclick="window.aiRedo()"
              style="
                flex: 0 0 36px;
                padding: 8px 0;
                background: #333;
                border: 1px solid #444;
                border-radius: 6px;
                color: white;
                cursor: pointer;
                font-size: 16px;
              "
              title="Dop≈ôedu (Redo)"
            >
              ‚Ü∑
            </button>

            <!-- MOVED CAMERA -->
            <button
              onclick="document.getElementById('aiImageInput').click()"
              title="Nahr√°t obr√°zek / Vyfotit (vy≈æaduje povolen√≠ kamery na mobilu)"
              style="
                flex: 0 0 36px;
                padding: 8px 0;
                background: #333;
                color: white;
                border: 1px solid #444;
                border-radius: 6px;
                font-size: 16px;
                cursor: pointer;
              "
            >
              üì∑
            </button>
            <input
              type="file"
              id="aiImageInput"
              accept="image/*"
              capture="environment"
              style="display: none"
              onchange="window.handleImageSelect(this)"
            />

            <!-- MOVED VOICE -->
            <button
              onclick="window.toggleVoice()"
              id="btnVoice"
              title="Hlasov√© zad√°n√≠ (vy≈æaduje povolen√≠ mikrofonu)"
              style="
                flex: 0 0 36px;
                padding: 8px 0;
                background: #333;
                color: white;
                border: 1px solid #444;
                border-radius: 6px;
                font-size: 16px;
                cursor: pointer;
                transition: all 0.2s;
              "
            >
              üé§
            </button>

            <button
              onclick="window.clearSelection()"
              id="btnClearSelection"
              style="
                flex: 0 0 36px;
                padding: 8px 0;
                background: #991b1b;
                border: 1px solid #991b1b;
                border-radius: 6px;
                color: white;
                cursor: pointer;
                font-size: 14px;
                display: none;
              "
              title="Zru≈°it v√Ωbƒõr"
            >
              ‚úï
            </button>
          </div>

          <!-- Selection List (Horizontal Chips) -->
          <div
            id="aiSelectionList"
            class="selection-list"
            style="display: none"
          >
            <!-- Chips inserted via JS -->
          </div>

          <!-- Input z√≥na (SIMPLIFIED) -->
          <div id="aiInputZone">
            <!-- NEW THINKING CHECKBOX (DEEP THINK) -->
            <div
              style="
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 6px;
              "
            >
              <label
                style="
                  display: flex;
                  align-items: center;
                  gap: 6px;
                  font-size: 11px;
                  color: #a78bfa;
                  cursor: pointer;
                  user-select: none;
                "
              >
                <input
                  type="checkbox"
                  id="useThinking"
                  style="width: 14px; height: 14px; accent-color: #7c3aed"
                />
                <span
                  >üß† Deep Think
                  <span style="opacity: 0.7">(Gemini 3 Pro)</span></span
                >
              </label>
              <span
                id="aiFileName"
                style="
                  font-size: 10px;
                  color: #888;
                  max-width: 120px;
                  overflow: hidden;
                  text-overflow: ellipsis;
                  white-space: nowrap;
                "
              ></span>
            </div>

            <!-- Nahr√°v√°n√≠ obr√°zku (mini preview) -->
            <div
              id="aiImagePreview"
              style="
                display: none;
                margin-bottom: 6px;
                position: relative;
                background: #111;
                padding: 4px;
                border-radius: 4px;
                width: fit-content;
              "
            >
              <img
                id="aiPreviewImg"
                style="
                  max-height: 60px;
                  max-width: 100%;
                  border-radius: 2px;
                  display: block;
                "
              />
              <button
                onclick="window.clearImage()"
                style="
                  position: absolute;
                  top: -5px;
                  right: -5px;
                  background: #ef4444;
                  color: white;
                  border: 1px solid #991b1b;
                  border-radius: 50%;
                  width: 18px;
                  height: 18px;
                  font-size: 10px;
                  cursor: pointer;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-weight: bold;
                "
              >
                ‚úï
              </button>
            </div>

            <div style="display: flex; gap: 8px; align-items: flex-end">
              <!-- Buttons removed from here, expanded text area -->
              <div style="flex: 1; position: relative">
                <textarea
                  id="aiPrompt"
                  rows="1"
                  placeholder="Zpr√°va pro Gemini..."
                  onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); if(window.callGemini) { window.callGemini(); } else { if(window.aiModuleError) { alert('‚ùå AI modul se nepoda≈ôilo naƒç√≠st.\\n\\n' + window.aiModuleError.message + '\\n\\nZkuste:\\n‚Ä¢ Obnovit str√°nku (F5)\\n‚Ä¢ Ovƒõ≈ôit internetov√© p≈ôipojen√≠\\n‚Ä¢ Zkusit jin√Ω prohl√≠≈æeƒç'); } else { alert('‚è≥ AI modul se je≈°tƒõ naƒç√≠t√°...\\n\\nPokud to trv√° d√©le ne≈æ 5 sekund, zkuste obnovit str√°nku (F5).'); } } }"
                  style="
                    resize: none;
                    width: 100%;
                    padding: 10px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    border-radius: 6px;
                    color: #fff;
                    font-family: inherit;
                    max-height: 80px;
                    overflow-y: auto;
                  "
                ></textarea>
              </div>

              <button
                onclick="if(window.callGemini) { window.callGemini(); } else { if(window.aiModuleError) { alert('‚ùå AI modul se nepoda≈ôilo naƒç√≠st.\\n\\n' + window.aiModuleError.message + '\\n\\nZkuste:\\n‚Ä¢ Obnovit str√°nku (F5)\\n‚Ä¢ Ovƒõ≈ôit internetov√© p≈ôipojen√≠\\n‚Ä¢ Zkusit jin√Ω prohl√≠≈æeƒç'); } else { alert('‚è≥ AI modul se je≈°tƒõ naƒç√≠t√°...\\n\\nPokud to trv√° d√©le ne≈æ 5 sekund, zkuste obnovit str√°nku (F5).'); } }"
                id="btnGenerate"
                style="
                  padding: 10px;
                  background: #7c3aed;
                  color: white;
                  border: none;
                  border-radius: 6px;
                  font-weight: bold;
                  cursor: pointer;
                "
                title="Odeslat do AI"
              >
                ‚û§
              </button>

              <!-- DEBUG BUTTON -->
              <button
                onclick="
                            let msg = 'üîç DEBUG INFO:\\n\\n';
                            msg += '‚úì callGemini exists: ' + (typeof window.callGemini !== 'undefined') + '\\n';
                            msg += '‚úì API Key: ' + (window.getCurrentApiKey ? (window.getCurrentApiKey() ? 'SET' : 'NOT SET') : 'function missing') + '\\n';
                            msg += '‚úì Prompt: ' + document.getElementById('aiPrompt').value + '\\n';
                            console.log(msg);
                            alert(msg);
                        "
                style="
                  padding: 10px;
                  background: #555;
                  color: white;
                  border: none;
                  border-radius: 6px;
                  font-weight: bold;
                  cursor: pointer;
                  font-size: 12px;
                "
                title="Debug - zkontrolovat co nefunguje"
              >
                üêõ
              </button>
            </div>

            <div
              id="aiStatus"
              style="
                margin-top: 8px;
                font-size: 10px;
                color: #555;
                text-align: center;
                display: flex;
                justify-content: space-between;
                flex-direction: column;
              "
            >
              <span id="keyIndicator">API Kl√≠ƒç: ≈Ω√°dn√Ω</span>
              <div id="apiUsageInfo" style="margin-top: 4px"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Kreslen√≠ panel -->
      <div class="tool-submenu" id="toolsDrawing" style="display: none">
        <div
          style="
            background: rgba(26, 26, 26, 0.95);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #444;
            max-width: 500px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
          "
        >
          <div
            style="
              display: flex;
              flex-wrap: wrap;
              gap: 8px;
              justify-content: center;
            "
          >
            <!-- V√Ωbƒõr removed from here -->

            <!-- Z√°kladn√≠ n√°stroje -->
            <button
              class="tool-btn"
              onclick="window.setMode('line')"
              id="btnLine"
              title="Nakreslit ƒç√°ru"
              style="margin: 0"
            >
              <span style="font-size: 20px">üìè</span>
              <div style="font-size: 10px; margin-top: 2px">ƒå√°ra</div>
            </button>
            <button
              class="tool-btn"
              onclick="window.setMode('circle')"
              id="btnCircle"
              title="Nakreslit kru≈ænici"
              style="margin: 0"
            >
              <span style="font-size: 20px">‚≠ï</span>
              <div style="font-size: 10px; margin-top: 2px">Kru≈ænice</div>
            </button>
            <button
              class="tool-btn"
              onclick="window.setMode('arc')"
              id="btnArc"
              title="Nakreslit oblouk"
              style="margin: 0"
            >
              <span style="font-size: 20px">üåô</span>
              <div style="font-size: 10px; margin-top: 2px">Oblouk</div>
            </button>
            <button
              class="tool-btn"
              onclick="window.setMode('point')"
              id="btnPoint"
              title="Vytvo≈ôit bod"
              style="margin: 0"
            >
              <span style="font-size: 20px">üìç</span>
              <div style="font-size: 10px; margin-top: 2px">Bod</div>
            </button>

            <!-- Konstrukce -->
            <button
              class="tool-btn"
              onclick="window.setMode('tangent')"
              id="btnTangent"
              title="Teƒçna ke kru≈ænici"
              style="margin: 0"
            >
              <span style="font-size: 20px">‚üÇ</span>
              <div style="font-size: 10px; margin-top: 2px">Teƒçna</div>
            </button>
            <button
              class="tool-btn"
              onclick="window.setMode('perpendicular')"
              id="btnPerpendicular"
              title="Kolmice"
              style="margin: 0"
            >
              <span style="font-size: 20px">‚î¥</span>
              <div style="font-size: 10px; margin-top: 2px">Kolmice</div>
            </button>
            <button
              class="tool-btn"
              onclick="window.setMode('parallel')"
              id="btnParallel"
              title="Rovnobƒõ≈æka"
              style="margin: 0"
            >
              <span style="font-size: 20px">‚à•</span>
              <div style="font-size: 10px; margin-top: 2px">Rovnobƒõ≈æka</div>
            </button>
          </div>
          <div
            style="
              margin-top: 12px;
              padding-top: 8px;
              border-top: 1px solid #444;
            "
          >
            <label
              style="
                display: flex;
                align-items: center;
                gap: 8px;
                color: #ccc;
                font-size: 12px;
                cursor: pointer;
              "
            >
              <input
                type="checkbox"
                id="polarSnapCheckboxLegacy"
                onchange="window.togglePolarSnapLegacy()"
              />
              Pol√°rn√≠ p≈ôichycen√≠ (15¬∞, 30¬∞, 45¬∞...)
          </div>
        </div>
      </div>

      <!-- √öpravy n√°stroje -->
      <div class="tool-submenu" id="toolsEdit" style="display: none">
        <div
          style="
            background: rgba(26, 26, 26, 0.95);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #444;
            max-width: 500px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
          "
        >
          <div
            style="
              display: flex;
              flex-wrap: wrap;
              gap: 8px;
              justify-content: center;
            "
          >
            <!-- Editace -->
            <button
              class="tool-btn"
              onclick="window.setMode('trim')"
              id="btnTrim"
              title="O≈ôezat ƒç√°ru"
              style="margin: 0"
            >
              <span style="font-size: 20px">‚úÇÔ∏è</span>
              <div style="font-size: 10px; margin-top: 2px">O≈ô√≠znut√≠</div>
            </button>
            <button
              class="tool-btn"
              onclick="window.setMode('extend')"
              id="btnExtend"
              title="Prot√°hnout ƒç√°ru do pr≈Øseƒç√≠ku"
              style="margin: 0"
            >
              <span style="font-size: 20px">‚ÜîÔ∏è</span>
              <div style="font-size: 10px; margin-top: 2px">Prota≈æen√≠</div>
            </button>
            <button
              class="tool-btn"
              onclick="window.setMode('offset')"
              id="btnOffset"
              title="Odsadit objekt"
              style="margin: 0"
            >
              <span style="font-size: 20px">‚áÑ</span>
              <div style="font-size: 10px; margin-top: 2px">Odsazen√≠</div>
            </button>
            <button
              class="tool-btn"
              onclick="window.setMode('mirror')"
              id="btnMirror"
              title="Zrcadlit objekt"
              style="margin: 0"
            >
              <span style="font-size: 20px">ü™û</span>
              <div style="font-size: 10px; margin-top: 2px">Zrcadlit</div>
            </button>
            <button
              class="tool-btn"
              onclick="window.setMode('erase')"
              id="btnErase"
              title="Smazat objekt"
              style="margin: 0"
            >
              <span style="font-size: 20px">üóëÔ∏è</span>
              <div style="font-size: 10px; margin-top: 2px">Guma</div>
            </button>
            <button
              class="tool-btn"
              onclick="calculateIntersections()"
              id="btnIntersect"
              title="Spoƒç√≠tat v≈°echny pr≈Øseƒç√≠ky"
              style="margin: 0"
            >
              <span style="font-size: 20px">‚äó</span>
              <div style="font-size: 10px; margin-top: 2px">Pr≈Øseƒç√≠ky</div>
            </button>
            <button
              class="tool-btn"
              onclick="window.setMode('measure')"
              id="btnMeasure"
              title="Zmƒõ≈ôit rozmƒõry objektu"
              style="margin: 0"
            >
              <span style="font-size: 20px">üìè</span>
              <div style="font-size: 10px; margin-top: 2px">Mƒõ≈ôen√≠</div>
            </button>
            <button
              class="tool-btn"
              onclick="window.showConstraintModal()"
              id="btnConstraint"
              title="Fixace - aretov√°n√≠ objekt≈Ø"
              style="margin: 0"
            >
              <span style="font-size: 20px">üîí</span>
              <div style="font-size: 10px; margin-top: 2px">Fixace</div>
            </button>
            <button
              class="tool-btn"
              onclick="window.setMode('dimension')"
              id="btnDimension"
              title="K√≥tovat objekt (d√©lka, polomƒõr, sou≈ôadnice)"
              style="margin: 0"
            >
              <span style="font-size: 20px">üìê</span>
              <div style="font-size: 10px; margin-top: 2px">K√≥ta</div>
            </button>
            <button
              class="tool-btn"
              onclick="window.deleteAllDimensions()"
              id="btnDeleteDimensions"
              title="Smazat v≈°echny k√≥ty"
              style="margin: 0"
            >
              <span style="font-size: 20px">‚ùå</span>
              <div style="font-size: 10px; margin-top: 2px">Smazat k√≥ty</div>
            </button>
            <button
              class="tool-btn"
              onclick="window.dimensionAll()"
              id="btnDimensionAll"
              title="Okotovat v≈°echny ƒç√°ry a kru≈ænice"
              style="margin: 0"
            >
              <span style="font-size: 20px">üìè‚ú®</span>
              <div style="font-size: 10px; margin-top: 2px">Okotovat v≈°e</div>
            </button>
          </div>
        </div>
      </div>

      <!-- Sou≈ôadnice panel -->
      <div
        class="tool-submenu coords-panel"
        id="toolsCoords"
        style="display: none"
      >
        <div
          style="
            background: rgba(26, 26, 26, 0.95);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #444;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
          "
        >
          <!-- Bod -->
          <div style="margin-bottom: 8px">
            <div
              onclick="toggleCoordSection('coordBod')"
              style="
                cursor: pointer;
                padding: 10px;
                background: #2a2a2a;
                border-radius: 6px;
                display: flex;
                justify-content: space-between;
                align-items: center;
              "
            >
              <strong style="color: #6ab0ff; font-size: 13px">üìç Bod</strong>
              <span id="coordBodToggle" style="color: #888">‚ñº</span>
            </div>
            <div
              id="coordBod"
              style="
                display: none;
                padding: 10px;
                background: #1a1a1a;
                border-radius: 6px;
                margin-top: 4px;
              "
            >
              <div style="display: flex; gap: 8px; margin-bottom: 8px">
                <input
                  type="number"
                  id="quickPointZ"
                  placeholder="Z"
                  step="0.01"
                  style="
                    flex: 1;
                    padding: 8px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                    font-size: 14px;
                  "
                />
                <input
                  type="number"
                  id="quickPointX"
                  placeholder="X"
                  step="0.01"
                  style="
                    flex: 1;
                    padding: 8px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                    font-size: 14px;
                  "
                />
              </div>
              <div style="display: flex; gap: 8px">
                <button
                  onclick="setPointFromCursor()"
                  style="
                    padding: 10px;
                    background: #4a4a4a;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 13px;
                    flex: 1;
                  "
                >
                  üìç Z kurzoru
                </button>
                <button
                  onclick="quickAddPoint()"
                  style="
                    padding: 10px;
                    background: #3a7bc8;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 13px;
                    flex: 1;
                  "
                >
                  + P≈ôidat
                </button>
              </div>
            </div>
          </div>

          <!-- ƒå√°ra -->
          <div style="margin-bottom: 8px">
            <div
              onclick="toggleCoordSection('coordLine')"
              style="
                cursor: pointer;
                padding: 10px;
                background: #2a2a2a;
                border-radius: 6px;
                display: flex;
                justify-content: space-between;
                align-items: center;
              "
            >
              <strong style="color: #6ab0ff; font-size: 13px">üìè ƒå√°ra</strong>
              <span id="coordLineToggle" style="color: #888">‚ñº</span>
            </div>
            <div
              id="coordLine"
              style="
                display: none;
                padding: 10px;
                background: #1a1a1a;
                border-radius: 6px;
                margin-top: 4px;
              "
            >
              <div style="font-size: 12px; color: #888; margin-bottom: 4px">
                Bod 1:
              </div>
              <div style="display: flex; gap: 8px; margin-bottom: 8px">
                <input
                  type="number"
                  id="lineZ1"
                  placeholder="Z1"
                  step="0.01"
                  style="
                    flex: 1;
                    padding: 8px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                  "
                />
                <input
                  type="number"
                  id="lineX1"
                  placeholder="X1"
                  step="0.01"
                  style="
                    flex: 1;
                    padding: 8px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                  "
                />
                <button
                  onclick="setLineStart()"
                  style="
                    padding: 8px 12px;
                    background: #4a4a4a;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                  "
                >
                  üìç
                </button>
              </div>
              <div style="font-size: 12px; color: #888; margin-bottom: 4px">
                Bod 2:
              </div>
              <div style="display: flex; gap: 8px; margin-bottom: 8px">
                <input
                  type="number"
                  id="lineZ2"
                  placeholder="Z2"
                  step="0.01"
                  style="
                    flex: 1;
                    padding: 8px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                  "
                />
                <input
                  type="number"
                  id="lineX2"
                  placeholder="X2"
                  step="0.01"
                  style="
                    flex: 1;
                    padding: 8px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                  "
                />
                <button
                  onclick="setLineEnd()"
                  style="
                    padding: 8px 12px;
                    background: #4a4a4a;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                  "
                >
                  üìç
                </button>
              </div>
              <button
                onclick="addLineByCoords()"
                style="
                  padding: 10px;
                  background: #3a7bc8;
                  color: white;
                  border: none;
                  border-radius: 4px;
                  cursor: pointer;
                  font-size: 13px;
                  width: 100%;
                "
              >
                + Nakreslit
              </button>
            </div>
          </div>

          <!-- Kru≈ænice -->
          <div style="margin-bottom: 8px">
            <div
              onclick="toggleCoordSection('coordCircle')"
              style="
                cursor: pointer;
                padding: 10px;
                background: #2a2a2a;
                border-radius: 6px;
                display: flex;
                justify-content: space-between;
                align-items: center;
              "
            >
              <strong style="color: #6ab0ff; font-size: 13px"
                >‚≠ï Kru≈ænice</strong
              >
              <span id="coordCircleToggle" style="color: #888">‚ñº</span>
            </div>
            <div
              id="coordCircle"
              style="
                display: none;
                padding: 10px;
                background: #1a1a1a;
                border-radius: 6px;
                margin-top: 4px;
              "
            >
              <div style="font-size: 12px; color: #888; margin-bottom: 4px">
                St≈ôed:
              </div>
              <div style="display: flex; gap: 8px; margin-bottom: 8px">
                <input
                  type="number"
                  id="quickCircleZ"
                  placeholder="Z"
                  step="0.01"
                  style="
                    flex: 1;
                    padding: 8px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                  "
                />
                <input
                  type="number"
                  id="quickCircleX"
                  placeholder="X"
                  step="0.01"
                  style="
                    flex: 1;
                    padding: 8px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                  "
                />
                <button
                  onclick="setCircleCenter()"
                  style="
                    padding: 8px 12px;
                    background: #4a4a4a;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                  "
                >
                  üìç
                </button>
              </div>
              <div style="font-size: 12px; color: #888; margin-bottom: 4px">
                Polomƒõr:
              </div>
              <div style="display: flex; gap: 8px; margin-bottom: 8px">
                <input
                  type="number"
                  id="quickCircleR"
                  placeholder="R"
                  step="0.01"
                  style="
                    width: 100%;
                    padding: 8px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                  "
                />
              </div>
              <button
                onclick="quickAddCircle()"
                style="
                  padding: 10px;
                  background: #3a7bc8;
                  color: white;
                  border: none;
                  border-radius: 4px;
                  cursor: pointer;
                  font-size: 13px;
                  width: 100%;
                "
              >
                + Nakreslit
              </button>
            </div>
          </div>

          <!-- Pol√°rn√≠ sou≈ôadnice -->
          <div style="margin-bottom: 8px">
            <div
              onclick="toggleCoordSection('coordPolar')"
              style="
                cursor: pointer;
                padding: 10px;
                background: #2a2a2a;
                border-radius: 6px;
                display: flex;
                justify-content: space-between;
                align-items: center;
              "
            >
              <strong style="color: #6ab0ff; font-size: 13px"
                >üìê Pol√°rn√≠</strong
              >
              <span id="coordPolarToggle" style="color: #888">‚ñº</span>
            </div>
            <div
              id="coordPolar"
              style="
                display: none;
                padding: 10px;
                background: #1a1a1a;
                border-radius: 6px;
                margin-top: 4px;
              "
            >
              <div style="font-size: 12px; color: #888; margin-bottom: 4px">
                Poƒç√°teƒçn√≠ bod:
              </div>
              <div style="display: flex; gap: 8px; margin-bottom: 8px">
                <input
                  type="number"
                  id="polarStartZ"
                  placeholder="Z"
                  step="0.01"
                  style="
                    flex: 1;
                    padding: 8px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                  "
                />
                <input
                  type="number"
                  id="polarStartX"
                  placeholder="X"
                  step="0.01"
                  style="
                    flex: 1;
                    padding: 8px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                  "
                />
              </div>
              <div style="display: flex; gap: 8px; margin-bottom: 8px">
                <div style="flex: 1">
                  <div style="font-size: 12px; color: #888; margin-bottom: 2px">
                    Vzd√°lenost:
                  </div>
                  <input
                    type="number"
                    id="polarDist"
                    placeholder="mm"
                    step="0.1"
                    style="
                      width: 100%;
                      padding: 8px;
                      background: #0a0a0a;
                      border: 1px solid #444;
                      color: white;
                      border-radius: 4px;
                    "
                  />
                </div>
                <div style="flex: 1">
                  <div style="font-size: 12px; color: #888; margin-bottom: 2px">
                    √öhel:
                  </div>
                  <input
                    type="number"
                    id="polarAngle"
                    placeholder="¬∞"
                    step="1"
                    style="
                      width: 100%;
                      padding: 8px;
                      background: #0a0a0a;
                      border: 1px solid #444;
                      color: white;
                      border-radius: 4px;
                    "
                  />
                </div>
              </div>
              <div style="font-size: 11px; color: #666; margin-bottom: 8px">
                0¬∞ = vpravo, 90¬∞ = nahoru
              </div>
              <div style="display: flex; gap: 8px">
                <button
                  onclick="addLinePolar()"
                  style="
                    padding: 10px;
                    background: #3a7bc8;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 13px;
                    flex: 1;
                  "
                >
                  + ƒå√°ra
                </button>
                <button
                  onclick="addPointPolar()"
                  style="
                    padding: 10px;
                    background: #3a7bc8;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 13px;
                    flex: 1;
                  "
                >
                  + Bod
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Ostatn√≠ n√°stroje -->
      <div class="tool-submenu" id="toolsOther" style="display: none">
        <div
          style="
            background: rgba(26, 26, 26, 0.95);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #444;
            max-width: 500px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
          "
        >
          <!-- Transformace -->
          <div style="margin-bottom: 8px">
            <div
              style="padding: 8px 10px; background: #2a2a2a; border-radius: 6px"
            >
              <strong style="color: #6ab0ff; font-size: 13px"
                >üîÑ Transformace</strong
              >
            </div>
            <div
              style="display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap"
            >
              <button
                class="tool-btn"
                onclick="window.setMode('align')"
                title="Zarovnat a posunout: klik bod ‚Üí target ‚Üí √∫seƒçka ‚Üí osa"
                style="margin: 0; flex: 1; min-width: 100px"
              >
                <span style="font-size: 20px">‚öñÔ∏è</span>
                <div style="font-size: 10px; margin-top: 2px">Zarovn√°n√≠</div>
              </button>
              <button
                class="tool-btn"
                onclick="window.setMode('rotate')"
                title="Otoƒçen√≠: vybrat objekty ‚Üí zadat √∫hel"
                style="margin: 0; flex: 1; min-width: 100px"
              >
                <span style="font-size: 20px">üîÅ</span>
                <div style="font-size: 10px; margin-top: 2px">Rotace</div>
              </button>
              <button
                class="tool-btn"
                onclick="window.showColorPicker()"
                title="Barva objektu"
                style="margin: 0; flex: 1; min-width: 100px"
              >
                <span style="font-size: 20px">üé®</span>
                <div style="font-size: 10px; margin-top: 2px">Barva</div>
              </button>
            </div>
          </div>

          <!-- Boolean operace -->
          <div style="margin-bottom: 8px">
            <div
              style="padding: 8px 10px; background: #2a2a2a; border-radius: 6px"
            >
              <strong style="color: #6ab0ff; font-size: 13px"
                >üîó Booleovsk√© operace</strong
              >
            </div>
            <div
              style="display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap"
            >
              <button
                class="tool-btn"
                onclick="window.booleanUnion()"
                title="Sjednocen√≠ vybran\u00fdch objekt≈Ø"
                style="margin: 0; flex: 1; min-width: 100px"
              >
                <span style="font-size: 20px">‚à™</span>
                <div style="font-size: 10px; margin-top: 2px">Sjednocen√≠</div>
              </button>
              <button
                class="tool-btn"
                onclick="window.booleanIntersect()"
                title="Pr≈Ønik vybran\u00fdch objekt≈Ø"
                style="margin: 0; flex: 1; min-width: 100px"
              >
                <span style="font-size: 20px">‚à©</span>
                <div style="font-size: 10px; margin-top: 2px">Pr≈Ønik</div>
              </button>
              <button
                class="tool-btn"
                onclick="window.booleanDifference()"
                title="Rozd√≠l vybran\u00fdch objekt≈Ø"
                style="margin: 0; flex: 1; min-width: 100px"
              >
                <span style="font-size: 20px">‚àí</span>
                <div style="font-size: 10px; margin-top: 2px">Rozd√≠l</div>
              </button>
            </div>
          </div>

          <!-- Akce -->
          <div style="margin-bottom: 8px">
            <div
              style="padding: 8px 10px; background: #2a2a2a; border-radius: 6px"
            >
              <strong style="color: #6ab0ff; font-size: 13px">‚ö° Akce</strong>
            </div>
            <div
              style="display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap"
            >
              <button
                class="tool-btn"
                onclick="undo()"
                title="Vr√°tit zpƒõt posledn√≠ akci"
                style="margin: 0; flex: 1; min-width: 80px"
              >
                <span style="font-size: 24px">‚Ü∂</span>
                <div style="font-size: 11px; margin-top: 2px">Zpƒõt</div>
              </button>
              <button
                class="tool-btn"
                onclick="clearAll()"
                title="Vymazat v≈°e"
                style="margin: 0; flex: 1; min-width: 80px"
              >
                <span style="font-size: 24px">üóëÔ∏è</span>
                <div style="font-size: 11px; margin-top: 2px">Vymazat</div>
              </button>
              <button
                class="tool-btn"
                onclick="exportPNG()"
                title="Exportovat jako PNG"
                style="margin: 0; flex: 1; min-width: 80px"
              >
                <span style="font-size: 24px">üíæ</span>
                <div style="font-size: 11px; margin-top: 2px">Export PNG</div>
              </button>
            </div>
            <div
              style="display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap"
            >
              <button
                class="tool-btn"
                onclick="saveProject()"
                title="Ulo≈æit projekt jako soubor"
                style="margin: 0; flex: 1; min-width: 120px"
              >
                <span style="font-size: 24px">üíæ</span>
                <div style="font-size: 11px; margin-top: 2px">
                  Ulo≈æit projekt
                </div>
              </button>
              <button
                class="tool-btn"
                onclick="document.getElementById('loadProjectInput').click()"
                title="Naƒç√≠st projekt ze souboru"
                style="margin: 0; flex: 1; min-width: 120px"
              >
                <span style="font-size: 24px">üìÇ</span>
                <div style="font-size: 11px; margin-top: 2px">
                  Naƒç√≠st projekt
                </div>
              </button>
<<<<<<< HEAD
              <button
                class="tool-btn"
                onclick="document.getElementById('importSimDxfInput').click()"
                title="Importovat z SimDxf JSON"
                style="margin: 0; flex: 1; min-width: 120px"
              >
                <span style="font-size: 24px">üì•</span>
                <div style="font-size: 11px; margin-top: 2px">
                  Import SimDxf
                </div>
              </button>
=======
>>>>>>> e52642107a8edc8ab34a98eec0d608b52fdb2926
              <input
                type="file"
                id="loadProjectInput"
                accept=".json"
                style="display: none"
                onchange="loadProject(this)"
              />
<<<<<<< HEAD
              <input
                type="file"
                id="importSimDxfInput"
                accept=".json"
                style="display: none"
                onchange="importSimDxfProject(this)"
              />
=======
>>>>>>> e52642107a8edc8ab34a98eec0d608b52fdb2926
            </div>
          </div>

          <!-- Kreslic√≠ pom≈Øcky -->
          <div style="margin-bottom: 8px">
            <div
              onclick="toggleCoordSection('otherHelpers')"
              style="
                cursor: pointer;
                padding: 10px;
                background: #2a2a2a;
                border-radius: 6px;
                display: flex;
                justify-content: space-between;
                align-items: center;
              "
            >
              <strong style="color: #6ab0ff; font-size: 13px"
                >üìç P≈ôichycen√≠</strong
              >
              <span id="otherHelpersToggle" style="color: #888">‚ñº</span>
            </div>
            <div
              id="otherHelpers"
              style="
                display: none;
                padding: 10px;
                background: #1a1a1a;
                border-radius: 6px;
                margin-top: 4px;
              "
            >
              <div style="margin-bottom: 10px">
                <label
                  style="
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    cursor: pointer;
                    font-size: 13px;
                  "
                >
                  <input
                    type="checkbox"
                    id="snapGrid"
                    onchange="updateSnap()"
                    style="width: 18px; height: 18px"
                  />
                  <span>P≈ôichycen√≠ k m≈ô√≠≈æce</span>
                </label>
              </div>
              <div style="margin-bottom: 10px">
                <label
                  style="
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    cursor: pointer;
                    font-size: 13px;
                  "
                >
                  <input
                    type="checkbox"
                    id="snapPoints"
                    checked
                    onchange="updateSnap()"
                    style="width: 18px; height: 18px"
                  />
                  <span>P≈ôichycen√≠ k bod≈Øm</span>
                </label>
              </div>
              <div style="margin-bottom: 10px">
                <label
                  style="
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    cursor: pointer;
                    font-size: 13px;
                  "
                >
                  <input
                    type="checkbox"
                    id="orthoMode"
                    checked
                    onchange="updateSnap()"
                    style="width: 18px; height: 18px"
                  />
                  <span>Ortogon√°ln√≠ p≈ôichycen√≠ (‚Üî‚Üï)</span>
                </label>
              </div>
              <div style="margin-bottom: 10px">
                <label
                  style="
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    cursor: pointer;
                    font-size: 13px;
                  "
                >
                  <input
                    type="checkbox"
                    id="polarSnapCheckbox"
                    onchange="window.updatePolarSnap()"
                    style="width: 18px; height: 18px"
                  />
                  <span>Pol√°rn√≠ p≈ôichycen√≠ (üß≤)</span>
                </label>
                <div style="margin-top: 6px; margin-left: 28px">
                  <label
                    style="
                      font-size: 12px;
                      color: #888;
                      display: block;
                      margin-bottom: 4px;
                    "
                    >√öhel p≈ôichycen√≠ (¬∞):</label
                  >
                  <input
                    type="number"
                    id="polarSnapAngle"
                    value="15"
                    min="1"
                    max="90"
                    step="1"
                    onchange="window.updatePolarSnap()"
                    oninput="window.updatePolarSnap()"
                    style="
                      width: 100%;
                      padding: 6px;
                      background: #0a0a0a;
                      border: 1px solid #444;
                      color: white;
                      border-radius: 4px;
                      font-size: 12px;
                    "
                  />
                </div>
              </div>
              <div style="margin-bottom: 10px">
                <label
                  style="
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    cursor: pointer;
                    font-size: 13px;
                  "
                >
                  <input
                    type="checkbox"
                    id="showPoints"
                    checked
                    onchange="draw()"
                    style="width: 18px; height: 18px"
                  />
                  <span>Zobrazit body</span>
                </label>
              </div>
              <div>
                <label
                  style="
                    font-size: 12px;
                    color: #888;
                    display: block;
                    margin-bottom: 4px;
                  "
                  >Vzd√°lenost p≈ôichycen√≠ (px):</label
                >
                <input
                  type="number"
                  id="snapDistance"
                  value="15"
                  min="5"
                  max="50"
                  step="5"
                  style="
                    width: 100%;
                    padding: 8px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                    font-size: 14px;
                  "
                />
              </div>
            </div>
          </div>

          <!-- Zobrazen√≠ -->
          <div style="margin-bottom: 8px">
            <div
              onclick="toggleCoordSection('otherDisplay')"
              style="
                cursor: pointer;
                padding: 10px;
                background: #2a2a2a;
                border-radius: 6px;
                display: flex;
                justify-content: space-between;
                align-items: center;
              "
            >
              <strong style="color: #6ab0ff; font-size: 13px"
                >üé® Zobrazen√≠</strong
              >
              <span id="otherDisplayToggle" style="color: #888">‚ñº</span>
            </div>
            <div
              id="otherDisplay"
              style="
                display: none;
                padding: 10px;
                background: #1a1a1a;
                border-radius: 6px;
                margin-top: 4px;
              "
            >
              <!-- M≈ô√≠≈æka -->
              <div style="margin-bottom: 12px">
                <label
                  style="
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    cursor: pointer;
                    font-size: 13px;
                    margin-bottom: 6px;
                  "
                >
                  <input
                    type="checkbox"
                    id="showGrid"
                    checked
                    onchange="draw()"
                    style="width: 18px; height: 18px"
                  />
                  <span>M≈ô√≠≈æka</span>
                </label>
                <label
                  style="
                    font-size: 12px;
                    color: #888;
                    display: block;
                    margin-bottom: 4px;
                  "
                  >Rozestup (mm):</label
                >
                <input
                  type="number"
                  id="gridSpacing"
                  value="10"
                  min="0.01"
                  max="100"
                  step="0.01"
                  onchange="updateGridSpacing()"
                  style="
                    width: 100%;
                    padding: 8px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                    font-size: 14px;
                    margin-bottom: 6px;
                  "
                />
                <div style="display: flex; gap: 6px">
                  <button
                    onclick="setGridSpacing(0.1)"
                    style="
                      flex: 1;
                      padding: 6px;
                      background: #3a3a3a;
                      color: white;
                      border: none;
                      border-radius: 4px;
                      cursor: pointer;
                      font-size: 12px;
                    "
                  >
                    0.1mm
                  </button>
                  <button
                    onclick="setGridSpacing(1)"
                    style="
                      flex: 1;
                      padding: 6px;
                      background: #3a3a3a;
                      color: white;
                      border: none;
                      border-radius: 4px;
                      cursor: pointer;
                      font-size: 12px;
                    "
                  >
                    1mm
                  </button>
                  <button
                    onclick="setGridSpacing(5)"
                    style="
                      flex: 1;
                      padding: 6px;
                      background: #3a3a3a;
                      color: white;
                      border: none;
                      border-radius: 4px;
                      cursor: pointer;
                      font-size: 12px;
                    "
                  >
                    5mm
                  </button>
                  <button
                    onclick="setGridSpacing(10)"
                    style="
                      flex: 1;
                      padding: 6px;
                      background: #3a3a3a;
                      color: white;
                      border: none;
                      border-radius: 4px;
                      cursor: pointer;
                      font-size: 12px;
                    "
                  >
                    10mm
                  </button>
                </div>
              </div>

              <!-- Osy -->
              <div style="margin-bottom: 12px">
                <label
                  style="
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    cursor: pointer;
                    font-size: 13px;
                    margin-bottom: 6px;
                  "
                >
                  <input
                    type="checkbox"
                    id="showAxes"
                    checked
                    onchange="draw()"
                    style="width: 18px; height: 18px"
                  />
                  <span>Osy</span>
                </label>
                <label
                  style="
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    cursor: pointer;
                    font-size: 13px;
                    margin-bottom: 6px;
                  "
                >
                  <input
                    type="checkbox"
                    id="showAxisLabels"
                    checked
                    onchange="draw()"
                    style="width: 18px; height: 18px"
                  />
                  <span>Popisky os</span>
                </label>
                <label
                  style="
                    font-size: 12px;
                    color: #888;
                    display: block;
                    margin-bottom: 4px;
                  "
                  >Orientace:</label
                >
                <select
                  id="axisMode"
                  onchange="changeAxisMode()"
                  style="
                    width: 100%;
                    padding: 8px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                    font-size: 14px;
                    margin-bottom: 6px;
                  "
                >
                  <option value="lathe" selected>Soustruh (Z‚Üí, X‚Üë)</option>
                  <option value="carousel">Karusel (X‚Üí, Y‚Üë)</option>
                </select>

                <!-- Re≈æim mƒõ≈ôen√≠ X -->
                <label
                  style="
                    font-size: 12px;
                    color: #888;
                    display: block;
                    margin-bottom: 4px;
                  "
                  >Mƒõ≈ôen√≠ X:</label
                >
                <select
                  id="xMeasureSelect"
                  onchange="changeXMeasure()"
                  style="
                    width: 100%;
                    padding: 8px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                    font-size: 14px;
                  "
                >
                  <option value="diameter" selected>Pr≈Ømƒõr (‚åÄ)</option>
                  <option value="radius">Polomƒõr (R)</option>
                </select>
              </div>

              <!-- Ostatn√≠ -->
              <div style="margin-bottom: 8px">
                <label
                  style="
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    cursor: pointer;
                    font-size: 13px;
                    margin-bottom: 6px;
                  "
                >
                  <input
                    type="checkbox"
                    id="showDims"
                    checked
                    onchange="draw()"
                    style="width: 18px; height: 18px"
                  />
                  <span>K√≥ty</span>
                </label>
                <label
                  style="
                    font-size: 12px;
                    color: #888;
                    display: block;
                    margin-bottom: 4px;
                  "
                  >Zobrazen√≠ ƒç√≠sel:</label
                >
                <select
                  id="decimalsSelect"
                  onchange="changeDecimals()"
                  style="
                    width: 100%;
                    padding: 8px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                    font-size: 14px;
                    margin-bottom: 8px;
                  "
                >
                  <option value="2">2 desetinn√° m√≠sta</option>
                  <option value="3">3 desetinn√° m√≠sta</option>
                </select>
                <label
                  style="
                    font-size: 12px;
                    color: #888;
                    display: block;
                    margin-bottom: 4px;
                  "
                  >Mƒõ≈ô√≠tko:</label
                >
                <select
                  id="scaleSelect"
                  onchange="changeScale()"
                  style="
                    width: 100%;
                    padding: 8px;
                    background: #0a0a0a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                    font-size: 14px;
                  "
                >
                  <option value="0.5">1:2</option>
                  <option value="1" selected>1:1</option>
                  <option value="2">2:1</option>
                  <option value="5">5:1</option>
                </select>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Toolbar dole -->
      <div class="toolbar">
        <button
          class="tool-btn"
          onclick="window.showControllerModal()"
          id="btnController"
          title="Ovladaƒç pro rychl√© kreslen√≠ √∫seƒçek"
        >
          <span style="font-size: 24px">üéÆ</span>
          <div style="font-size: 11px; margin-top: 4px">Ovladaƒç</div>
        </button>
        <button
          class="tool-btn"
          onclick="window.showToolCategory('drawing')"
          id="btnCatDrawing"
          title="N√°stroje pro kreslen√≠ a konstrukce"
        >
          <span style="font-size: 24px">‚úèÔ∏è</span>
          <div style="font-size: 11px; margin-top: 4px">Kreslen√≠</div>
        </button>
        <button
          class="tool-btn"
          onclick="window.showToolCategory('edit')"
          id="btnCatEdit"
          title="N√°stroje pro √∫pravu objekt≈Ø"
        >
          <span style="font-size: 24px">üîß</span>
          <div style="font-size: 11px; margin-top: 4px">√öpravy</div>
        </button>
        <button
          class="tool-btn"
          onclick="window.showToolCategory('coords')"
          id="btnCatCoords"
          title="P≈ôesn√© zad√°n√≠ sou≈ôadnic"
        >
          <span style="font-size: 24px">üìê</span>
          <div style="font-size: 11px; margin-top: 4px">Sou≈ôadnice</div>
        </button>
        <button
          class="tool-btn"
          onclick="window.showToolCategory('other')"
          id="btnCatOther"
          title="Ostatn√≠ n√°stroje"
        >
          <span style="font-size: 24px">‚öôÔ∏è</span>
          <div style="font-size: 11px; margin-top: 4px">Ostatn√≠</div>
        </button>

        <!-- AI Tlaƒç√≠tko (P≈ôid√°no) -->
        <div
          style="width: 1px; height: 40px; background: #333; margin: 0 5px"
        ></div>

        <button
          class="tool-btn ai-btn"
          onclick="window.showToolCategory('ai')"
          id="btnCatAi"
          title="AI Asistent"
        >
          <span style="font-size: 24px">‚ú®</span>
          <div style="font-size: 11px; margin-top: 4px">AI</div>
        </button>
      </div>

      <canvas id="canvas"></canvas>

      <!-- Touch cursor - k≈ô√≠≈æek pro p≈ôesn√© zamƒõ≈ôen√≠ na mobilu -->
      <div class="touch-cursor" id="touchCursor">
        <div class="touch-cursor-center"></div>
      </div>

      <div class="coords" id="coords">Z: 0.00 | X: 0.00 mm</div>
      <div class="snap-info" id="snapInfo"></div>
      <div class="mode-info" id="modeInfo"></div>
    </div>

    <!-- MOD√ÅLN√ç OKNO NASTAVEN√ç (NOV√â) -->
    <div id="settingsModal" class="modal-overlay">
      <div class="modal-window">
        <h2 style="margin-bottom: 15px; color: #6ab0ff; font-size: 18px">
          ‚öôÔ∏è Nastaven√≠ API Kl√≠ƒç≈Ø
        </h2>

        <p style="font-size: 13px; color: #aaa; margin-bottom: 10px">
          Pro pou≈æit√≠ AI funkc√≠ (Gemini) je pot≈ôeba vlo≈æit API kl√≠ƒç. Kl√≠ƒçe jsou
          ulo≈æeny pouze ve va≈°em prohl√≠≈æeƒçi.
          <a
            href="https://aistudio.google.com/app/apikey"
            target="_blank"
            style="color: #6ab0ff"
            >Z√≠skat kl√≠ƒç zde</a
          >.
        </p>

        <!-- Seznam kl√≠ƒç≈Ø -->
        <div style="font-size: 12px; color: #888">Ulo≈æen√© kl√≠ƒçe:</div>
        <div id="keyList" class="key-list">
          <!-- Zde se dynamicky vygeneruj√≠ kl√≠ƒçe -->
          <div
            style="
              padding: 10px;
              color: #555;
              font-style: italic;
              text-align: center;
            "
          >
            ≈Ω√°dn√© kl√≠ƒçe
          </div>
        </div>

        <!-- P≈ôid√°n√≠ nov√©ho kl√≠ƒçe -->
        <div
          style="
            background: #222;
            padding: 12px;
            border-radius: 6px;
            margin-top: 15px;
          "
        >
          <div style="margin-bottom: 8px">
            <label style="font-size: 11px; display: block; margin-bottom: 2px"
              >N√°zev (nap≈ô. Pracovn√≠):</label
            >
            <input
              type="text"
              id="newKeyName"
              placeholder="M≈Øj kl√≠ƒç"
              style="
                width: 100%;
                background: #111;
                border: 1px solid #444;
                color: white;
                padding: 6px;
                border-radius: 4px;
              "
            />
          </div>
          <div style="margin-bottom: 8px">
            <label style="font-size: 11px; display: block; margin-bottom: 2px"
              >API Key (zaƒç√≠n√° AIza...):</label
            >
            <input
              type="password"
              id="newKeyValue"
              placeholder="AIza..."
              style="
                width: 100%;
                background: #111;
                border: 1px solid #444;
                color: white;
                padding: 6px;
                border-radius: 4px;
              "
            />
          </div>
          <button
            onclick="addApiKey()"
            style="
              width: 100%;
              padding: 8px;
              background: #3a7bc8;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 13px;
            "
          >
            + P≈ôidat a pou≈æ√≠t
          </button>
        </div>

        <div style="margin-top: 15px; text-align: right">
          <button
            onclick="closeSettings()"
            style="
              padding: 8px 16px;
              background: #444;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
            "
          >
            Zav≈ô√≠t
          </button>
        </div>
      </div>
    </div>

    <!-- MOD√ÅLN√ç OKNO AI PREFERENCE (NOV√â) -->
    <div id="aiPreferencesModal" class="modal-overlay" style="display: none">
      <div class="modal-window">
        <h2 style="margin-bottom: 15px; color: #6ab0ff; font-size: 18px">
          üéì AI Preference (AI se uƒç√≠)
        </h2>

        <p style="font-size: 12px; color: #aaa; margin-bottom: 15px">
          Nastavte sv√© preference a AI se nauƒç√≠ je respektovat. M≈Ø≈æete nastavit
          preferovanou terminologii, rozmƒõry, nebo zp≈Øsob pr√°ce.
        </p>

        <div
          style="
            background: #222;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
          "
        >
          <h3 style="color: #6ab0ff; font-size: 14px; margin-bottom: 10px">
            üìù Nastaven√© preference:
          </h3>
          <div id="preferencesList" style="font-size: 12px; color: #ccc">
            <div
              style="
                padding: 10px;
                color: #555;
                font-style: italic;
                text-align: center;
              "
            >
              Zat√≠m ≈æ√°dn√© preference
            </div>
          </div>
        </div>

        <div style="background: #222; padding: 12px; border-radius: 6px">
          <h3 style="color: #6ab0ff; font-size: 14px; margin-bottom: 10px">
            ‚ûï P≈ôidat preferenci:
          </h3>
          <div style="margin-bottom: 8px">
            <label style="font-size: 11px; display: block; margin-bottom: 2px"
              >Kl√≠ƒç (nap≈ô. "default_diameter", "terminology"):</label
            >
            <input
              type="text"
              id="newPrefKey"
              placeholder="nap≈ô. material"
              style="
                width: 100%;
                background: #111;
                border: 1px solid #444;
                color: white;
                padding: 6px;
                border-radius: 4px;
              "
            />
          </div>
          <div style="margin-bottom: 8px">
            <label style="font-size: 11px; display: block; margin-bottom: 2px"
              >Hodnota (nap≈ô. "80mm", "ƒçesky bez ciz√≠ch slov"):</label
            >
            <input
              type="text"
              id="newPrefValue"
              placeholder="nap≈ô. ocel"
              style="
                width: 100%;
                background: #111;
                border: 1px solid #444;
                color: white;
                padding: 6px;
                border-radius: 4px;
              "
            />
          </div>
          <button
            onclick="addAIPreference()"
            style="
              width: 100%;
              padding: 8px;
              background: #3a7bc8;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 13px;
            "
          >
            + P≈ôidat
          </button>
        </div>

        <div
          style="
            margin-top: 10px;
            padding: 10px;
            background: #1a2a1a;
            border-radius: 6px;
            border: 1px solid #2a4a2a;
            font-size: 11px;
          "
        >
          üí° <strong>P≈ô√≠klady preferenc√≠:</strong><br />
          ‚Ä¢ <code>default_diameter: 50mm</code> - Preferovan√Ω pr≈Ømƒõr<br />
          ‚Ä¢ <code>terminology: pouze ƒçesky</code> - Jazykov√Ω styl<br />
          ‚Ä¢ <code>precision: 2 desetinn√° m√≠sta</code> - P≈ôesnost<br />
          ‚Ä¢ <code>working_area: 0-200mm</code> - Pracovn√≠ rozsah
        </div>

        <div style="margin-top: 15px; text-align: right">
          <button
            onclick="closeAIPreferences()"
            style="
              padding: 8px 16px;
              background: #444;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
            "
          >
            Zav≈ô√≠t
          </button>
        </div>
      </div>
    </div>

    <!-- MOD√ÅLN√ç OKNO KRU≈ΩNICE (NOV√â) -->
    <div id="circleModal" class="modal-overlay">
      <div class="modal-window">
        <h2 style="margin-bottom: 15px; color: #6ab0ff; font-size: 18px">
          ‚≠ï Zad√°n√≠ kru≈ænice
        </h2>

        <div class="circle-input-row">
          <label>Polomƒõr (R):</label>
          <input
            type="number"
            id="circleInputR"
            step="0.01"
            oninput="updateCircleInputs('R')"
            onkeydown="if(event.key==='Enter') confirmCircle()"
          />
        </div>

        <div class="circle-input-row">
          <label>Pr≈Ømƒõr (D):</label>
          <input
            type="number"
            id="circleInputD"
            step="0.01"
            oninput="updateCircleInputs('D')"
            onkeydown="if(event.key==='Enter') confirmCircle()"
          />
        </div>

        <div
          style="
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
          "
        >
          <button
            onclick="closeCircleModal()"
            style="
              padding: 8px 16px;
              background: #444;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
            "
          >
            Zru≈°it
          </button>
          <button
            onclick="confirmCircle()"
            style="
              padding: 8px 16px;
              background: #3a7bc8;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-weight: bold;
            "
          >
            Vytvo≈ôit
          </button>
        </div>
      </div>
    </div>

    <!-- MOD√ÅLN√ç OKNO FIXACE (ARETOV√ÅN√ç) -->
    <div id="constraintModal" class="modal-overlay">
      <div class="modal-window">
        <h2 style="margin-bottom: 15px; color: #6ab0ff; font-size: 18px">
          üîí Fixace - Aretov√°n√≠ objekt≈Ø
        </h2>

        <p
          style="
            color: #aaa;
            font-size: 12px;
            margin-bottom: 15px;
            text-align: center;
          "
        >
          Vyberte typ fixace pro aretov√°n√≠ vybran√Ωch objekt≈Ø
        </p>

        <div
          style="
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
          "
        >
          <!-- Fixace typu BOD -->
          <button
            onclick="window.applyConstraint('point')"
            style="
              padding: 10px 12px;
              background: #2a3a4a;
              color: #aaa;
              border: 1px solid #555;
              border-radius: 4px;
              cursor: pointer;
              font-size: 11px;
              min-width: 70px;
              transition: all 0.2s;
            "
            onmouseover="this.style.background='#3a5a7a'; this.style.color='#fff'"
            onmouseout="this.style.background='#2a3a4a'; this.style.color='#aaa'"
          >
            üìç Bod
          </button>

          <!-- Fixace VZD√ÅLENOST -->
          <button
            onclick="window.applyConstraint('distance')"
            style="
              padding: 10px 12px;
              background: #2a3a4a;
              color: #aaa;
              border: 1px solid #555;
              border-radius: 4px;
              cursor: pointer;
              font-size: 11px;
              min-width: 70px;
              transition: all 0.2s;
            "
            onmouseover="this.style.background='#3a5a7a'; this.style.color='#fff'"
            onmouseout="this.style.background='#2a3a4a'; this.style.color='#aaa'"
          >
            üìè Vzd√°lenost
          </button>

          <!-- Fixace RADIUS -->
          <button
            onclick="window.applyConstraint('radius')"
            style="
              padding: 10px 12px;
              background: #2a3a4a;
              color: #aaa;
              border: 1px solid #555;
              border-radius: 4px;
              cursor: pointer;
              font-size: 11px;
              min-width: 70px;
              transition: all 0.2s;
            "
            onmouseover="this.style.background='#3a5a7a'; this.style.color='#fff'"
            onmouseout="this.style.background='#2a3a4a'; this.style.color='#aaa'"
          >
            ‚≠ï Radius
          </button>

          <!-- Fixace POL√ÅRN√ç √öHEL -->
          <button
            onclick="window.applyConstraint('polarAngle')"
            style="
              padding: 10px 12px;
              background: #2a3a4a;
              color: #aaa;
              border: 1px solid #555;
              border-radius: 4px;
              cursor: pointer;
              font-size: 11px;
              min-width: 70px;
              transition: all 0.2s;
            "
            onmouseover="this.style.background='#3a5a7a'; this.style.color='#fff'"
            onmouseout="this.style.background='#2a3a4a'; this.style.color='#aaa'"
          >
            ‚ü≤ Pol. √öhel
          </button>

          <!-- Fixace VODOROVNOST -->
          <button
            onclick="window.applyConstraint('horizontal')"
            style="
              padding: 10px 12px;
              background: #2a3a4a;
              color: #aaa;
              border: 1px solid #555;
              border-radius: 4px;
              cursor: pointer;
              font-size: 11px;
              min-width: 70px;
              transition: all 0.2s;
            "
            onmouseover="this.style.background='#3a5a7a'; this.style.color='#fff'"
            onmouseout="this.style.background='#2a3a4a'; this.style.color='#aaa'"
          >
            ‚û°Ô∏è Vodorovnƒõ
          </button>

          <!-- Fixace SVISLOST -->
          <button
            onclick="window.applyConstraint('vertical')"
            style="
              padding: 10px 12px;
              background: #2a3a4a;
              color: #aaa;
              border: 1px solid #555;
              border-radius: 4px;
              cursor: pointer;
              font-size: 11px;
              min-width: 70px;
              transition: all 0.2s;
            "
            onmouseover="this.style.background='#3a5a7a'; this.style.color='#fff'"
            onmouseout="this.style.background='#2a3a4a'; this.style.color='#aaa'"
          >
            ‚¨ÜÔ∏è Svisle
          </button>

          <!-- SMAZAT FIXACI -->
          <button
            onclick="window.removeConstraint('all')"
            style="
              padding: 10px 12px;
              background: #3a2a2a;
              color: #ff6b6b;
              border: 1px solid #555;
              border-radius: 4px;
              cursor: pointer;
              font-size: 11px;
              min-width: 70px;
              transition: all 0.2s;
            "
            onmouseover="this.style.background='#5a3a3a'; this.style.color='#ff8888'"
            onmouseout="this.style.background='#3a2a2a'; this.style.color='#ff6b6b'"
          >
            ‚ùå Smazat
          </button>
        </div>

        <div
          style="
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
          "
        >
          <button
            onclick="window.closeConstraintModal()"
            style="
              padding: 8px 16px;
              background: #444;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
            "
          >
            Zav≈ô√≠t
          </button>
        </div>
      </div>
    </div>

    <!-- MOD√ÅLN√ç OKNO PRO ZAD√ÅN√ç BODU (SOU≈òADNICE) -->
    <div id="constraintPointModal" class="modal-overlay">
      <div class="modal-window">
        <h2 style="margin-bottom: 15px; color: #6ab0ff; font-size: 18px">
          üìç Fixace Bodu - Zad√°n√≠ Sou≈ôadnic
        </h2>

        <div class="circle-input-row">
          <label>Z (Horizont√°lnƒõ):</label>
          <input type="number" id="constraintPointZ" step="0.01" value="0" />
        </div>

        <div class="circle-input-row">
          <label>X (Vertik√°lnƒõ):</label>
          <input type="number" id="constraintPointX" step="0.01" value="0" />
        </div>

        <div
          style="
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
          "
        >
          <button
            onclick="window.cancelConstraintValue()"
            style="
              padding: 8px 16px;
              background: #444;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
            "
          >
            Zru≈°it
          </button>
          <button
            onclick="window.confirmConstraintPoint()"
            style="
              padding: 8px 16px;
              background: #3a7bc8;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-weight: bold;
            "
          >
            Potvrdit
          </button>
        </div>
      </div>
    </div>

    <!-- MOD√ÅLN√ç OKNO PRO ZAD√ÅN√ç VZD√ÅLENOSTI -->
    <div id="constraintDistanceModal" class="modal-overlay">
      <div class="modal-window">
        <h2 style="margin-bottom: 15px; color: #6ab0ff; font-size: 18px">
          üìè Fixace Vzd√°lenosti
        </h2>

        <div class="circle-input-row">
          <label>Vzd√°lenost:</label>
          <input
            type="number"
            id="constraintDistanceValue"
            step="0.01"
            value="10"
          />
        </div>

        <div
          style="
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
          "
        >
          <button
            onclick="window.cancelConstraintValue()"
            style="
              padding: 8px 16px;
              background: #444;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
            "
          >
            Zru≈°it
          </button>
          <button
            onclick="window.confirmConstraintDistance()"
            style="
              padding: 8px 16px;
              background: #3a7bc8;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-weight: bold;
            "
          >
            Potvrdit
          </button>
        </div>
      </div>
    </div>

    <!-- MOD√ÅLN√ç OKNO PRO ZAD√ÅN√ç RADIUSU -->
    <div id="constraintRadiusModal" class="modal-overlay">
      <div class="modal-window">
        <h2 style="margin-bottom: 15px; color: #6ab0ff; font-size: 18px">
          ‚≠ï Fixace Radiusu
        </h2>

        <div class="circle-input-row">
          <label>Radius:</label>
          <input
            type="number"
            id="constraintRadiusValue"
            step="0.01"
            value="5"
          />
        </div>

        <div
          style="
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
          "
        >
          <button
            onclick="window.cancelConstraintValue()"
            style="
              padding: 8px 16px;
              background: #444;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
            "
          >
            Zru≈°it
          </button>
          <button
            onclick="window.confirmConstraintRadius()"
            style="
              padding: 8px 16px;
              background: #3a7bc8;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-weight: bold;
            "
          >
            Potvrdit
          </button>
        </div>
      </div>
    </div>

    <!-- MOD√ÅLN√ç OKNO PRO ZAD√ÅN√ç POL√ÅRN√çHO √öHLU -->
    <div id="constraintPolarAngleModal" class="modal-overlay">
      <div class="modal-window">
        <h2 style="margin-bottom: 15px; color: #6ab0ff; font-size: 18px">
          ‚ü≤ Fixace Pol√°rn√≠ho √öhlu
        </h2>

        <div class="circle-input-row">
          <label>Pol√°rn√≠ √öhel (¬∞):</label>
          <input
            type="number"
            id="constraintPolarAngleValue"
            step="0.1"
            value="0"
            min="0"
            max="360"
          />
        </div>

        <div
          style="
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
          "
        >
          <button
            onclick="window.cancelConstraintValue()"
            style="
              padding: 8px 16px;
              background: #444;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
            "
          >
            Zru≈°it
          </button>
          <button
            onclick="window.confirmConstraintPolarAngle()"
            style="
              padding: 8px 16px;
              background: #3a7bc8;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-weight: bold;
            "
          >
            Potvrdit
          </button>
        </div>
      </div>
    </div>

    <!-- MOD√ÅLN√ç OKNO RYCHL√â ZAD√ÅN√ç (NOV√â) -->
    <div id="quickInputModal" class="modal-overlay">
      <div class="modal-window" style="max-width: 550px">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
          "
        >
          <h2 style="color: #6ab0ff; font-size: 18px; margin: 0">
            ‚å®Ô∏è Rychl√© zad√°n√≠ (CNC)
          </h2>
          <button
            onclick="window.closeQuickInput()"
            style="
              background: transparent;
              border: none;
              color: #888;
              font-size: 20px;
              cursor: pointer;
            "
          >
            &times;
          </button>
        </div>

        <!-- TEXT DISPLAY -->
        <textarea
          id="quickInputDisplay"
          class="quick-input-display"
          placeholder="Zde se zobrazuje zad√°n√≠..."
          readonly
        ></textarea>

        <!-- KEYPAD GRID -->
        <div class="keypad-grid">
          <!-- G-Codes Row (6 tlaƒç√≠tek) -->
          <button
            class="keypad-btn cnc-code"
            onclick="window.insertToken('G90 ')"
          >
            G90<span>Abs</span>
          </button>
          <button
            class="keypad-btn cnc-code"
            onclick="window.insertToken('G91 ')"
          >
            G91<span>P≈ô√≠r</span>
          </button>
          <button
            class="keypad-btn cnc-code"
            onclick="window.insertToken('G0 ')"
          >
            G0<span>Bod</span>
          </button>
          <button
            class="keypad-btn cnc-code"
            onclick="window.insertToken('G1 ')"
          >
            G1<span>P≈ô√≠mka</span>
          </button>
          <button
            class="keypad-btn cnc-code"
            onclick="window.insertToken('G2 ')"
          >
            G2<span>CW</span>
          </button>
          <button
            class="keypad-btn cnc-code"
            onclick="window.insertToken('G3 ')"
          >
            G3<span>CCW</span>
          </button>

          <!-- Row 1: X, Z, 7, 8, 9, ; -->
          <button class="keypad-btn action" onclick="window.insertToken('X')">
            X<span>Osa</span>
          </button>
          <button class="keypad-btn action" onclick="window.insertToken('Z')">
            Z<span>Osa</span>
          </button>
          <button class="keypad-btn" onclick="window.insertToken('7')">
            7
          </button>
          <button class="keypad-btn" onclick="window.insertToken('8')">
            8
          </button>
          <button class="keypad-btn" onclick="window.insertToken('9')">
            9
          </button>
          <button class="keypad-btn action" onclick="window.insertToken(';')">
            ;<span>Oddƒõlovaƒç</span>
          </button>

          <!-- Row 2: R, D, 4, 5, 6, Space -->
          <button class="keypad-btn action" onclick="window.insertToken('R')">
            R<span>Polomƒõr</span>
          </button>
          <button class="keypad-btn action" onclick="window.insertToken('D')">
            D<span>Pr≈Ømƒõr</span>
          </button>
          <button class="keypad-btn" onclick="window.insertToken('4')">
            4
          </button>
          <button class="keypad-btn" onclick="window.insertToken('5')">
            5
          </button>
          <button class="keypad-btn" onclick="window.insertToken('6')">
            6
          </button>
          <button class="keypad-btn" onclick="window.insertToken(' ')">
            Mezera
          </button>

          <!-- Row 3: L, A, 1, 2, 3, ? -->
          <button class="keypad-btn action" onclick="window.insertToken('L')">
            L<span>D√©lka</span>
          </button>
          <button class="keypad-btn action" onclick="window.insertToken('A')">
            A<span>√öhel</span>
          </button>
          <button class="keypad-btn" onclick="window.insertToken('1')">
            1
          </button>
          <button class="keypad-btn" onclick="window.insertToken('2')">
            2
          </button>
          <button class="keypad-btn" onclick="window.insertToken('3')">
            3
          </button>
          <button
            class="keypad-btn help"
            onclick="window.showQuickInputHelp()"
            title="Zobrazit n√°povƒõdu"
          >
            ?<span>N√°povƒõda</span>
          </button>

          <!-- Row 4: RP, AP, -, 0, ., ‚å´ -->
          <button class="keypad-btn action" onclick="window.insertToken('RP')">
            RP<span>Pol. polomƒõr</span>
          </button>
          <button class="keypad-btn action" onclick="window.insertToken('AP')">
            AP<span>Pol. √∫hel</span>
          </button>
          <button class="keypad-btn" onclick="window.insertToken('-')">
            -
          </button>
          <button class="keypad-btn" onclick="window.insertToken('0')">
            0
          </button>
          <button class="keypad-btn" onclick="window.insertToken('.')">
            .
          </button>
          <button
            class="keypad-btn backspace"
            onclick="window.backspaceToken()"
          >
            ‚å´
          </button>

          <!-- Row 5: Smƒõry, Sra≈æen√≠, Zaoblen√≠, V√Ωbƒõr, Vlo≈æit (6 sloupc≈Ø) -->
          <button
            class="keypad-btn action"
            onclick="window.showDirectionModal()"
            style="background: #2d5a8f"
          >
            üß≠<span>Smƒõry</span>
          </button>
          <button
            class="keypad-btn action"
            onclick="window.insertToken('Sra≈æ ')"
          >
            Sra≈æ<span>Sra≈æen√≠</span>
          </button>
          <button
            class="keypad-btn action"
            onclick="window.insertToken('Zaob ')"
          >
            Zaob<span>Zaoblen√≠</span>
          </button>
          <button
            class="keypad-btn action"
            onclick="window.insertToken('V√Ωbƒõr ')"
          >
            V√Ωbƒõr<span>Vybran√©</span>
          </button>
          <button
            class="keypad-btn confirm"
            onclick="window.confirmQuickInput()"
            style="grid-column: span 2"
          >
            Vlo≈æit do chatu
          </button>
        </div>
      </div>
    </div>

    <!-- HELP MODAL - N√°povƒõda pro rychl√© zad√°n√≠ -->
    <div id="quickInputHelpModal" class="modal-overlay">
      <div class="modal-window" style="max-width: 650px">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
          "
        >
          <h2 style="color: #6ab0ff; font-size: 18px; margin: 0">
            ‚ùì N√°povƒõda - Rychl√© zad√°n√≠ (CNC/G-k√≥d styl)
          </h2>
          <button
            onclick="window.closeQuickInputHelp()"
            style="
              background: transparent;
              border: none;
              color: #888;
              font-size: 20px;
              cursor: pointer;
            "
          >
            &times;
          </button>
        </div>

        <div
          style="
            max-height: 500px;
            overflow-y: auto;
            color: #e0e0e0;
            font-size: 13px;
            line-height: 1.6;
          "
        >
          <h3 style="color: #90cdf4; margin-top: 0">üéØ Z√°kladn√≠ pou≈æit√≠</h3>
          <p>
            Mezery mezi parametry <strong>nejsou povinn√©</strong>. M≈Ø≈æe≈° ps√°t
            jak <code>G0 X50 Z100</code> tak <code>G0X50Z100</code>.
          </p>

          <h3 style="color: #90cdf4; margin-top: 15px">üìç G-k√≥dy (p≈ô√≠kazy)</h3>
          <ul style="margin-left: 20px">
            <li><strong>G0</strong> - Vytvo≈ôen√≠ bodu (rapid move)</li>
            <li><strong>G1</strong> - P≈ô√≠mka (line√°rn√≠ pohyb)</li>
            <li>
              <strong>G2</strong> - Oblouk ve smƒõru hodinov√Ωch ruƒçiƒçek (CW)
            </li>
            <li>
              <strong>G3</strong> - Oblouk proti smƒõru hodinov√Ωch ruƒçiƒçek (CCW)
            </li>
            <li><strong>G90</strong> - Absolutn√≠ sou≈ôadnice</li>
            <li><strong>G91</strong> - P≈ô√≠r≈Østkov√© sou≈ôadnice</li>
          </ul>

          <h3 style="color: #90cdf4; margin-top: 15px">üìê Parametry pozice</h3>
          <ul style="margin-left: 20px">
            <li>
              <strong>X</strong> - Sou≈ôadnice osy X (radi√°ln√≠ pro soustruh)
            </li>
            <li>
              <strong>Z</strong> - Sou≈ôadnice osy Z (pod√©ln√° pro soustruh)
            </li>
            <li><strong>R</strong> - Polomƒõr (pro oblouky nebo kru≈ænice)</li>
            <li><strong>D</strong> - Pr≈Ømƒõr</li>
          </ul>

          <h3 style="color: #90cdf4; margin-top: 15px">
            üîÑ Pol√°rn√≠ sou≈ôadnice
          </h3>
          <ul style="margin-left: 20px">
            <li><strong>RP</strong> - Pol√°rn√≠ polomƒõr (vzd√°lenost od bodu)</li>
            <li><strong>AP</strong> - Pol√°rn√≠ √∫hel (√∫hel ve stupn√≠ch)</li>
            <li><strong>L</strong> - D√©lka (alternativa k RP)</li>
            <li><strong>A</strong> - √öhel ve stupn√≠ch (alternativa k AP)</li>
          </ul>

          <h3 style="color: #90cdf4; margin-top: 15px">‚úÇÔ∏è √öpravy hran</h3>
          <ul style="margin-left: 20px">
            <li><strong>Sra≈æ</strong> - Sra≈æen√≠ hrany (f√°ze)</li>
            <li><strong>Zaob</strong> - Zaoblen√≠ hrany (r√°diusov√©)</li>
          </ul>

          <h3 style="color: #90cdf4; margin-top: 15px">‚ûó Oddƒõlovaƒç</h3>
          <ul style="margin-left: 20px">
            <li>
              <strong>;</strong> (st≈ôedn√≠k) - Oddƒõluje v√≠ce p≈ô√≠kaz≈Ø v jednom
              zad√°n√≠
            </li>
          </ul>

          <h3 style="color: #90cdf4; margin-top: 15px">üí° P≈ô√≠klady pou≈æit√≠</h3>
          <div
            style="
              background: #1a1a1a;
              padding: 12px;
              border-radius: 6px;
              margin-top: 8px;
              font-family: 'Courier New', monospace;
              font-size: 12px;
            "
          >
            <p><strong>Vytvo≈ô bod na pozici:</strong></p>
            <code style="color: #90ee90">G0 X50 Z100</code> nebo
            <code style="color: #90ee90">G0X50Z100</code>

            <p style="margin-top: 10px">
              <strong>Nakresli ƒç√°ru od aktu√°ln√≠ pozice:</strong>
            </p>
            <code style="color: #90ee90">G1 X100 Z50</code>

            <p style="margin-top: 10px">
              <strong
                >Pol√°rn√≠ sou≈ôadnice (√∫seƒçka o d√©lce 100mm pod √∫hlem
                90¬∞):</strong
              >
            </p>
            <code style="color: #90ee90">G1 RP100 AP90</code> nebo
            <code style="color: #90ee90">G1 L100 A90</code>

            <p style="margin-top: 10px">
              <strong>V√≠ce p≈ô√≠kaz≈Ø najednou:</strong>
            </p>
            <code style="color: #90ee90"
              >G0 X50 Z100; G1 RP100 AP90; G1 X0 Z0</code
            >
            <p style="font-size: 11px; color: #888; margin-top: 4px">
              ‚Üí Vytvo≈ô√≠ bod na [50, 100], pak ƒç√°ru pol√°rnƒõ, pak ƒç√°ru zpƒõt na [0,
              0]
            </p>

            <p style="margin-top: 10px">
              <strong>Kru≈ænice s polomƒõrem:</strong>
            </p>
            <code style="color: #90ee90">G0 X50 Z50; kru≈ænice R20</code>
          </div>

          <p
            style="
              margin-top: 15px;
              padding: 10px;
              background: #2d3748;
              border-left: 3px solid #90cdf4;
              border-radius: 4px;
              font-size: 12px;
            "
          >
            <strong>üí° Tip:</strong> AI Gemini rozum√≠ tƒõmto zkratk√°m a
            automaticky je p≈ôevede na p≈ô√≠slu≈°n√© tvary na pl√°tnƒõ!
          </p>
        </div>

        <div style="margin-top: 15px; text-align: center">
          <button
            onclick="window.closeQuickInputHelp()"
            style="
              padding: 10px 20px;
              background: #3a7bc8;
              color: white;
              border: none;
              border-radius: 6px;
              cursor: pointer;
              font-size: 14px;
            "
          >
            Zav≈ô√≠t
          </button>
        </div>
      </div>
    </div>

    <!-- CONTROLLER MODAL - Ovladaƒç pro rychl√© kreslen√≠ -->
    <div id="controllerModal" class="modal-overlay">
      <div class="modal-window" style="max-width: 700px">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
          "
        >
          <h2 style="color: #6ab0ff; font-size: 18px; margin: 0">
            üéÆ Ovladaƒç - Rychl√© kreslen√≠ √∫seƒçek
          </h2>
          <button
            onclick="closeControllerModal()"
            style="
              background: transparent;
              border: none;
              color: #888;
              font-size: 20px;
              cursor: pointer;
            "
          >
            &times;
          </button>
        </div>

        <!-- Input Display & Mode Selector -->
        <div style="margin-bottom: 12px">
          <div
            style="
              display: flex;
              gap: 8px;
              align-items: center;
              margin-bottom: 8px;
            "
          >
            <!-- G90/G91 Toggle -->
            <button
              id="btnG90"
              onclick="setControllerMode('G90')"
              style="
                padding: 8px 12px;
                background: #3a7bc8;
                border: 1px solid #5a9be8;
                border-radius: 6px;
                color: white;
                cursor: pointer;
                font-size: 12px;
                font-weight: bold;
              "
            >
              G90<br /><span style="font-size: 9px">Absolutn√≠</span>
            </button>
            <button
              id="btnG91"
              onclick="setControllerMode('G91')"
              style="
                padding: 8px 12px;
                background: #2a2a2a;
                border: 1px solid #444;
                border-radius: 6px;
                color: #888;
                cursor: pointer;
                font-size: 12px;
              "
            >
              G91<br /><span style="font-size: 9px">P≈ô√≠r≈Østkov√©</span>
            </button>

            <!-- Input Display -->
            <input
              type="text"
              id="controllerInput"
              readonly
              placeholder="Zad√°n√≠..."
              style="
                flex: 1;
                padding: 10px;
                background: #000;
                border: 1px solid #444;
                border-radius: 6px;
                color: #0f0;
                font-family: 'Courier New', monospace;
                font-size: 16px;
                font-weight: bold;
              "
            />
          </div>

          <!-- Status Info -->
          <div style="display: flex; gap: 10px; font-size: 11px; color: #888">
            <div>
              <strong style="color: #6ab0ff">Re≈æim:</strong>
              <span id="controllerModeDisplay">G90 (Absolutn√≠)</span>
            </div>
            <div>
              <strong style="color: #6ab0ff">Posledn√≠ bod:</strong>
              <span id="controllerLastPointInline">‚Äî</span>
            </div>
          </div>
        </div>

        <!-- Controller Layout - JEN KL√ÅVESNICE -->
        <div
          style="
            background: #1a1a1a;
            padding: 12px;
            border-radius: 10px;
            border: 1px solid #444;
          "
        >
          <h4
            style="
              color: #90cdf4;
              margin: 0 0 8px 0;
              text-align: center;
              font-size: 12px;
            "
          >
            ‚å®Ô∏è CNC Zad√°n√≠
          </h4>

          <!-- G-Codes Row -->
          <div
            style="
              display: grid;
              grid-template-columns: repeat(6, 1fr);
              gap: 3px;
              margin-bottom: 3px;
            "
          >
            <button
              class="mini-key-action"
              onclick="insertControllerToken('G90 ')"
              style="background: #1e3a5f"
            >
              G90<span style="font-size: 7px; display: block">Abs</span>
            </button>
            <button
              class="mini-key-action"
              onclick="insertControllerToken('G91 ')"
              style="background: #1e3a5f"
            >
              G91<span style="font-size: 7px; display: block">P≈ô√≠r</span>
            </button>
            <button
              class="mini-key-action"
              onclick="insertControllerToken('G0 ')"
              style="background: #1e3a5f"
            >
              G0<span style="font-size: 7px; display: block">Bod</span>
            </button>
            <button
              class="mini-key-action"
              onclick="insertControllerToken('G1 ')"
              style="background: #1e3a5f"
            >
              G1<span style="font-size: 7px; display: block">ƒå√°ra</span>
            </button>
            <button
              class="mini-key-action"
              onclick="insertControllerToken('G2 ')"
              style="background: #1e3a5f"
            >
              G2<span style="font-size: 7px; display: block">CW</span>
            </button>
            <button
              class="mini-key-action"
              onclick="insertControllerToken('G3 ')"
              style="background: #1e3a5f"
            >
              G3<span style="font-size: 7px; display: block">CCW</span>
            </button>
          </div>

          <!-- Row 1: X, Z, 7, 8, 9, ; -->
          <div
            style="
              display: grid;
              grid-template-columns: repeat(6, 1fr);
              gap: 3px;
              margin-bottom: 3px;
            "
          >
            <button
              class="mini-key-action"
              onclick="insertControllerToken('X')"
            >
              X<span style="font-size: 7px; display: block">Osa</span>
            </button>
            <button
              class="mini-key-action"
              onclick="insertControllerToken('Z')"
            >
              Z<span style="font-size: 7px; display: block">Osa</span>
            </button>
            <button class="mini-key" onclick="insertControllerToken('7')">
              7
            </button>
            <button class="mini-key" onclick="insertControllerToken('8')">
              8
            </button>
            <button class="mini-key" onclick="insertControllerToken('9')">
              9
            </button>
            <button
              class="mini-key-action"
              onclick="insertControllerToken(';')"
            >
              ;<span style="font-size: 7px; display: block">Odd</span>
            </button>
          </div>

          <!-- Row 2: R, CR, 4, 5, 6, Space -->
          <div
            style="
              display: grid;
              grid-template-columns: repeat(6, 1fr);
              gap: 3px;
              margin-bottom: 3px;
            "
          >
            <button
              class="mini-key-action"
              onclick="insertControllerToken('R')"
            >
              R<span style="font-size: 7px; display: block">Radius</span>
            </button>
            <button
              class="mini-key-action"
              onclick="insertControllerToken('CR')"
            >
              CR<span style="font-size: 7px; display: block">Min R</span>
            </button>
            <button class="mini-key" onclick="insertControllerToken('4')">
              4
            </button>
            <button class="mini-key" onclick="insertControllerToken('5')">
              5
            </button>
            <button class="mini-key" onclick="insertControllerToken('6')">
              6
            </button>
            <button
              class="mini-key-action"
              onclick="insertControllerToken(' ')"
            >
              ‚ê£<span style="font-size: 7px; display: block">Mezera</span>
            </button>
          </div>

          <!-- Row 3: L, A, 1, 2, 3, Backspace -->
          <div
            style="
              display: grid;
              grid-template-columns: repeat(6, 1fr);
              gap: 3px;
              margin-bottom: 3px;
            "
          >
            <button
              class="mini-key-action"
              onclick="insertControllerToken('L')"
            >
              L<span style="font-size: 7px; display: block">D√©lka</span>
            </button>
            <button
              class="mini-key-action"
              onclick="insertControllerToken('A')"
            >
              A<span style="font-size: 7px; display: block">√öhel</span>
            </button>
            <button class="mini-key" onclick="insertControllerToken('1')">
              1
            </button>
            <button class="mini-key" onclick="insertControllerToken('2')">
              2
            </button>
            <button class="mini-key" onclick="insertControllerToken('3')">
              3
            </button>
            <button class="mini-key-back" onclick="backspaceControllerToken()">
              ‚å´
            </button>
          </div>

          <!-- Row 4: RP, AP, -, 0, . -->
          <div
            style="
              display: grid;
              grid-template-columns: repeat(6, 1fr);
              gap: 3px;
              margin-bottom: 3px;
            "
          >
            <button
              class="mini-key-action"
              onclick="insertControllerToken('RP')"
            >
              RP<span style="font-size: 7px; display: block">Pol R</span>
            </button>
            <button
              class="mini-key-action"
              onclick="insertControllerToken('AP')"
            >
              AP<span style="font-size: 7px; display: block">Pol A</span>
            </button>
            <button class="mini-key" onclick="insertControllerToken('-')">
              -
            </button>
            <button class="mini-key" onclick="insertControllerToken('0')">
              0
            </button>
            <button class="mini-key" onclick="insertControllerToken('.')">
              .
            </button>
            <button
              class="mini-key-action"
              onclick="window.showControllerHelp()"
            >
              ‚ùì<span style="font-size: 7px; display: block">Help</span>
            </button>
          </div>

          <!-- Row 5: Smƒõry, Sra≈æen√≠, Zaoblen√≠, Potvrdit -->
          <div
            style="
              display: grid;
              grid-template-columns: repeat(3, 1fr);
              gap: 3px;
            "
          >
            <button
              class="mini-key-action"
              onclick="window.showDirectionModal()"
              style="background: #2d5a8f"
            >
              üß≠<span style="font-size: 7px; display: block">Smƒõry</span>
            </button>
            <button
              class="mini-key-action"
              onclick="insertControllerToken('Sra≈æ ')"
            >
              Sra≈æ<span style="font-size: 7px; display: block">Sra≈æen√≠</span>
            </button>
            <button
              class="mini-key-action"
              onclick="insertControllerToken('Zaob ')"
            >
              Zaob<span style="font-size: 7px; display: block">Zaoblen√≠</span>
            </button>
          </div>
          <div style="margin-top: 6px">
            <button
              onclick="confirmControllerInput()"
              style="
                width: 100%;
                padding: 10px;
                background: #22c55e;
                border: none;
                border-radius: 6px;
                color: white;
                cursor: pointer;
                font-size: 14px;
                font-weight: bold;
              "
            >
              ‚úì Potvrdit
            </button>
          </div>
        </div>

        <!-- Help Text -->
        <div
          style="
            margin-top: 12px;
            padding: 10px;
            background: #1a1a1a;
            border-radius: 6px;
            border-left: 3px solid #6ab0ff;
            font-size: 11px;
            color: #aaa;
          "
        >
          <strong style="color: #6ab0ff">üí° Tip:</strong>
          Pou≈æij <strong>G-k√≥dy</strong>:
          <code style="color: #90ee90">G0 X50 Z100</code> (bod),
          <code style="color: #90ee90">G1 X100</code> (ƒç√°ra),
          <code style="color: #90ee90">G2 R20</code> (oblouk), nebo klikni
          <strong>üß≠ Smƒõry</strong> pro rychl√© kreslen√≠
        </div>
      </div>
    </div>

    <!-- DIRECTION MODAL - Skryt√© smƒõrov√© ≈°ipky -->
    <div id="directionModal" class="modal-overlay">
      <div class="modal-window" style="max-width: 350px">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
          "
        >
          <h2 style="color: #6ab0ff; font-size: 18px; margin: 0">
            üß≠ Smƒõrov√© kreslen√≠
          </h2>
          <button
            onclick="window.closeDirectionModal()"
            style="
              background: transparent;
              border: none;
              color: #888;
              font-size: 20px;
              cursor: pointer;
            "
          >
            &times;
          </button>
        </div>

        <p style="color: #aaa; font-size: 12px; margin-bottom: 15px">
          Klikni na ≈°ipku, automaticky se vlo≈æ√≠ p≈ô√≠kaz do zad√°n√≠:
        </p>

        <!-- Direction Pad (8-way) -->
        <div
          style="
            display: grid;
            grid-template-columns: repeat(3, 80px);
            grid-template-rows: repeat(3, 80px);
            gap: 5px;
            justify-content: center;
          "
        >
          <!-- Row 1: ‚Üñ ‚Üë ‚Üó -->
          <button
            class="controller-btn"
            onclick="window.insertDirectionCommand('NW')"
            title="≈†ikmo vlevo nahoru (‚Üñ)"
          >
            <span style="font-size: 32px">‚Üñ</span>
          </button>
          <button
            class="controller-btn"
            onclick="window.insertDirectionCommand('N')"
            title="Nahoru (‚Üë)"
          >
            <span style="font-size: 32px">‚Üë</span>
          </button>
          <button
            class="controller-btn"
            onclick="window.insertDirectionCommand('NE')"
            title="≈†ikmo vpravo nahoru (‚Üó)"
          >
            <span style="font-size: 32px">‚Üó</span>
          </button>

          <!-- Row 2: ‚Üê ¬∑ ‚Üí -->
          <button
            class="controller-btn"
            onclick="window.insertDirectionCommand('W')"
            title="Doleva (‚Üê)"
          >
            <span style="font-size: 32px">‚Üê</span>
          </button>
          <div
            style="
              display: flex;
              align-items: center;
              justify-content: center;
              background: #1a1a1a;
              border-radius: 8px;
              color: #666;
              font-size: 36px;
            "
          >
            ‚óè
          </div>
          <button
            class="controller-btn"
            onclick="window.insertDirectionCommand('E')"
            title="Doprava (‚Üí)"
          >
            <span style="font-size: 32px">‚Üí</span>
          </button>

          <!-- Row 3: ‚Üô ‚Üì ‚Üò -->
          <button
            class="controller-btn"
            onclick="window.insertDirectionCommand('SW')"
            title="≈†ikmo vlevo dol≈Ø (‚Üô)"
          >
            <span style="font-size: 32px">‚Üô</span>
          </button>
          <button
            class="controller-btn"
            onclick="window.insertDirectionCommand('S')"
            title="Dol≈Ø (‚Üì)"
          >
            <span style="font-size: 32px">‚Üì</span>
          </button>
          <button
            class="controller-btn"
            onclick="window.insertDirectionCommand('SE')"
            title="≈†ikmo vpravo dol≈Ø (‚Üò)"
          >
            <span style="font-size: 32px">‚Üò</span>
          </button>
        </div>

        <div style="margin-top: 15px; text-align: center">
          <button
            onclick="window.closeDirectionModal()"
            style="
              padding: 8px 16px;
              background: #3a7bc8;
              color: white;
              border: none;
              border-radius: 6px;
              cursor: pointer;
              font-size: 13px;
            "
          >
            Zav≈ô√≠t
          </button>
        </div>
      </div>
    </div>

    <!-- HELP MODAL - N√°povƒõda pro ovladaƒç -->
    <div id="controllerHelpModal" class="modal-overlay" style="display: none">
      <div
        class="modal-window"
        style="max-width: 650px; max-height: 80vh; overflow-y: auto"
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
          "
        >
          <h2 style="color: #6ab0ff; font-size: 18px; margin: 0">
            ‚ùì N√°povƒõda - Ovladaƒç
          </h2>
          <button
            onclick="window.closeControllerHelp()"
            style="
              background: transparent;
              border: none;
              color: #888;
              font-size: 20px;
              cursor: pointer;
            "
          >
            &times;
          </button>
        </div>

        <div
          style="
            background: #1a1a1a;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            color: #ccc;
          "
        >
          <h3 style="color: #90cdf4; margin-top: 0">üìê Z√°kladn√≠ p≈ô√≠kazy</h3>
          <div
            style="
              background: #222;
              padding: 10px;
              border-radius: 4px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-bottom: 8px">
              <code style="color: #22c55e">X80 Z120</code> - Bod na sou≈ôadnic√≠ch
              X=80, Z=120
            </div>
            <div style="margin-bottom: 8px">
              <code style="color: #22c55e">G1 X100 Z200</code> - ƒå√°ra do bodu
              X=100, Z=200
            </div>
            <div style="margin-bottom: 8px">
              <code style="color: #22c55e">G0 X50</code> - Skok (bez ƒç√°ry) na
              X=50
            </div>
          </div>

          <h3 style="color: #90cdf4">‚≠ï Kru≈ænice a oblouky</h3>
          <div
            style="
              background: #222;
              padding: 10px;
              border-radius: 4px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-bottom: 8px">
              <code style="color: #22c55e">R50</code> - Kru≈ænice s polomƒõrem
              50mm
            </div>
            <div style="margin-bottom: 8px">
              <code style="color: #22c55e">CR30</code> - Kru≈ænice s minim√°ln√≠m
              polomƒõrem (pro teƒçny)
            </div>
            <div style="margin-bottom: 8px">
              <code style="color: #22c55e">G2 X100 Z150 R25</code> - Oblouk CW
            </div>
            <div style="margin-bottom: 8px">
              <code style="color: #22c55e">G3 X100 Z150 R25</code> - Oblouk CCW
            </div>
          </div>

          <h3 style="color: #90cdf4">üìè Pol√°rn√≠ sou≈ôadnice</h3>
          <div
            style="
              background: #222;
              padding: 10px;
              border-radius: 4px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-bottom: 8px">
              <code style="color: #22c55e">AP0 RP120</code> - ƒå√°ra √∫hel 0¬∞,
              d√©lka 120mm
            </div>
            <div style="margin-bottom: 8px">
              <code style="color: #22c55e">AP90 RP50</code> - ƒå√°ra √∫hel 90¬∞,
              d√©lka 50mm
            </div>
            <div style="margin-bottom: 8px">
              <code style="color: #22c55e">AP45 RP100</code> - ƒå√°ra √∫hel 45¬∞,
              d√©lka 100mm
            </div>
          </div>

          <h3 style="color: #90cdf4">üîÑ Re≈æimy</h3>
          <div
            style="
              background: #222;
              padding: 10px;
              border-radius: 4px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-bottom: 8px">
              <strong style="color: #6ab0ff">G90</strong> - Absolutn√≠ sou≈ôadnice
              (od nuly)
            </div>
            <div style="margin-bottom: 8px">
              <strong style="color: #6ab0ff">G91</strong> - P≈ô√≠r≈Østkov√© (od
              posledn√≠ho bodu)
            </div>
          </div>

          <h3 style="color: #90cdf4">üí° Speci√°ln√≠ funkce</h3>
          <div
            style="
              background: #222;
              padding: 10px;
              border-radius: 4px;
              margin-bottom: 10px;
            "
          >
            <div style="margin-bottom: 8px">
              <code style="color: #22c55e">Sra≈æ 5</code> - Sra≈æen√≠ hran 5mm
            </div>
            <div style="margin-bottom: 8px">
              <code style="color: #22c55e">Zaob 10</code> - Zaoblen√≠ roh≈Ø 10mm
            </div>
            <div style="margin-bottom: 8px">
              <code style="color: #22c55e">L50 A30</code> - D√©lka 50mm, √∫hel 30¬∞
            </div>
          </div>

          <h3 style="color: #90cdf4">‚ú® Tipy</h3>
          <div style="background: #222; padding: 10px; border-radius: 4px">
            <div style="margin-bottom: 6px">
              ‚Ä¢ Mezern√≠ky jsou voliteln√©: <code>X80Z120</code> =
              <code>X80 Z120</code>
            </div>
            <div style="margin-bottom: 6px">
              ‚Ä¢ Pou≈æij üß≠ Smƒõry pro rychl√© kreslen√≠
            </div>
            <div style="margin-bottom: 6px">
              ‚Ä¢ G-k√≥dy m≈Ø≈æe≈° kombinovat: <code>G90 G1 X100 Z200</code>
            </div>
            <div style="margin-bottom: 6px">
              ‚Ä¢ CR (minim√°ln√≠ radius) - vybere men≈°√≠ √∫hel rozev≈ôen√≠
            </div>
          </div>

          <div
            style="
              margin-top: 15px;
              padding: 10px;
              background: #1a3a1a;
              border-radius: 6px;
              border-left: 3px solid #22c55e;
            "
          >
            <strong style="color: #90ee90">üéØ Rychl√Ω start:</strong><br />
            1. Vyber re≈æim (G90/G91)<br />
            2. Zadej sou≈ôadnice (nap≈ô. X80 Z120)<br />
            3. Stiskni ‚úì Potvrdit
          </div>
        </div>

        <div style="margin-top: 15px; text-align: center">
          <button
            onclick="window.closeControllerHelp()"
            style="
              padding: 10px 20px;
              background: #3a7bc8;
              color: white;
              border: none;
              border-radius: 6px;
              cursor: pointer;
              font-size: 13px;
            "
          >
            Rozum√≠m
          </button>
        </div>
      </div>
    </div>

    <!-- PRE-LOAD API KEY MANAGEMENT -->
    <script>
      // Early definition to prevent race conditions
      window.getCurrentApiKey = function () {
        console.warn("‚ö†Ô∏è getCurrentApiKey called too early, returning null");
        return null;
      };

      // === EARLY STUB DEFINITIONS FOR HTML ONCLICK HANDLERS ===
      window.showToolCategory = function (category) {
        console.warn(
          "‚ö†Ô∏è showToolCategory stub called, full version not yet loaded"
        );
      };

      window.setMode = function (m) {
        console.warn("‚ö†Ô∏è setMode stub called, full version not yet loaded");
      };

      window.showConstraintModal = function () {
        console.warn(
          "‚ö†Ô∏è showConstraintModal stub called, full version not yet loaded"
        );
      };

      window.showControllerModal = function () {
        console.warn(
          "‚ö†Ô∏è showControllerModal stub called, full version not yet loaded"
        );
      };

      // === AI MEMORY SYSTEM ===
      const AI_MEMORY_KEY = "soustruznik_ai_memory";

      function loadAIMemory() {
        try {
          return JSON.parse(localStorage.getItem(AI_MEMORY_KEY) || "{}");
        } catch (e) {
          return {};
        }
      }

      function saveAIMemory(memory) {
        localStorage.setItem(AI_MEMORY_KEY, JSON.stringify(memory));
      }

      function recordCommand(command) {
        const memory = loadAIMemory();
        if (!memory.commands) memory.commands = [];
        memory.commands.push({
          text: command,
          timestamp: new Date().toISOString(),
        });
        if (memory.commands.length > 100)
          memory.commands = memory.commands.slice(-100);
        saveAIMemory(memory);
      }

      function recordCorrection(aiResponse, userCorrection) {
        const memory = loadAIMemory();
        if (!memory.corrections) memory.corrections = [];
        memory.corrections.push({
          aiResponse: aiResponse.substring(0, 100),
          userCorrection: userCorrection.substring(0, 100),
          timestamp: new Date().toISOString(),
        });
        if (memory.corrections.length > 50)
          memory.corrections = memory.corrections.slice(-50);
        saveAIMemory(memory);
      }

      window.getAIMemoryContext = function () {
        const memory = loadAIMemory();
        const topCommands = (memory.commands || [])
          .slice(-20)
          .reduce((acc, cmd) => {
            const existing = acc.find((c) => c.command === cmd.text);
            if (existing) existing.count++;
            else acc.push({ command: cmd.text, count: 1 });
            return acc;
          }, [])
          .sort((a, b) => b.count - a.count)
          .slice(0, 5);

        return {
          topCommands: topCommands,
          recentCorrections: (memory.corrections || []).slice(-5),
          successfulPatterns: (memory.successfulPatterns || []).slice(-5),
          preferences: memory.preferences || {},
        };
      };

      // === AI UI FUNCTIONS ===
      window.toggleAiSelect = function () {
        aiSelectMode = !aiSelectMode;
        const btn = document.getElementById("btnAiSelect");
        if (btn) {
          if (aiSelectMode) {
            btn.style.background = "#3a7bc8";
            setMode("select");
          } else {
            btn.style.background = "#333";
            clearMode();
          }
        }
      };

      window.openQuickInput = function () {
        const modal = document.getElementById("quickInputModal");
        if (modal) modal.style.display = "flex";
      };

      window.closeQuickInput = function () {
        const modal = document.getElementById("quickInputModal");
        if (modal) modal.style.display = "none";
      };

      window.confirmQuickInput = function () {
        const display = document.getElementById("quickInputDisplay");
        const prompt = document.getElementById("aiPrompt");
        if (display && prompt) {
          const text = display.value.trim();
          if (text) {
            prompt.value = text;
            window.closeQuickInput();
            if (window.callGemini) window.callGemini();
          }
        }
      };

      window.insertToken = function (token) {
        const display = document.getElementById("quickInputDisplay");
        if (display) {
          display.value += token;
          display.scrollTop = display.scrollHeight;
        }
      };

      window.backspaceToken = function () {
        const display = document.getElementById("quickInputDisplay");
        if (display && display.value) {
          display.value = display.value.slice(0, -1);
        }
      };

      window.showQuickInputHelp = function () {
        const modal = document.getElementById("quickInputHelpModal");
        if (modal) modal.style.display = "flex";
      };

      window.closeQuickInputHelp = function () {
        const modal = document.getElementById("quickInputHelpModal");
        if (modal) modal.style.display = "none";
      };

      window.toggleVoice = function () {
        const btn = document.getElementById("btnVoice");
        if (!btn) return;

        // Jednoduch√° implementace - jen zmƒõna stylu pro nyn√≠
        btn.classList.toggle("recording-pulse");
        setTimeout(() => {
          btn.classList.remove("recording-pulse");
        }, 2000);

        alert("üé§ Hlasov√© zad√°n√≠: Funkce bude implementov√°na v p≈ô√≠≈°t√≠ verzi.");
      };

      window.openAIPreferences = function () {
        const modal = document.getElementById("aiPreferencesModal");
        if (modal) {
          modal.style.display = "flex";
          renderPreferencesList();
        }
      };

      window.closeAIPreferences = function () {
        const modal = document.getElementById("aiPreferencesModal");
        if (modal) modal.style.display = "none";
      };

      function renderPreferencesList() {
        const memory = loadAIMemory();
        const list = document.getElementById("preferencesList");
        if (!list) return;

        const prefs = memory.preferences || {};
        if (Object.keys(prefs).length === 0) {
          list.innerHTML =
            '<div style="padding: 10px; color: #555; font-style: italic; text-align: center;">Zat√≠m ≈æ√°dn√© preference</div>';
          return;
        }

        list.innerHTML = Object.entries(prefs)
          .map(
            ([k, v]) =>
              `<div style="padding: 8px; background: #222; border-radius: 4px; margin-bottom: 6px;"><strong>${k}:</strong> ${v}</div>`
          )
          .join("");
      }

      window.addAIPreference = function () {
        const keyEl = document.getElementById("newPrefKey");
        const valEl = document.getElementById("newPrefValue");
        if (!keyEl || !valEl) return;

        const key = keyEl.value.trim();
        const val = valEl.value.trim();

        if (!key || !val) {
          alert("Vypl≈à kl√≠ƒç i hodnotu");
          return;
        }

        const memory = loadAIMemory();
        if (!memory.preferences) memory.preferences = {};
        memory.preferences[key] = val;
        saveAIMemory(memory);

        keyEl.value = "";
        valEl.value = "";
        renderPreferencesList();
        alert("‚úÖ Preference p≈ôid√°na!");
      };

      window.showAIMemory = function () {
        const context = window.getAIMemoryContext();
        let msg = "üß† AI PAMƒö≈§:\n\n";
        msg +=
          "üìä Nejƒçastƒõj≈°√≠ p≈ô√≠kazy:\n" +
          (context.topCommands.length > 0
            ? context.topCommands
                .map((c) => `  ‚Ä¢ "${c.command}" (${c.count}√ó)`)
                .join("\n")
            : "  ≈Ω√°dn√© zat√≠m");
        msg +=
          "\n\n‚úÖ √öspƒõ≈°n√© vzory:\n" +
          (context.successfulPatterns.length > 0
            ? context.successfulPatterns
                .map((p) => `  ‚Ä¢ ${p.input} ‚Üí ${p.shapeCount} tvar≈Ø`)
                .join("\n")
            : "  ≈Ω√°dn√© zat√≠m");
        alert(msg);
      };

      window.showAIMetrics = function () {
        let msg = "üìä AI STATISTIKY:\n\n";
        msg += "Celkem po≈æadavk≈Ø: " + aiMetrics.totalRequests + "\n";
        msg += "√öspƒõ≈°n√Ωch: " + aiMetrics.successfulRequests + "\n";
        msg += "Selhalo: " + aiMetrics.failedRequests + "\n";
        msg += "Pr≈Ømƒõrn√° latence: " + aiMetrics.avgLatency.toFixed(0) + "ms";
        alert(msg);
      };
    </script>

    <!-- AI LOGIC MODULE -->
    <script type="module">
      // Async initialization with proper error handling
      (async () => {
        try {
          const module = await import("@google/genai");
          window.GoogleGenAI = module.GoogleGenAI;
          window.Type = module.Type || module.SchemaType;
          console.log("‚úÖ AI Module loaded successfully");
        } catch (importError) {
          console.error("‚ùå Failed to import Google GenAI:", importError);
          console.log("Attempting fallback...");

          try {
            // Fallback: Try loading from alternative CDN
            const fallbackModule = await import(
              "https://cdn.jsdelivr.net/npm/@google/generative-ai@latest/dist/index.mjs"
            );
            window.GoogleGenerativeAI = fallbackModule.GoogleGenerativeAI;
            console.log(
              "‚úÖ Fallback: Google GenAI loaded from alternative CDN"
            );
          } catch (fallbackError) {
            console.error("‚ùå Fallback also failed:", fallbackError);
            window.aiModuleError = fallbackError;
          }
        }
      })();

      // Global variables for AI (Initialized dynamically inside callGemini)

      // ===== API USAGE TRACKING =====
      // Model Limits (per minute for free tier):
      // - Gemini 2.5 Flash-Lite: 300 req/min (nejlep≈°√≠ pro high volume)
      // - Gemini 2.5 Flash: 15 req/min
      // - Gemini 3 Pro: 2 req/min
      // - Gemini 2.0 Flash: 15 req/min

      let API_FREE_LIMIT = 15; // Default, zmƒõn√≠ se podle modelu
      let currentModel = "gemini-2.5-flash";
      let apiCallsCount = 0;
      let apiCallsTimestamp = [];
      let apiUsageStats = {
        totalCalls: 0,
        totalTokensIn: 0,
        totalTokensOut: 0,
        lastReset: new Date(),
      };

      // Update limit based on selected model
      window.updateModelLimit = function updateModelLimit() {
        const modelSelect = document.getElementById("aiModelSelect");
        if (!modelSelect) return;

        const model = modelSelect.value;
        currentModel = model;

        const limits = {
          "gemini-2.5-flash-lite": 300, // Highest limit
          "gemini-2.5-flash": 15,
          "gemini-3-pro-preview": 2,
          "gemini-2.0-flash-exp": 15,
        };

        API_FREE_LIMIT = limits[model] || 15;
        console.log(`üîÑ Model: ${model} | Limit: ${API_FREE_LIMIT} req/min`);
        updateApiUsageUI();
      };

      // Load API stats from localStorage
      function loadApiStats() {
        const stored = localStorage.getItem("api_usage_stats");
        if (stored) {
          try {
            apiUsageStats = JSON.parse(stored);
            // Check if we need to reset (new day)
            checkAndResetDailyStats();
          } catch (e) {
            console.warn("Could not parse API stats", e);
          }
        }
        // Schedule next reset at midnight
        scheduleMidnightReset();
      }

      // Check if it's a new day and reset if needed
      function checkAndResetDailyStats() {
        const lastResetDate = new Date(apiUsageStats.lastReset);
        const today = new Date();

        // Porovn√°me jen den/mƒõs√≠c/rok (bez ƒçasu)
        if (
          lastResetDate.getDate() !== today.getDate() ||
          lastResetDate.getMonth() !== today.getMonth() ||
          lastResetDate.getFullYear() !== today.getFullYear()
        ) {
          console.log("üîÑ Nov√Ω den - resetuji denn√≠ statistiky");
          apiUsageStats.dailyCalls = 0;
          apiUsageStats.lastReset = new Date().toISOString();
          saveApiStats();
        }
      }

      // Napl√°nuj reset v 10:00 r√°no (CET - ƒåesk√° republika)
      function scheduleMidnightReset() {
        const now = new Date();
        const resetTime = new Date(now);

        // Nastavit ƒças na 10:00
        resetTime.setHours(10, 0, 0, 0);

        // Pokud je u≈æ po 10:00, napl√°nuj reset na z√≠t≈ôej≈°√≠ 10:00
        if (resetTime <= now) {
          resetTime.setDate(resetTime.getDate() + 1);
        }

        const timeUntilReset = resetTime - now;
        const hoursUntil = Math.floor(timeUntilReset / 3600000);
        const minutesUntil = Math.floor((timeUntilReset % 3600000) / 60000);

        setTimeout(() => {
          console.log("üåÖ 10:00 - resetuji denn√≠ limit API");
          apiUsageStats.dailyCalls = 0;
          apiUsageStats.lastReset = new Date().toISOString();
          saveApiStats();
          updateApiUsageUI();
          alert("‚úÖ Denn√≠ limit API resetov√°n (10:00 r√°no)");
          scheduleMidnightReset(); // Reschedule for next day
        }, timeUntilReset);

        console.log(
          `üåÖ Dal≈°√≠ reset v 10:00 za ${hoursUntil}h ${minutesUntil}m`
        );
      }

      // Ruƒçn√≠ reset
      window.resetApiStats = function () {
        if (confirm("Opravdu resetovat API statistiky?")) {
          apiUsageStats = {
            totalCalls: 0,
            totalTokensIn: 0,
            totalTokensOut: 0,
            dailyCalls: 0,
            lastReset: new Date().toISOString(),
          };
          apiCallsTimestamp = [];
          apiCallsCount = 0;
          saveApiStats();
          updateApiUsageUI();
          alert("‚úÖ API statistiky resetov√°ny");
          console.log("üîÑ API stats resetov√°ny ruƒçnƒõ");
        }
      };

      // Save API stats to localStorage
      function saveApiStats() {
        localStorage.setItem("api_usage_stats", JSON.stringify(apiUsageStats));
      }

      // Record API call
      function recordApiCall(tokensIn = 0, tokensOut = 0) {
        const now = Date.now();
        apiCallsTimestamp.push(now);
        apiUsageStats.totalCalls++;
        apiUsageStats.dailyCalls = (apiUsageStats.dailyCalls || 0) + 1;
        apiUsageStats.totalTokensIn += tokensIn;
        apiUsageStats.totalTokensOut += tokensOut;

        // Vypoƒç√≠tej rate limit - sma≈æ vol√°n√≠ star≈°√≠ ne≈æ 1 minutu
        const oneMinuteAgo = now - 60000;
        apiCallsTimestamp = apiCallsTimestamp.filter((t) => t > oneMinuteAgo);
        apiCallsCount = apiCallsTimestamp.length;

        saveApiStats();
        updateApiUsageUI();

        console.log(
          `üìä API Call ${apiUsageStats.totalCalls} (dnes: ${apiUsageStats.dailyCalls}): ${apiCallsCount}/${API_FREE_LIMIT} (za minutu)`
        );
      }

      // Aktualizuj UI s informacemi o limitu
      function updateApiUsageUI() {
        const usage = document.getElementById("apiUsageInfo");
        if (usage) {
          const percentage = Math.round((apiCallsCount / API_FREE_LIMIT) * 100);
          const color =
            apiCallsCount >= API_FREE_LIMIT
              ? "#ff4444"
              : apiCallsCount > 10
              ? "#ff9900"
              : "#44ff44";

          usage.innerHTML = `
            <div style="font-size: 11px; color: #aaa; margin-top: 4px">
              üìä API limit: <span style="color: ${color}; font-weight: bold">${apiCallsCount}/${API_FREE_LIMIT}</span> za minutu
              <br/>
              üìà Dnes: <span style="color: #888">${
                apiUsageStats.dailyCalls || 0
              }</span> | Celkem: <span style="color: #888">${
            apiUsageStats.totalCalls
          }</span>
              <br/>
              <button onclick="window.resetApiStats()" style="font-size: 9px; padding: 2px 6px; margin-top: 2px; background: #333; border: 1px solid #555; color: #aaa; cursor: pointer; border-radius: 3px;">üîÑ Reset</button>
            </div>
          `;
        }
      }

      // Initialize API stats on page load
      loadApiStats();

      // Chat History for Context
      let chatSessionHistory = [];
      let shapesHistory = []; // To track shapes added per AI turn for Undo

      // Image Handling Vars
      let currentImageBase64 = null;
      let currentImageMimeType = null;

      // Expose functions to window for HTML event handlers
      window.handleImageSelect = (input) => {
        const file = input.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const result = e.target.result;
            currentImageBase64 = result.split(",")[1];
            currentImageMimeType = file.type;
            document.getElementById("aiPreviewImg").src = result;
            document.getElementById("aiImagePreview").style.display = "block";
            const fileNameEl = document.getElementById("aiFileName");
            if (fileNameEl) fileNameEl.textContent = file.name;
          } catch (error) {
            console.error("Chyba p≈ôi naƒç√≠t√°n√≠ obr√°zku:", error);
            alert(
              "‚ö†Ô∏è Nepoda≈ôilo se naƒç√≠st obr√°zek.\n\nZkuste jin√Ω soubor nebo form√°t."
            );
          }
        };

        reader.onerror = () => {
          alert(
            "‚ö†Ô∏è Nepoda≈ôilo se p≈ôeƒç√≠st soubor.\n\nZkontrolujte opr√°vnƒõn√≠ a zkuste to znovu."
          );
        };

        reader.readAsDataURL(file);
      };

      window.clearImage = () => {
        currentImageBase64 = null;
        currentImageMimeType = null;
        document.getElementById("aiImageInput").value = "";
        document.getElementById("aiImagePreview").style.display = "none";
        const fileNameEl = document.getElementById("aiFileName");
        if (fileNameEl) fileNameEl.textContent = "";
      };

      function addMessageToChat(role, text, shapesCount = 0) {
        const container = document.getElementById("aiChatHistory");
        const div = document.createElement("div");
        div.className = `chat-msg ${role}`;

        let content = text.replace(/\n/g, "<br>");

        // System zpr√°vy maj√≠ speci√°ln√≠ styling
        if (role === "system") {
          div.style.background = "rgba(124, 58, 237, 0.15)";
          div.style.borderLeft = "3px solid #7c3aed";
          div.style.fontSize = "12px";
          div.style.fontStyle = "italic";
        }

        // Pokud model vygeneroval tvary, p≈ôid√°me ≈°t√≠tek
        if (role === "model" && shapesCount > 0) {
          content =
            `<span class="shape-tag">‚úèÔ∏è +${shapesCount} tvar≈Ø</span><br>` +
            content;
        }

        // P≈ôidat tlaƒç√≠tko pro opravu u AI odpovƒõd√≠ (pro uƒçen√≠)
        if (role === "model") {
          content += `<br><button class="correction-btn" onclick="window.correctAIResponse('${text.replace(
            /'/g,
            "\\'"
          )}', this)" style="margin-top:8px;padding:4px 8px;background:#3a7bc8;border:none;border-radius:3px;color:white;font-size:10px;cursor:pointer;">‚úèÔ∏è Opravit (AI se nauƒç√≠)</button>`;
        }

        div.innerHTML = content;
        container.appendChild(div);
        container.scrollTop = container.scrollHeight;
      }

      // === CORRECTION SYSTEM - AI learns from user corrections ===
      window.correctAIResponse = function (originalResponse, buttonElement) {
        const correction = prompt(
          "üéì Jak by mƒõla AI odpovƒõdƒõt spr√°vnƒõ?\n\nAI se z toho pouƒç√≠ a p≈ô√≠≈°tƒõ to udƒõl√° l√©pe:",
          originalResponse
        );

        if (
          correction &&
          correction.trim() &&
          correction !== originalResponse
        ) {
          // Zapsat opravu do pamƒõti
          window.recordCorrection(originalResponse, correction);

          // Vizu√°ln√≠ feedback
          buttonElement.innerHTML = "‚úÖ Ulo≈æeno";
          buttonElement.style.background = "#4CAF50";
          buttonElement.disabled = true;

          alert(
            '‚úÖ AI se nauƒçila z tv√© opravy!\n\nüìö P≈ô√≠≈°tƒõ bude odpov√≠dat l√©pe.\n\nüí° Otev≈ôi "üß† AI Pamƒõ≈•" pro zobrazen√≠ v≈°ech nauƒçen√Ωch vƒõc√≠.'
          );
        }
      };

      // AI UNDO LOGIC
      window.aiUndo = function () {
        const container = document.getElementById("aiChatHistory");
        // Must have at least 2 messages (user + model) to undo a turn
        // The first child is the "Start conversation" text, so check > 3 children usually
        // But let's check chatSessionHistory length

        if (chatSessionHistory.length < 2) {
          alert("Nen√≠ co vr√°tit.");
          return;
        }

        // 1. Remove last User + Model interaction from history
        chatSessionHistory.pop(); // Remove Model
        chatSessionHistory.pop(); // Remove User

        // 2. Remove messages from UI (last 2 elements)
        // Be careful if there is a loading bubble or others.
        // We assume standard flow: user msg -> model msg
        const msgs = container.querySelectorAll(".chat-msg");
        if (msgs.length >= 2) {
          container.removeChild(msgs[msgs.length - 1]); // Model
          container.removeChild(msgs[msgs.length - 2]); // User
        }

        // 3. Revert Geometry if the last turn added shapes
        // Simple approach: standard global undo if available, but ideally we track what AI added
        // For now, let's trigger the global undo ONCE if the last model message had shapes.
        // A better way: maintain specific undo history for AI.
        // Let's assume the user uses global undo for geometry primarily.
        // But the request was "step back in what AI did".
        // Implementation: We will trigger standard undo if shapes were added in last step.
        // Simplified: Just undo once.
        window.undo();
      };

      window.aiRedo = function () {
        // Redo pou≈æ√≠v√° glob√°ln√≠ redo funkci pokud existuje
        // V souƒçasn√© implementaci nem√°me redo stack, ale m≈Ø≈æeme ho p≈ôidat
        // Prozat√≠m jen zavol√° standardn√≠ redo pokud bude implementov√°no
        if (window.redo && typeof window.redo === "function") {
          window.redo();
        } else {
          alert("Funkce Dop≈ôedu nen√≠ zat√≠m implementov√°na.");
        }
      };

      window.callGemini = async () => {
        const startTime = performance.now();
        console.log("üöÄ callGemini called at", new Date().toLocaleTimeString());

        // 1. Z√≠skat aktivn√≠ API kl√≠ƒç
        if (!window.getCurrentApiKey) {
          alert(
            "‚ùå Chyba: Funkce getCurrentApiKey nen√≠ dostupn√°. Zkuste obnovit str√°nku."
          );
          console.error("getCurrentApiKey is not defined");
          return;
        }

        const apiKey = window.getCurrentApiKey();
        console.log("üîë API Key:", apiKey ? "SET" : "NOT SET");

        if (!apiKey) {
          alert(
            "Pro pou≈æit√≠ AI mus√≠te nejprve nastavit API kl√≠ƒç v nastaven√≠ (‚öôÔ∏è)."
          );
          window.openSettings();
          return;
        }

        const promptInput = document.getElementById("aiPrompt");
        const prompt = promptInput.value.trim();
        const btn = document.getElementById("btnGenerate");
        const status = document.getElementById("aiStatus");
        const useThinking = document.getElementById("useThinking")?.checked; // NEW THINKING CHECK

        if (!prompt && !currentImageBase64) {
          return; // Empty
        }

        // Add User Message
        const userMsg = prompt || (currentImageBase64 ? "[Obr√°zek]" : "...");
        addMessageToChat("user", userMsg);

        // Record command to AI memory
        if (prompt) window.recordCommand(prompt);

        promptInput.value = ""; // Clear input

        // UI Loading state
        const originalBtn = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<div class="loading-spinner"></div>';

        // Add temporary loading bubble
        const container = document.getElementById("aiChatHistory");
        const loadingDiv = document.createElement("div");
        loadingDiv.className = "chat-msg model loading-bubble";
        loadingDiv.innerHTML =
          '<div class="loading-dots"><div></div><div></div><div></div></div>';
        container.appendChild(loadingDiv);
        container.scrollTop = container.scrollHeight;

        try {
          // Initialize AI with user key
          // Check which Google GenAI class is available
          const GoogleGenAIClass =
            window.GoogleGenAI || window.GoogleGenerativeAI;

          if (!GoogleGenAIClass) {
            throw new Error(
              "Google GenAI library not loaded. Please refresh the page."
            );
          }

          const ai = new GoogleGenAIClass({ apiKey: apiKey });

          // Get shapes and selected items from window scope
          const currentShapes = window.shapes || [];
          const currentSelections = window.selectedItems || [];
          const axisMode = window.axisMode || "lathe";

          const axisLabel =
            axisMode === "lathe"
              ? "Z axis is Horizontal (Length/Longitudinal), X axis is Vertical (Diameter/Radius)."
              : "X axis is Horizontal, Y axis is Vertical.";

          // System Instruction (Dynamic context)
          // --- UPDATE: PASS SHAPE GEOMETRY AND SELECTED ITEMS WITH LABELS ---
          // Omezit context jen na posledn√≠ch 20 shapes + selected items
          const recentShapes = currentShapes.slice(-20);

          // Spoƒç√≠tat pr≈Øseƒç√≠ky pro kontext
          const contextIntersections = [];
          for (
            let i = Math.max(0, currentShapes.length - 20);
            i < currentShapes.length;
            i++
          ) {
            for (let j = i + 1; j < currentShapes.length; j++) {
              const s1 = currentShapes[i];
              const s2 = currentShapes[j];
              let pts = [];

              if (s1.type === "line" && s2.type === "circle") {
                pts = intersectLineCircle(s1, s2);
              } else if (s1.type === "circle" && s2.type === "line") {
                pts = intersectLineCircle(s2, s1);
              } else if (s1.type === "circle" && s2.type === "circle") {
                pts = intersectCircleCircle(s1, s2);
              } else if (s1.type === "line" && s2.type === "line") {
                const pt = lineIntersection(s1, s2);
                if (pt) pts = [pt];
              }

              pts.forEach((pt) => {
                contextIntersections.push({
                  shape1_idx: i,
                  shape2_idx: j,
                  x: parseFloat(pt.x.toFixed(2)),
                  y: parseFloat(pt.y.toFixed(2)),
                });
              });
            }
          }

          const shapesContext =
            recentShapes.length > 0
              ? `Shapes on canvas (last ${
                  recentShapes.length
                }): ${JSON.stringify(
                  recentShapes.map((s) => {
                    // Konverze Y sou≈ôadnic pro diameter mode
                    if (xMeasureMode === "diameter") {
                      if (s.type === "circle") {
                        return { ...s, cy: s.cy * 2 };
                      } else if (s.type === "line") {
                        return { ...s, y1: s.y1 * 2, y2: s.y2 * 2 };
                      } else if (s.type === "point") {
                        return { ...s, y: s.y * 2 };
                      }
                    }
                    return s;
                  })
                )}

      Intersections found: ${
        contextIntersections.length > 0
          ? JSON.stringify(
              contextIntersections.map((i) => {
                // Konverze Y sou≈ôadnic pro diameter mode
                if (xMeasureMode === "diameter") {
                  return { ...i, y: i.y * 2 };
                }
                return i;
              })
            )
          : "None"
      }

      NOTE: When user asks about intersections, use the data above. Intersection x,y are in JSON coords (x=Z, y=X).
      ${
        xMeasureMode === "diameter"
          ? "\n‚ö†Ô∏è DIAMETER MODE ACTIVE: X axis values in context are DIAMETER (√ó2). When creating shapes, use these EXACT values as shown - conversion is automatic."
          : ""
      }`
              : "No shapes yet.";

          // Format selections with labels
          const selectionContext =
            currentSelections.length > 0
              ? `SELECTED: ${JSON.stringify(
                  currentSelections.map((s) => ({
                    label: s.label,
                    type: s.type,
                    x: s.x || s.ref.x1,
                    y: s.y || s.ref.y1,
                  }))
                )}`
              : ``;

          // === LOAD AI LEARNING CONTEXT ===
          const aiMemoryContext = window.getAIMemoryContext();
          const learningContext =
            aiMemoryContext.topCommands.length > 0 ||
            aiMemoryContext.recentCorrections.length > 0 ||
            aiMemoryContext.successfulPatterns.length > 0
              ? `
      üß† LEARNED KNOWLEDGE (Use this to improve responses):

      üìä Most Used Commands (Learn patterns):
      ${
        aiMemoryContext.topCommands
          .map((cmd) => `  ‚Ä¢ "${cmd.command}" (used ${cmd.count}√ó)`)
          .join("\n") || "  None yet"
      }

      ‚úÖ Successful Patterns (Proven to work):
      ${
        aiMemoryContext.successfulPatterns
          .map(
            (p) => `  ‚Ä¢ Input: "${p.input}" ‚Üí Created ${p.count} ${p.type}(s)`
          )
          .join("\n") || "  None yet"
      }

      ‚úèÔ∏è Recent Corrections (Learn from mistakes):
      ${
        aiMemoryContext.recentCorrections
          .map(
            (corr) =>
              `  ‚Ä¢ User corrected: "${corr.aiResponse}" ‚Üí "${corr.userCorrection}"`
          )
          .join("\n") || "  None yet"
      }

      üìù User Preferences:
      ${
        Object.entries(aiMemoryContext.preferences)
          .map(([k, v]) => `  ‚Ä¢ ${k}: ${v}`)
          .join("\n") || "  None set"
      }

      üí° ADAPT: Use this knowledge to predict what user wants, recognize similar patterns, and avoid past mistakes!
      `
              : "";

          // OPTIMIZED AI SYSTEM PROMPT - Enhanced with CNC/G-code support + LEARNING
          const modeIndicator =
            xMeasureMode === "diameter" ? "‚åÄ DIAMETER MODE" : "R RADIUS MODE";
          const modeExplanation =
            xMeasureMode === "diameter"
              ? "X values in context are shown as DIAMETER (user sees X=100 for ‚åÄ100). Create shapes with these exact values - conversion is automatic."
              : "X values in context are shown as RADIUS (user sees X=50 for R50). Create shapes with these exact values.";

          const systemPrompt = `CAD Assistant for CNC Lathe/Mill operations (Czech language).

      COORDINATE SYSTEM:
      Z-axis (horizontal/‚Üí) = JSON 'x' property
      X-axis (vertical/‚Üë) = JSON 'y' property
      Origin: (0,0) center
      Report coords as: "Z=[x] X=[y]"

      üîß CURRENT MODE: ${modeIndicator}
      ${modeExplanation}

      ANGLES (Standard Unit Circle):
      0¬∞=RIGHT(+Z), 90¬∞=UP(+X), 180¬∞=LEFT(-Z), 270¬∞=DOWN(-X)

      INPUT FORMATS:
      1. Natural language: "kru≈ænice Z100 X50 R30"
      2. CNC/G-code style: "X80Z56R52" or "X50Z56AP0RP120"

      CNC SYNTAX PARSING:
      - XvalZval = position (X=diameter/radius, Z=length)
      - Rval = radius for circle
      - APval = angle in polar (0¬∞=right, 90¬∞=up, 180¬∞=left, 270¬∞=down)
      - RPval = polar radius/length (distance from start point)

      Examples:
      "X80Z56R52" ‚Üí Circle at (Z=56,X=80) with radius 52
      "X50Z56AP0RP120" ‚Üí Line from (Z=56,X=50) at angle 0¬∞ length 120mm
        ‚Üí End point: Z=56+120*cos(0¬∞)=176, X=50+120*sin(0¬∞)=50
        ‚Üí {"type":"line","x1":56,"y1":50,"x2":176,"y2":50}

      "X80Z56R52;X50Z56AP0RP120" ‚Üí Circle + Line:
        - Circle: center (56,80), R=52
        - Line: from (56,50) angle 0¬∞ length 120 ‚Üí to (176,50)

      IMPORTANT FOR POLAR LINES:
      When user says "√∫seƒçka OD ST≈òEDU kru≈ænice" or "line FROM CENTER of circle":
      - Start point (x1,y1) = center of that circle (cx,cy)
      - End point: calculate using angle and length FROM that center
      - CALCULATION:
        * x2 = x1 + length*cos(angle_degrees * œÄ/180)
        * y2 = y1 + length*sin(angle_degrees * œÄ/180)

      - Example 1: Center Z=100,X=100 + line angle 0¬∞ length 120mm
        ‚Üí x2 = 100 + 120*cos(0¬∞) = 100 + 120*1 = 220
        ‚Üí y2 = 100 + 120*sin(0¬∞) = 100 + 120*0 = 100
        ‚Üí Line: {"type":"line","x1":100,"y1":100,"x2":220,"y2":100}

      - Example 2: Center Z=96,X=78 + line angle 5¬∞ length 250mm
        ‚Üí x2 = 96 + 250*cos(5¬∞) = 96 + 250*0.9962 = 345
        ‚Üí y2 = 78 + 250*sin(5¬∞) = 78 + 250*0.0872 = 100
        ‚Üí Line: {"type":"line","x1":96,"y1":78,"x2":345,"y2":100}

      ‚ö†Ô∏è CRITICAL RULES FOR LINES:
      1. ALWAYS calculate BOTH x2 AND y2 using the angle and length
      2. DO NOT provide only y2 without x2 - both must be present
      3. Use the FULL formulas:
         - x2 = x1 + length*cos(angle_in_radians)
         - y2 = y1 + length*sin(angle_in_radians)
      4. Even if you're unsure about x, always provide calculated x2
      5. A line with x1==x2 is vertical and will not match user intent if angle != 90¬∞
      - A line with x1==x2 AND y1==y2 is invisible (zero length)!


      AVAILABLE TOOLS & OPERATIONS:
      ‚úèÔ∏è DRAWING: line, circle, point
      üîß CONSTRUCTION: tangent, perpendicular, parallel
      ‚úÇÔ∏è EDITING: trim, extend, offset, mirror, erase
      üìê ANALYSIS: measure, intersections, distance

      RESPONSE FORMAT (strict JSON only):
      {"response_text":"Brief Czech confirmation <50 chars","shapes":[...]}

      SHAPE TYPES:
      Line: {"type":"line","x1":z1,"y1":x1,"x2":z2,"y2":x2}
      Circle: {"type":"circle","cx":z,"cy":x,"r":radius}
      Point: {"type":"point","x":z,"y":x}

      POLAR CALCULATION (Œ± in degrees):
      x_end = cx + length*cos(Œ±*œÄ/180)
      y_end = cy + length*sin(Œ±*œÄ/180)

      CRITICAL RULES:
      1. DRAW commands ‚Üí add shapes[] (never empty)
      2. CALCULATE/MEASURE commands ‚Üí empty shapes[], answer in response_text
      3. Parse CNC syntax: AP=angle, RP=polar_length
      4. For polar coords: calculate endpoint using angle and length
      5. NEVER hallucinate coords - use provided data or ask
      6. Support Czech terms: √∫seƒçka=line, kru≈ænice=circle, st≈ôed=center

      EXAMPLES:
      Natural: {"response_text":"Kru≈ænice R50","shapes":[{"type":"circle","cx":100,"cy":100,"r":50}]}
      CNC: {"response_text":"Kru≈ænice + √∫seƒçka 0¬∞ 120mm","shapes":[{"type":"circle","cx":56,"cy":80,"r":52},{"type":"line","x1":56,"y1":50,"x2":176,"y2":50}]}

      ${axisLabel}
      ${shapesContext}
      ${selectionContext}
      ${learningContext}`;

          // OPTIMIZED: Smart history management - compress old messages
          function compressHistory(history, maxMessages = 12) {
            if (history.length <= maxMessages) return history;

            // Keep last 6 messages (3 exchanges) in full detail
            const recentMessages = history.slice(-6);
            const oldMessages = history.slice(0, -6);

            // Count shapes created in old messages for context
            let shapeCount = 0;
            oldMessages.forEach((msg) => {
              if (msg.role === "model" && msg.parts[0]?.text) {
                try {
                  const json = JSON.parse(msg.parts[0].text);
                  if (json.shapes) shapeCount += json.shapes.length;
                } catch (e) {}
              }
            });

            // Create compressed summary
            const summary = {
              role: "user",
              parts: [
                {
                  text: `[Previous: ${
                    oldMessages.length / 2
                  } exchanges, ${shapeCount} shapes created]`,
                },
              ],
            };

            return [summary, ...recentMessages];
          }

          // === LIMIT CHAT HISTORY - Optimizace pro dlouh√© konverzace ===
          const MAX_CHAT_HISTORY = 50;
          if (chatSessionHistory.length > MAX_CHAT_HISTORY) {
            // Zachovat prvn√≠ch 3 messages (popis syst√©mu) a posledn√≠ N messages
            const systemMessages = chatSessionHistory.slice(
              0,
              Math.min(6, chatSessionHistory.length)
            );
            const recentMessages = chatSessionHistory.slice(
              -Math.max(0, MAX_CHAT_HISTORY - 6)
            );
            chatSessionHistory = [...systemMessages, ...recentMessages];
          }

          let contents = chatSessionHistory;

          // Add new message to history
          const newParts = [];
          if (prompt) newParts.push({ text: `User Command: ${prompt}` });
          if (currentImageBase64) {
            newParts.push({
              inlineData: {
                mimeType: currentImageMimeType,
                data: currentImageBase64,
              },
            });
          }

          // Get selected model
          const modelSelect = document.getElementById("aiModelSelect");
          let selectedModel = modelSelect
            ? modelSelect.value
            : "gemini-2.5-flash";

          // CONFIG SETUP
          const config = {
            systemInstruction: systemPrompt,
            responseMimeType: "application/json",
            responseSchema: {
              type: Type.OBJECT,
              properties: {
                response_text: { type: Type.STRING },
                shapes: {
                  type: Type.ARRAY,
                  items: {
                    type: Type.OBJECT,
                    properties: {
                      type: { type: Type.STRING, enum: ["line", "circle"] },
                      x1: { type: Type.NUMBER },
                      y1: { type: Type.NUMBER },
                      x2: { type: Type.NUMBER },
                      y2: { type: Type.NUMBER },
                      cx: { type: Type.NUMBER },
                      cy: { type: Type.NUMBER },
                      r: { type: Type.NUMBER },
                      length: { type: Type.NUMBER },
                      angle: { type: Type.NUMBER },
                    },
                    required: ["type"],
                  },
                },
              },
            },
          };

          // THINKING MODE OVERRIDE
          if (useThinking) {
            selectedModel = "gemini-3-pro-preview";
            config.thinkingConfig = { thinkingBudget: 32768 };
            // FIX: Remove JSON enforcement for Thinking models to avoid 500 errors
            delete config.responseMimeType;
            delete config.responseSchema;
          }

          // OPTIMIZED: Use retry logic with exponential backoff
          const apiCallStart = performance.now();
          console.log("‚è±Ô∏è API call starting...");

          const response = await retryWithBackoff(async () => {
            return await ai.models.generateContent({
              model: selectedModel,
              contents: [...contents, { role: "user", parts: newParts }],
              config: config,
            });
          }, 3);

          const apiCallTime = performance.now() - apiCallStart;
          console.log(
            `‚è±Ô∏è API response received in ${(apiCallTime / 1000).toFixed(1)}s`
          );

          // üìä Record API call statistics
          const tokensIn = response.usageMetadata?.promptTokenCount || 0;
          const tokensOut = response.usageMetadata?.candidatesTokenCount || 0;
          recordApiCall(tokensIn, tokensOut);

          // Remove loading bubble
          container.removeChild(loadingDiv);

          if (response.text) {
            let result;

            // Aggressive JSON cleaning
            let cleanedText = response.text;

            // Remove markdown code blocks
            cleanedText = cleanedText
              .replace(/```json\s*/gi, "")
              .replace(/```\s*/g, "");

            // Remove any text before first { and after last }
            const firstBrace = cleanedText.indexOf("{");
            const lastBrace = cleanedText.lastIndexOf("}");
            if (
              firstBrace !== -1 &&
              lastBrace !== -1 &&
              lastBrace > firstBrace
            ) {
              cleanedText = cleanedText.substring(firstBrace, lastBrace + 1);
            }

            // Trim whitespace
            cleanedText = cleanedText.trim();

            // Log for debugging
            console.log(
              "AI Response (first 200 chars):",
              response.text.substring(0, 200)
            );
            console.log("Cleaned JSON:", cleanedText.substring(0, 200));

            // Fix incomplete JSON (missing closing brackets)
            let fixedJson = cleanedText;

            // Count opening and closing brackets
            const openBraces = (fixedJson.match(/\{/g) || []).length;
            const closeBraces = (fixedJson.match(/\}/g) || []).length;
            const openBrackets = (fixedJson.match(/\[/g) || []).length;
            const closeBrackets = (fixedJson.match(/\]/g) || []).length;

            // Add missing closing brackets
            if (openBrackets > closeBrackets) {
              fixedJson += "]".repeat(openBrackets - closeBrackets);
            }
            if (openBraces > closeBraces) {
              fixedJson += "}".repeat(openBraces - closeBraces);
            }

            // BEFORE shortening numbers: Fix missing x2 in line shapes
            // Pattern: "x1":num,"y1":num,"y2":num} WITHOUT x2
            fixedJson = fixedJson.replace(
              /\{"type":"line","x1":([^,]+),"y1":([^,]+),"y2":([^}]+)\}/g,
              '{"type":"line","x1":$1,"y1":$2,"x2":$1,"y2":$3}'
            );

            // Remove incomplete number at the end (like "100.0000000000000185676...")
            // Zkr√°tit dlouh√° ƒç√≠sla v≈°ude v JSON (ne jen na konci)
            fixedJson = fixedJson.replace(/(\d+\.\d{6})\d{4,}/g, "$1");
            fixedJson = fixedJson.replace(/,\s*([}\]])/g, "$1"); // Remove trailing commas

            console.log("Fixed JSON:", fixedJson.substring(0, 200));

            try {
              // Try to parse the fixed JSON response
              result = JSON.parse(fixedJson);
            } catch (parseError) {
              console.error("JSON Parse Error:", parseError);
              console.error("Full fixed response:", fixedJson);

              // Last resort: try to extract valid JSON with regex
              const jsonMatch = fixedJson.match(
                /\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/
              );
              if (jsonMatch) {
                try {
                  result = JSON.parse(jsonMatch[0]);
                  console.log("‚úÖ Recovered JSON from response");
                } catch (e) {
                  console.error("‚ùå Recovery failed:", e);
                  addMessageToChat(
                    "model",
                    `‚ùå AI nevr√°tila validn√≠ JSON.\n\nüîç Debug:\n${fixedJson.substring(
                      0,
                      100
                    )}...\n\nüí° Zkuste:\n‚Ä¢ Gemini 2.5 Flash m√° limit 20/den - p≈ôidejte dal≈°√≠ kl√≠ƒç\n‚Ä¢ Zjednodu≈°it dotaz\n‚Ä¢ Obnovit str√°nku`
                  );
                  return;
                }
              } else {
                addMessageToChat(
                  "model",
                  `‚ùå AI nevr√°tila JSON form√°t.\n\nüí° Zkuste Gemini 1.5 Flash - ten m√° nejlep≈°√≠ JSON podporu.`
                );
                return;
              }
            }

            const replyText = result.response_text || "Hotovo.";
            const newShapes = result.shapes || [];

            // Debug: Show what AI returned
            console.log("üìä AI Response:", {
              response_text: replyText,
              shapes_count: newShapes.length,
              shapes: newShapes,
            });

            // If AI returned empty shapes, show debug info
            if (newShapes.length === 0) {
              console.warn("‚ö†Ô∏è AI vr√°tila pr√°zdn√© shapes array!");
              console.log("Full JSON:", result);
            }

            // OPTIMIZED: Add shapes to canvas with validation
            if (Array.isArray(newShapes) && newShapes.length > 0) {
              let addedCount = 0;
              newShapes.forEach((s) => {
                try {
                  // DIAMETER MODE CONVERSION
                  // AI dost√°v√° sou≈ôadnice v diameter mode (cy=100)
                  // Ale mus√≠me ulo≈æit v radius mode (cy=50)
                  const convertY = (y) => {
                    return xMeasureMode === "diameter" ? y / 2 : y;
                  };

                  if (s.type === "line") {
                    // Fix missing x2 if present
                    if (
                      typeof s.x1 === "number" &&
                      typeof s.y1 === "number" &&
                      typeof s.y2 === "number" &&
                      typeof s.x2 !== "number"
                    ) {
                      // AI vr√°tila jen y2 m√≠sto x2 - opravit
                      s.x2 = s.x1; // V√Ωchoz√≠: svisl√° ƒç√°ra
                      console.warn("‚ö†Ô∏è Fixed missing x2 - set to x1");
                    }

                    if (
                      typeof s.x1 === "number" &&
                      typeof s.y1 === "number" &&
                      typeof s.x2 === "number" &&
                      typeof s.y2 === "number"
                    ) {
                      // Check if line has zero length (degenerate case)
                      const lineLength = Math.sqrt(
                        (s.x2 - s.x1) ** 2 + (s.y2 - s.y1) ** 2
                      );

                      if (lineLength < 0.1) {
                        // Line has no length - AI probably made an error
                        // Try to detect if it was supposed to be horizontal or vertical
                        console.warn(
                          "‚ö†Ô∏è Zero-length line detected - attempting repair:",
                          s
                        );

                        // If we have shape context from AI prompt, we could infer direction
                        // For now, make it horizontal 100 units long
                        s.x2 = s.x1 + 100;
                        console.log(
                          "   Repaired to horizontal line: x1=" +
                            s.x1 +
                            ", x2=" +
                            s.x2
                        );
                      } else if (s.x1 === s.x2 && lineLength > 0.5) {
                        // Vertical line with non-zero length - likely AI forgot x2
                        // Try to infer x from the non-zero y distance
                        const dy = s.y2 - s.y1;
                        // If dy is very small, assume it's supposed to be horizontal
                        if (Math.abs(dy) < 1) {
                          s.x2 = s.x1 + 100;
                          console.log(
                            "‚ö†Ô∏è Vertical line with near-zero dy detected - converting to horizontal"
                          );
                        } else {
                          // Keep as is - might be intentionally vertical
                          console.warn(
                            "‚ö†Ô∏è Vertical line: x1==x2, but has length dy=" + dy
                          );
                        }
                      }

                      // If AI provided length and angle, recalculate x2 if it's missing/wrong
                      if (
                        typeof s.length === "number" &&
                        typeof s.angle === "number" &&
                        s.length > 0
                      ) {
                        const angleRad = (s.angle * Math.PI) / 180;
                        const calculatedX2 =
                          s.x1 + s.length * Math.cos(angleRad);
                        const calculatedY2 =
                          s.y1 + s.length * Math.sin(angleRad);

                        // If current x2 is too close to x1, use calculated values
                        if (Math.abs(s.x2 - s.x1) < 1) {
                          console.log(
                            "üîß Using AI-provided length/angle to calculate endpoint:",
                            { length: s.length, angle: s.angle }
                          );
                          s.x2 = calculatedX2;
                          s.y2 = calculatedY2;
                          console.log("   Recalculated:", {
                            x2: s.x2.toFixed(2),
                            y2: s.y2.toFixed(2),
                          });
                        }
                      }

                      window.shapes.push({
                        type: "line",
                        x1: s.x1,
                        y1: convertY(s.y1),
                        x2: s.x2,
                        y2: convertY(s.y2),
                      });
                      console.log("‚úÖ Line added:", {
                        x1: s.x1,
                        y1: s.y1,
                        x2: s.x2,
                        y2: s.y2,
                      });
                      addedCount++;
                    } else {
                      console.warn("‚ö†Ô∏è Invalid line skipped:", s);
                    }
                  } else if (
                    s.type === "circle" &&
                    typeof s.cx === "number" &&
                    typeof s.cy === "number" &&
                    typeof s.r === "number" &&
                    s.r > 0
                  ) {
                    window.shapes.push({
                      type: "circle",
                      cx: s.cx,
                      cy: convertY(s.cy),
                      r: s.r,
                    });
                    console.log("‚úÖ Circle added:", {
                      cx: s.cx,
                      cy: s.cy,
                      r: s.r,
                    });
                    addedCount++;
                  } else if (
                    s.type === "point" &&
                    typeof s.x === "number" &&
                    typeof s.y === "number"
                  ) {
                    // Add construction point
                    window.points.push({
                      x: s.x,
                      y: convertY(s.y),
                    });
                    addedCount++;
                  } else {
                    console.warn("‚ö†Ô∏è Invalid shape skipped:", s);
                    console.warn("  Type check:", {
                      type: s.type,
                      x1: typeof s.x1,
                      y1: typeof s.y1,
                      x2: typeof s.x2,
                      y2: typeof s.y2,
                      cx: typeof s.cx,
                      cy: typeof s.cy,
                      r: typeof s.r,
                    });
                  }
                } catch (e) {
                  console.error("Error adding shape:", e, s);
                }
              });

              console.log(
                `‚úÖ Added ${addedCount}/${newShapes.length} shapes (diameter mode: ${xMeasureMode})`
              );

              if (window.updateSnapPoints) window.updateSnapPoints();
              if (window.draw) window.draw();
            }

            // 2. Add message to chat UI
            addMessageToChat("model", replyText, newShapes.length);

            // Show learning indicator if AI used learned knowledge
            if (learningContext) {
              const indicator = document.createElement("div");
              indicator.style.cssText =
                "background: #1a3a1a; border: 1px solid #2a5a2a; border-radius: 4px; padding: 6px; margin: 8px 0; font-size: 10px; color: #90ee90;";
              indicator.innerHTML =
                "üéì AI pou≈æila nauƒçen√© znalosti z p≈ôedchoz√≠ch konverzac√≠";
              document.getElementById("aiChatHistory").appendChild(indicator);
            }

            // === AUTO-LEARNING: Record successful patterns ===
            if (newShapes.length > 0 && prompt) {
              // Learn from successful commands
              const pattern = {
                input: prompt.toLowerCase().substring(0, 50),
                outputType: newShapes[0].type,
                shapeCount: newShapes.length,
                timestamp: new Date().toISOString(),
              };

              // Save to memory as successful pattern
              const memory = loadAIMemory();
              if (!memory.successfulPatterns) memory.successfulPatterns = [];
              memory.successfulPatterns.push(pattern);

              // Keep only last 50 patterns
              if (memory.successfulPatterns.length > 50) {
                memory.successfulPatterns =
                  memory.successfulPatterns.slice(-50);
              }

              saveAIMemory(memory);
              console.log("üéì AI learned from success:", pattern);
            }

            // 3. Update History
            chatSessionHistory.push({ role: "user", parts: newParts });
            chatSessionHistory.push({
              role: "model",
              parts: [{ text: response.text }],
            });

            window.clearImage();
          }
        } catch (err) {
          console.error(err);
          if (container.contains(loadingDiv)) container.removeChild(loadingDiv);

          // Odstranit posledn√≠ user zpr√°vu z UI (ta co zp≈Øsobila chybu)
          const msgs = container.querySelectorAll(".chat-msg.user");
          if (msgs.length > 0) {
            const lastUserMsg = msgs[msgs.length - 1];
            container.removeChild(lastUserMsg);
          }

          // Vr√°tit prompt zpƒõt do inputu pro opakov√°n√≠
          promptInput.value = prompt;

          // Zobrazit chybovou zpr√°vu
          const errorText = err.message || String(err);
          let userFriendlyError = "";

          if (
            errorText.includes("429") ||
            errorText.includes("quota") ||
            errorText.includes("RESOURCE_EXHAUSTED")
          ) {
            // Pokusit se p≈ôepnout na dal≈°√≠ API kl√≠ƒç
            const switched = window.switchToNextApiKey();

            if (switched) {
              userFriendlyError =
                "‚ö†Ô∏è P≈ôekroƒçen limit API vol√°n√≠.\n\nüîÑ Automaticky p≈ôepnuto na dal≈°√≠ API kl√≠ƒç.\n\nüí° Kliknƒõte Enter pro odesl√°n√≠ s nov√Ωm kl√≠ƒçem.";
            } else {
              userFriendlyError =
                "‚ö†Ô∏è P≈ôekroƒçen limit API vol√°n√≠.\n\n‚ùå Nem√°te dal≈°√≠ API kl√≠ƒçe.\n\nüí° Zkuste:\n‚Ä¢ P≈ôidat dal≈°√≠ API kl√≠ƒç v nastaven√≠ (‚öôÔ∏è)\n‚Ä¢ Poƒçkat p√°r minut\n‚Ä¢ P≈ôepnout na jin√Ω model\n‚Ä¢ Zkontrolovat limity: https://ai.dev/usage";
            }
          } else if (
            errorText.includes("404") ||
            errorText.includes("not found")
          ) {
            userFriendlyError =
              "‚ö†Ô∏è Model nenalezen.\n\nüí° Zkuste:\n‚Ä¢ P≈ôepnout na Gemini 2.5 Flash\n‚Ä¢ Ovƒõ≈ôit platnost API kl√≠ƒçe v nastaven√≠";
          } else if (
            errorText.includes("403") ||
            errorText.includes("PERMISSION_DENIED")
          ) {
            userFriendlyError =
              "‚ö†Ô∏è API kl√≠ƒç byl zam√≠tnut.\n\nüí° Zkuste:\n‚Ä¢ Vytvo≈ôit nov√Ω API kl√≠ƒç v Google AI Studio\n‚Ä¢ Ovƒõ≈ôit ≈æe kl√≠ƒç nen√≠ expired";
          } else {
            userFriendlyError = `‚ùå Chyba: ${errorText}`;
          }

          addMessageToChat(
            "model",
            userFriendlyError +
              "\n\n‚úèÔ∏è V√°≈° dotaz byl vr√°cen do pole - m≈Ø≈æete ho upravit a poslat znovu."
          );
        } finally {
          const totalTime = performance.now() - startTime;
          console.log(
            `‚úÖ callGemini completed in ${(totalTime / 1000).toFixed(1)}s`
          );

          btn.disabled = false;
          btn.innerHTML = originalBtn;
          document.getElementById("aiPrompt").focus();
        }
      };

      console.log("‚úÖ window.callGemini is ready");

      // Timeout warning for slow module loading
      setTimeout(() => {
        if (!window.callGemini) {
          console.warn(
            "‚ö†Ô∏è AI Module loading is taking longer than expected (5s)"
          );
          const snapInfo = document.getElementById("snapInfo");
          if (snapInfo) {
            snapInfo.textContent =
              "‚ö†Ô∏è AI se naƒç√≠t√° pomalu - zkuste obnovit (F5)";
            snapInfo.style.display = "block";
          }
        }
      }, 5000);
    </script>

    <!-- ORIGINAL LOGIC + KEY MANAGER -->
    <script>
      // === GLOBAL VARIABLES (Moved to top to prevent ReferenceError) ===
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      let shapes = [];
      let points = []; // Konstrukƒçn√≠ body (manu√°ln√≠)
      let cachedSnapPoints = []; // Cache pro v≈°echny zaj√≠mav√© body (konce, pr≈Øseƒç√≠ky)
      let selectedItems = []; // Seznam vybran√Ωch objekt≈Ø pro AI (shapes nebo points)

      // === PAN + SELECT HELPER VARS ===
      let panStartPosition = null; // Pozice p≈ôi pointerdown
      let panHasMoved = false; // Zda se my≈° pohnula bƒõhem pan
      let currentCategory = null; // Fix for ReferenceError
      let aiSelectMode = false; // M√≥d v√Ωbƒõru pro AI

      // ===== CONSTRAINT (FIXACE) VARIABLES =====
      let constraintMode = null; // Aktu√°ln√≠ typ fixace (point, distance, radius, polarAngle, horizontal, vertical)
      let constraintSelection = []; // Vybran√© objekty pro fixaci
      let constraintPointValue = { x: 0, z: 0 }; // Hodnota pro fixaci bodu
      let constraintDistanceValue = 0; // Hodnota pro fixaci vzd√°lenosti
      let constraintRadiusValue = 0; // Hodnota pro fixaci radiusu
      let constraintAngleValue = 0; // Hodnota pro fixaci √∫hlu
      let constraintPolarAngleValue = 0; // Hodnota pro fixaci pol√°rn√≠ho √∫hlu

      // ===== ALIGN (ZAROVN√ÅN√ç) VARIABLES =====
      let alignStep = 0; // Krok procesu: 0=ƒçek√°, 1=referenƒçn√≠ bod, 2=target bod, 3=√∫seƒçka, 4=osa
      let alignRefPoint = null; // Referenƒçn√≠ bod na objektu
      let alignTargetPoint = null; // Target bod kam se m√° posunout
      let alignLine = null; // √öseƒçka pro zarovn√°n√≠
      let alignAxis = null; // Osa zarovn√°n√≠ (Z nebo X)

      let mode = "pan";
      let drawing = false;
      let startPt = null;
      let tempShape = null;
      let selectedShape = null;

      let panX = 0;
      let panY = 0;
      let zoom = 2;
      let gridSize = 10;
      let axisMode = "lathe"; // 'lathe' nebo 'carousel'
      let xMeasureMode = "diameter"; // 'diameter' or 'radius'
      let displayDecimals = 2; // Poƒçet desetinn√Ωch m√≠st pro zobrazen√≠ (2 nebo 3)

      let snapToGrid = false;
      let snapToPoints = true;
      let snapDistance = 15;
      let orthoMode = true; // Ortogon√°ln√≠ p≈ôichycen√≠ (vodorovn√©/svisl√©)

      let lastTouch = null;
      let lastDist = 0;
      let cursorPos = { x: 0, y: 0 }; // Aktu√°ln√≠ poloha kurzoru
      let pendingCircleCenter = null;
      let offsetDistance = 5; // V√Ωchoz√≠ vzd√°lenost offsetu v mm

      // ===== ARC TOOL VARIABLES =====
      let arcStep = 0; // 0=start, 1=end, 2=angle
      let arcStart = null; // Poƒç√°teƒçn√≠ bod oblouku
      let arcEnd = null; // Koncov√Ω bod oblouku
      let arcAngle = 0; // √öhel oblouku (v stupn√≠ch)
      let arcCenter = null; // St≈ôed oblouku (vypoƒç√≠tan√Ω)

      // ===== ROTATE TOOL VARIABLES =====
      let rotateStep = 0; // 0=center, 1=awaiting angle
      let rotateCenter = null; // St≈ôed rotace
      let rotateAngle = 0; // √öhel rotace

      // ===== COLOR PICKER VARIABLES =====
      let shapeColors = {}; // Mapa colors {shapeId: '#RRGGBB'}
      let currentColor = "#ffffff"; // Aktu√°ln√≠ vybran√° barva

      // ===== POLAR SNAP VARIABLES =====
      let polarSnapEnabled = false; // Povoleno p≈ôichycov√°n√≠ k √∫hl≈Øm
      let polarSnapInterval = 15; // Interval √∫hlu v stupn√≠ch (3, 6, 9...)
      let polarSnapAngles = []; // Dynamicky generovan√© √∫hly na z√°kladƒõ intervalu
      generatePolarSnapAngles(); // Inicializace na default 15¬∞

      // ===== BOOLEAN OPERATIONS VARIABLES =====
      let booleanSelection = []; // Vybran√© shapes pro booleovsk√© operace
      let booleanMode = null; // 'union', 'intersect', 'difference'

      // Touch cursor promƒõnn√©
      let touchCursorTimeout = null;
      let touchCursorActive = false;
      let touchCursorOffset = 60; // Offset nad prstem v pixelech
      const touchCursorDelay = 300; // Prodleva p≈ôed zobrazen√≠m (ms)

      // AI Performance metrics
      let aiMetrics = {
        totalRequests: 0,
        successfulRequests: 0,
        failedRequests: 0,
        totalTokens: 0,
        avgLatency: 0,
      };

      // Retry helper with exponential backoff
      async function retryWithBackoff(apiCall, maxRetries = 3) {
        for (let attempt = 0; attempt < maxRetries; attempt++) {
          try {
            const startTime = Date.now();
            const result = await apiCall();
            const latency = Date.now() - startTime;

            // Update metrics
            aiMetrics.totalRequests++;
            aiMetrics.successfulRequests++;
            aiMetrics.avgLatency =
              (aiMetrics.avgLatency * (aiMetrics.successfulRequests - 1) +
                latency) /
              aiMetrics.successfulRequests;

            return result;
          } catch (err) {
            const isRateLimit =
              err.message?.includes("429") ||
              err.message?.includes("quota") ||
              err.message?.includes("RESOURCE_EXHAUSTED");

            if (isRateLimit && attempt < maxRetries - 1) {
              const delay = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s
              console.log(`‚è≥ Rate limit hit, retrying in ${delay / 1000}s...`);
              await new Promise((resolve) => setTimeout(resolve, delay));
              continue;
            }

            // Update failed metrics
            aiMetrics.totalRequests++;
            aiMetrics.failedRequests++;
            throw err;
          }
        }
      }

      // === GEOMETRY HELPER FUNCTIONS ===
      function lineIntersection(line1, line2) {
        const x1 = line1.x1,
          y1 = line1.y1,
          x2 = line1.x2,
          y2 = line1.y2;
        const x3 = line2.x1,
          y3 = line2.y1,
          x4 = line2.x2,
          y4 = line2.y2;
        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (Math.abs(denom) < 1e-10) return null;
        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
        return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1) };
      }

      function intersectLineCircle(line, circle) {
        const dx = line.x2 - line.x1,
          dy = line.y2 - line.y1;
        const fx = line.x1 - circle.cx,
          fy = line.y1 - circle.cy;
        const a = dx * dx + dy * dy,
          b = 2 * (fx * dx + fy * dy),
          c = fx * fx + fy * fy - circle.r * circle.r;
        const disc = b * b - 4 * a * c;
        if (disc < 0) return [];
        const pts = [];
        const t1 = (-b + Math.sqrt(disc)) / (2 * a),
          t2 = (-b - Math.sqrt(disc)) / (2 * a);
        [t1, t2].forEach((t) => {
          if (t >= 0 && t <= 1)
            pts.push({ x: line.x1 + t * dx, y: line.y1 + t * dy });
        });
        return pts;
      }

      function intersectCircleCircle(c1, c2) {
        const d = Math.sqrt((c1.cx - c2.cx) ** 2 + (c1.cy - c2.cy) ** 2);
        if (d > c1.r + c2.r || d < Math.abs(c1.r - c2.r) || d === 0) return [];
        const a = (c1.r * c1.r - c2.r * c2.r + d * d) / (2 * d);
        const h = Math.sqrt(c1.r * c1.r - a * a);
        const px = c1.cx + (a / d) * (c2.cx - c1.cx);
        const py = c1.cy + (a / d) * (c2.cy - c1.cy);
        return [
          {
            x: px + (h / d) * (c2.cy - c1.cy),
            y: py - (h / d) * (c2.cx - c1.cx),
          },
          {
            x: px - (h / d) * (c2.cy - c1.cy),
            y: py + (h / d) * (c2.cx - c1.cx),
          },
        ];
      }

      // Alias pro kompatibilitu
      const lineCircleIntersect = intersectLineCircle;

      function lineLineIntersect(line1, line2) {
        return lineIntersection(line1, line2);
      }

      // Expose settings modal functions
      window.openSettings = function () {
        const modal = document.getElementById("settingsModal");
        if (modal) {
          modal.style.display = "flex";
          renderKeyList();
          updateKeyIndicator();
        }
      };

      window.closeSettings = function () {
        const modal = document.getElementById("settingsModal");
        if (modal) modal.style.display = "none";
      };

      function renderKeyList() {
        const list = document.getElementById("keyList");
        const keys = getStoredKeys();

        if (keys.length === 0) {
          list.innerHTML =
            '<div style="padding: 10px; color: #555; font-style: italic; text-align: center;">≈Ω√°dn√© kl√≠ƒçe</div>';
          return;
        }

        list.innerHTML = keys
          .map(
            (k, i) => `
                  <div class="key-item ${k.active ? "active" : ""}" ${
              EMBEDDED_API_KEY && k.key === EMBEDDED_API_KEY
                ? 'style="opacity: 0.7;"'
                : ""
            }>
                    <div>
                      <div class="key-name">${k.name} ${
              k.active ? "‚úì" : ""
            }</div>
                      <div class="key-val">${k.key.substring(
                        0,
                        10
                      )}...${k.key.substring(k.key.length - 5)}</div>
                    </div>
                    <div style="display: flex; gap: 6px;">
                      <button class="key-save" onclick="window.activateApiKey(${i})">Aktivovat</button>
                      <button class="key-delete" onclick="window.deleteApiKey(${i})">Smazat</button>
                    </div>
                  </div>
                `
          )
          .join("");
      }

      function updateKeyIndicator() {
        const indicator = document.getElementById("keyIndicator");
        const apiKey = window.getCurrentApiKey();
        if (indicator) {
          indicator.textContent = apiKey
            ? "‚úÖ API Kl√≠ƒç: Nastaven"
            : "‚ùå API Kl√≠ƒç: ≈Ω√°dn√Ω";
        }
      }

      window.activateApiKey = function (index) {
        const keys = getStoredKeys();
        keys.forEach((k, i) => (k.active = i === index));
        saveStoredKeys(keys);
      };

      window.deleteApiKey = function (index) {
        if (confirm("Opravdu smazat tento kl√≠ƒç?")) {
          const keys = getStoredKeys();
          keys.splice(index, 1);
          if (keys.length > 0 && !keys.some((k) => k.active)) {
            keys[0].active = true;
          }
          saveStoredKeys(keys);
        }
      };

      window.addApiKey = function () {
        const name = document.getElementById("newKeyName").value.trim();
        const key = document.getElementById("newKeyValue").value.trim();

        if (!name || !key) {
          alert("Vypl≈à n√°zev i kl√≠ƒç!");
          return;
        }

        if (!key.startsWith("AIza")) {
          alert('‚ùå Kl√≠ƒç mus√≠ zaƒç√≠nat "AIza"');
          return;
        }

        const keys = getStoredKeys();
        keys.forEach((k) => (k.active = false)); // Deaktivovat ostatn√≠
        keys.push({ name, key, active: true });
        saveStoredKeys(keys);

        document.getElementById("newKeyName").value = "";
        document.getElementById("newKeyValue").value = "";
        alert("‚úÖ Kl√≠ƒç p≈ôid√°n a aktivov√°n!");
      };

      // === API KEY MANAGER START ===
      const API_STORAGE_KEY = "soustruznik_api_keys";

      // DEMO API KEY - rozdƒõlen√Ω na 2 ƒç√°sti (bezpeƒçn√© pro GitHub)
      const API_KEY_PART1 = "AIzaSyCXuMvhO_senLS"; // Prvn√≠ polovina
      const API_KEY_PART2 = "oA_idEuBk_EwnMmIPIhg"; // Druh√° polovina
      const EMBEDDED_API_KEY = API_KEY_PART1 + API_KEY_PART2;

      function getStoredKeys() {
        try {
          return JSON.parse(localStorage.getItem(API_STORAGE_KEY) || "[]");
        } catch (e) {
          return [];
        }
      }

      function saveStoredKeys(keys) {
        localStorage.setItem(API_STORAGE_KEY, JSON.stringify(keys));
        renderKeyList();
        updateKeyIndicator();
      }

      // Exposed for Module Script
      window.getCurrentApiKey = function () {
        const keys = getStoredKeys();
        const active = keys.find((k) => k.active);

        // 1. Pokud m√°me aktivn√≠ kl√≠ƒç v localStorage, pou≈æijeme ho
        if (active) {
          console.log("üîë Using API key from localStorage");
          return active.key;
        }

        // 2. Pokud nem√°me kl√≠ƒçe, pou≈æijeme embedded demo kl√≠ƒç
        if (
          keys.length === 0 &&
          EMBEDDED_API_KEY &&
          EMBEDDED_API_KEY.length > 20
        ) {
          console.log("üîë Using embedded demo API key");
          return EMBEDDED_API_KEY;
        }

        // 3. ≈Ω√°dn√Ω kl√≠ƒç
        console.warn("‚ö†Ô∏è No API key available");
        return null;
        return null;
      };

      // Automatick√© p≈ôepnut√≠ na dal≈°√≠ API kl√≠ƒç p≈ôi quota exceeded
      window.switchToNextApiKey = function () {
        const keys = getStoredKeys();
        if (keys.length <= 1) {
          return false; // Nen√≠ kam p≈ôepnout
        }

        const currentActiveIndex = keys.findIndex((k) => k.active);

        // Naj√≠t dal≈°√≠ kl√≠ƒç (cyklicky)
        const nextIndex = (currentActiveIndex + 1) % keys.length;

        // Deaktivovat v≈°echny
        keys.forEach((k) => (k.active = false));

        // Aktivovat dal≈°√≠
        keys[nextIndex].active = true;

        saveStoredKeys(keys);

        console.log(
          `üîÑ P≈ôepnuto na kl√≠ƒç: ${
            keys[nextIndex].name || `Kl√≠ƒç ${nextIndex + 1}`
          }`
        );

        return true; // √öspƒõ≈°nƒõ p≈ôepnuto
      };

      // Show AI performance metrics
      window.showAIMetrics = function () {
        const successRate =
          aiMetrics.totalRequests > 0
            ? (
                (aiMetrics.successfulRequests / aiMetrics.totalRequests) *
                100
              ).toFixed(1)
            : 0;

        const metricsText = `üìä AI Performance Metrics

        üìà Requests:
          ‚Ä¢ Total: ${aiMetrics.totalRequests}
          ‚Ä¢ Successful: ${aiMetrics.successfulRequests}
          ‚Ä¢ Failed: ${aiMetrics.failedRequests}
          ‚Ä¢ Success Rate: ${successRate}%

        ‚è±Ô∏è Performance:
          ‚Ä¢ Avg Latency: ${aiMetrics.avgLatency.toFixed(0)}ms

        üí° Tips:
          ‚Ä¢ Success rate >90% = Good
          ‚Ä¢ Latency <2000ms = Good
          ‚Ä¢ Use Gemini 2.5 Flash for speed
          ‚Ä¢ Use Gemini 3 Pro for complex tasks`;

        alert(metricsText);
      };

      // === AI LEARNING SYSTEM ===
      // const AI_MEMORY_KEY = "ai_learned_knowledge"; // REMOVED - already defined above

      const defaultMemory = {
        userPreferences: {},
        commonCommands: {},
        corrections: {},
        projectContext: {
          typicalDimensions: [],
          workingArea: null,
          lastUsedTools: [],
        },
        lastUpdated: null,
      };

      function loadAIMemory() {
        try {
          const stored = localStorage.getItem(AI_MEMORY_KEY);
          if (stored) return JSON.parse(stored);
        } catch (e) {
          console.error("Error loading AI memory:", e);
        }
        return JSON.parse(JSON.stringify(defaultMemory));
      }

      function saveAIMemory(memory) {
        try {
          memory.lastUpdated = new Date().toISOString();
          localStorage.setItem(AI_MEMORY_KEY, JSON.stringify(memory));
          console.log("üíæ AI memory saved");
          return true;
        } catch (e) {
          console.error("Error saving AI memory:", e);
          return false;
        }
      }

      window.addAIKnowledge = function (category, key, value) {
        const memory = loadAIMemory();
        if (!memory[category]) memory[category] = {};
        memory[category][key] = value;
        saveAIMemory(memory);
        console.log(
          `üìö AI learned: ${category}.${key} = ${JSON.stringify(value)}`
        );
      };

      window.recordCommand = function (command) {
        const memory = loadAIMemory();
        if (!memory.commonCommands[command]) {
          memory.commonCommands[command] = { count: 0, lastUsed: null };
        }
        memory.commonCommands[command].count++;
        memory.commonCommands[command].lastUsed = new Date().toISOString();
        saveAIMemory(memory);
      };

      window.recordCorrection = function (originalAI, userCorrection) {
        const memory = loadAIMemory();
        const key = `${Date.now()}`;
        memory.corrections[key] = {
          aiResponse: originalAI,
          userCorrection: userCorrection,
          timestamp: new Date().toISOString(),
        };
        // Keep only last 20
        const corrections = Object.entries(memory.corrections)
          .sort((a, b) => b[1].timestamp.localeCompare(a[1].timestamp))
          .slice(0, 20);
        memory.corrections = Object.fromEntries(corrections);
        saveAIMemory(memory);
        console.log("‚úèÔ∏è AI correction recorded");
      };

      window.getAIMemoryContext = function () {
        const memory = loadAIMemory();

        // Get successful patterns
        const successPatterns = memory.successfulPatterns || [];
        const patternSummary =
          successPatterns.length > 0
            ? successPatterns.slice(-10).map((p) => ({
                input: p.input,
                type: p.outputType,
                count: p.shapeCount,
              }))
            : [];

        return {
          preferences: memory.userPreferences,
          topCommands: Object.entries(memory.commonCommands)
            .sort((a, b) => b[1].count - a[1].count)
            .slice(0, 5)
            .map(([cmd, data]) => ({ command: cmd, count: data.count })),
          recentCorrections: Object.values(memory.corrections).slice(-3),
          successfulPatterns: patternSummary,
        };
      };

      window.showAIMemory = function () {
        const memory = loadAIMemory();
        const stats = {
          commands: Object.keys(memory.commonCommands).length,
          corrections: Object.keys(memory.corrections).length,
          preferences: Object.keys(memory.userPreferences).length,
          patterns: memory.successfulPatterns
            ? memory.successfulPatterns.length
            : 0,
          size: (new Blob([JSON.stringify(memory)]).size / 1024).toFixed(2),
        };

        const topCommands =
          Object.entries(memory.commonCommands)
            .sort((a, b) => b[1].count - a[1].count)
            .slice(0, 3)
            .map(([cmd, data]) => `    ‚Ä¢ "${cmd}" (${data.count}√ó)`)
            .join("\n") || "    ≈Ω√°dn√©";

        const text = `üß† AI Pamƒõ≈• - Co se nauƒçila

        üìä Statistiky:
          ‚Ä¢ P≈ô√≠kaz≈Ø: ${stats.commands}
          ‚Ä¢ Oprav: ${stats.corrections}
          ‚Ä¢ Preferenc√≠: ${stats.preferences}
          ‚Ä¢ √öspƒõ≈°n√Ωch vzor≈Ø: ${stats.patterns}
          ‚Ä¢ Velikost: ${stats.size} KB
          ‚Ä¢ Posledn√≠ update: ${
            memory.lastUpdated
              ? new Date(memory.lastUpdated).toLocaleString("cs-CZ")
              : "Nikdy"
          }

        üîù Nejpou≈æ√≠vanƒõj≈°√≠ p≈ô√≠kazy:
        ${topCommands}

        üéì Preference: Kliknƒõte na ikonu üéì pro nastaven√≠

        üíæ Spr√°va dat:
          [Console Commands]
          ‚Ä¢ exportAIMemory() - Export do souboru
          ‚Ä¢ clearAIMemory() - Vymazat v≈°e
          ‚Ä¢ addAIKnowledge('userPreferences', 'key', 'value')

        üí° Tip: AI se uƒç√≠ automaticky z ka≈æd√©ho √∫spƒõ≈°n√©ho p≈ô√≠kazu a z va≈°ich oprav!`;

        alert(text);
      };

      window.clearAIMemory = function () {
        if (confirm("Opravdu vymazat ve≈°kerou nauƒçenou pamƒõ≈• AI?")) {
          localStorage.removeItem(AI_MEMORY_KEY);
          console.log("üóëÔ∏è AI memory cleared");
          alert("‚úÖ AI pamƒõ≈• byla vymaz√°na.");
        }
      };

      window.exportAIMemory = function () {
        const memory = loadAIMemory();
        const blob = new Blob([JSON.stringify(memory, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `ai_memory_${new Date().toISOString().split("T")[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
        console.log("üíæ AI memory exported");
        alert("‚úÖ AI pamƒõ≈• exportov√°na!");
      };

      window.openSettings = function () {
        document.getElementById("settingsModal").style.display = "flex";
        renderKeyList();
      };

      window.closeSettings = function () {
        document.getElementById("settingsModal").style.display = "none";
      };

      // === AI PREFERENCES MANAGEMENT ===
      window.openAIPreferences = function () {
        document.getElementById("aiPreferencesModal").style.display = "flex";
        renderPreferencesList();
      };

      window.closeAIPreferences = function () {
        document.getElementById("aiPreferencesModal").style.display = "none";
      };

      window.renderPreferencesList = function () {
        const memory = loadAIMemory();
        const list = document.getElementById("preferencesList");

        if (
          !memory.userPreferences ||
          Object.keys(memory.userPreferences).length === 0
        ) {
          list.innerHTML =
            '<div style="padding: 10px; color: #555; font-style: italic; text-align: center;">Zat√≠m ≈æ√°dn√© preference</div>';
          return;
        }

        list.innerHTML = Object.entries(memory.userPreferences)
          .map(
            ([key, value]) => `
                            <div style="padding: 8px; background: #111; border-radius: 4px; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong style="color: #6ab0ff;">${key}:</strong>
                                    <span style="color: #ccc;">${value}</span>
                                </div>
                                <button onclick="removeAIPreference('${key}')" style="padding: 4px 8px; background: #c83a3a; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 10px;">
                                    üóëÔ∏è Smazat
                                </button>
                            </div>
                        `
          )
          .join("");
      };

      window.addAIPreference = function () {
        const keyInput = document.getElementById("newPrefKey");
        const valueInput = document.getElementById("newPrefValue");
        const key = keyInput.value.trim();
        const value = valueInput.value.trim();

        if (!key || !value) {
          alert("‚ö†Ô∏è Vypl≈àte obƒõ pole!");
          return;
        }

        window.addAIKnowledge("userPreferences", key, value);

        // Clear inputs
        keyInput.value = "";
        valueInput.value = "";

        // Refresh list
        renderPreferencesList();

        alert(
          "‚úÖ Preference p≈ôid√°na!\n\nüéì AI se nauƒçila tuto preferenci a bude ji respektovat."
        );
      };

      window.removeAIPreference = function (key) {
        if (!confirm(`Opravdu smazat preferenci "${key}"?`)) return;

        const memory = loadAIMemory();
        delete memory.userPreferences[key];
        saveAIMemory(memory);

        renderPreferencesList();
        alert("‚úÖ Preference smaz√°na.");
      };

      // Click outside modal to close
      document
        .getElementById("aiPreferencesModal")
        .addEventListener("click", (e) => {
          if (e.target.id === "aiPreferencesModal") closeAIPreferences();
        });

      // QUICK INPUT LOGIC
      window.openQuickInput = function () {
        const modal = document.getElementById("quickInputModal");
        const mainInput = document.getElementById("aiPrompt");
        const display = document.getElementById("quickInputDisplay");

        // Sync current prompt to display
        if (display && mainInput) {
          display.value = mainInput.value;
        }

        modal.style.display = "flex";
      };

      window.closeQuickInput = function () {
        document.getElementById("quickInputModal").style.display = "none";
        // Return focus to input
        const input = document.getElementById("aiPrompt");
        if (input) input.focus();
      };

      window.confirmQuickInput = function () {
        const mainInput = document.getElementById("aiPrompt");
        const display = document.getElementById("quickInputDisplay");

        if (mainInput && display) {
          mainInput.value = display.value;
        }
        window.closeQuickInput();
      };

      window.insertToken = function (text) {
        const input = document.getElementById("quickInputDisplay");
        if (!input) return;

        // Insert at cursor position
        const start = input.selectionStart;
        const end = input.selectionEnd;
        const val = input.value;

        input.value = val.substring(0, start) + text + val.substring(end);

        // Move cursor after insertion
        input.selectionStart = input.selectionEnd = start + text.length;
        input.focus();
      };

      window.backspaceToken = function () {
        const input = document.getElementById("quickInputDisplay");
        if (!input) return;

        const start = input.selectionStart;
        const end = input.selectionEnd;
        const val = input.value;

        if (start === end && start > 0) {
          // Delete previous char
          input.value = val.substring(0, start - 1) + val.substring(end);
          input.selectionStart = input.selectionEnd = start - 1;
        } else if (start !== end) {
          // Delete selection
          input.value = val.substring(0, start) + val.substring(end);
          input.selectionStart = input.selectionEnd = start;
        }
        input.focus();
      };

      window.showQuickInputHelp = function () {
        const helpModal = document.getElementById("quickInputHelpModal");
        if (helpModal) helpModal.style.display = "flex";
      };

      window.closeQuickInputHelp = function () {
        const helpModal = document.getElementById("quickInputHelpModal");
        if (helpModal) helpModal.style.display = "none";
      };

      // --- CONTROLLER MODAL LOGIC ---
      let controllerInputBuffer = "";
      let controllerMode = "G90"; // 'G90' = absolutn√≠, 'G91' = p≈ô√≠r≈Østkov√©
      let pendingDirection = null; // Smƒõr ƒçekaj√≠c√≠ na potvrzen√≠

      window.showControllerModal = function () {
        const modal = document.getElementById("controllerModal");
        if (modal) modal.style.display = "flex";
        updateControllerLastPoint();
        updateControllerInputDisplay();
      };

      window.closeControllerModal = function () {
        const modal = document.getElementById("controllerModal");
        if (modal) modal.style.display = "none";
        controllerInputBuffer = "";
        pendingDirection = null;
        updateControllerInputDisplay();
      };

      function setControllerMode(mode) {
        controllerMode = mode;

        // Update button styles
        const btnG90 = document.getElementById("btnG90");
        const btnG91 = document.getElementById("btnG91");

        if (mode === "G90") {
          btnG90.style.background = "#3a7bc8";
          btnG90.style.borderColor = "#5a9be8";
          btnG90.style.color = "white";
          btnG91.style.background = "#2a2a2a";
          btnG91.style.borderColor = "#444";
          btnG91.style.color = "#888";
        } else {
          btnG91.style.background = "#3a7bc8";
          btnG91.style.borderColor = "#5a9be8";
          btnG91.style.color = "white";
          btnG90.style.background = "#2a2a2a";
          btnG90.style.borderColor = "#444";
          btnG90.style.color = "#888";
        }

        // Update display
        const modeDisplay = document.getElementById("controllerModeDisplay");
        if (modeDisplay) {
          modeDisplay.textContent =
            mode === "G90" ? "G90 (Absolutn√≠)" : "G91 (P≈ô√≠r≈Østkov√©)";
        }
      }

      function updateControllerLastPoint() {
        // Naj√≠t posledn√≠ bod
        let lastPoint = null;

        if (shapes.length > 0) {
          const lastShape = shapes[shapes.length - 1];
          if (lastShape.type === "line") {
            lastPoint = { x: lastShape.x2, y: lastShape.y2 };
          } else if (lastShape.type === "circle") {
            lastPoint = { x: lastShape.cx, y: lastShape.cy };
          }
        }

        if (!lastPoint && points.length > 0) {
          const p = points[points.length - 1];
          lastPoint = { x: p.x, y: p.y };
        }

        const inlineDisplay = document.getElementById(
          "controllerLastPointInline"
        );
        if (inlineDisplay) {
          if (lastPoint) {
            const displayY =
              xMeasureMode === "diameter" ? lastPoint.y * 2 : lastPoint.y;
            inlineDisplay.textContent = `Z${lastPoint.x.toFixed(
              displayDecimals
            )} X${displayY.toFixed(displayDecimals)}`;
          } else {
            inlineDisplay.textContent = "‚Äî";
          }
        }
      }

      function updateControllerInputDisplay() {
        const input = document.getElementById("controllerInput");
        if (input) {
          input.value = controllerInputBuffer;
        }
      }

      function insertControllerToken(text) {
        controllerInputBuffer += text;
        updateControllerInputDisplay();
      }

      function backspaceControllerToken() {
        if (controllerInputBuffer.length > 0) {
          controllerInputBuffer = controllerInputBuffer.slice(0, -1);
          updateControllerInputDisplay();
        }
      }

      function confirmControllerInput() {
        const input = controllerInputBuffer.trim();

        if (!input) {
          alert("Zadej p≈ô√≠kaz (nap≈ô. G0 X50 Z100 nebo G1 X100)");
          return;
        }

        // Zkusit zpracovat jako G-k√≥d p≈ô√≠kaz
        const parsed = parseGCode(input, controllerMode);

        if (parsed) {
          // Reset
          controllerInputBuffer = "";
          pendingDirection = null;
          updateControllerInputDisplay();
          updateControllerLastPoint();
        } else {
          // Pokud nen√≠ G-k√≥d a m√°me pendingDirection, pou≈æ√≠t smƒõrov√Ω re≈æim
          if (pendingDirection) {
            executeDirectionDraw(pendingDirection, input);
            controllerInputBuffer = "";
            pendingDirection = null;
            updateControllerInputDisplay();
          } else {
            alert(
              "Neplatn√Ω p≈ô√≠kaz! Pou≈æij G-k√≥d (G0, G1, G2, G3) nebo klikni na ≈°ipku a zadej parametry."
            );
          }
        }
      }

      // Parsov√°n√≠ G-k√≥du (podobn√© jako v AI)
      function parseGCode(input, mode) {
        // NOVƒö: Odstranit v≈°echny mezern√≠ky p≈ôed zpracov√°n√≠m
        // X80 Z120 R80 ‚Üí X80Z120R80
        input = input.replace(/\s+/g, "").toUpperCase().trim();

        // Validace: Zkontrolovat zda obsahuje alespo≈à nƒõjak√Ω parametr
        if (!input || input.length < 2) {
          alert(
            "‚ùå P≈ô√≠li≈° kr√°tk√Ω p≈ô√≠kaz!\n\nZadej nap≈ô.: G0X50Z100 nebo G1X100"
          );
          return false;
        }

        // Naj√≠t posledn√≠ bod
        let lastPoint = null;
        if (shapes.length > 0) {
          const lastShape = shapes[shapes.length - 1];
          if (lastShape.type === "line") {
            lastPoint = { x: lastShape.x2, y: lastShape.y2 };
          } else if (lastShape.type === "circle") {
            lastPoint = { x: lastShape.cx, y: lastShape.cy };
          }
        }
        if (!lastPoint && points.length > 0) {
          const p = points[points.length - 1];
          lastPoint = { x: p.x, y: p.y };
        }
        if (!lastPoint) {
          lastPoint = { x: 0, y: 0 }; // Default
        }

        // Rozdƒõlit na p≈ô√≠kazy (st≈ôedn√≠k)
        const commands = input
          .split(";")
          .map((c) => c.trim())
          .filter((c) => c);

        let commandExecuted = false;

        for (const cmd of commands) {
          // Detekce G-k√≥du
          const gMatch = cmd.match(/^G(\d+)/);
          if (!gMatch) {
            // Pokud nen√≠ G-k√≥d, zkusit pouze sou≈ôadnice (nap≈ô. X50Z100)
            // To znamen√° pou≈æ√≠t G1 (p≈ô√≠mku) implicitnƒõ
            if (cmd.match(/[XZ]/)) {
              // Rekurzivnƒõ zavolat s G1
              return parseGCode("G1" + cmd, mode);
            }
            continue;
          }

          const gCode = parseInt(gMatch[1]);

          // Parse parametr≈Ø (vƒçetnƒõ CR - radius men≈°√≠ho √∫hlu)
          const xMatch = cmd.match(/X(-?\d+\.?\d*)/);
          const zMatch = cmd.match(/Z(-?\d+\.?\d*)/);
          const rMatch = cmd.match(/(?<![C])R(-?\d+\.?\d*)/); // R ale ne CR
          const crMatch = cmd.match(/CR(-?\d+\.?\d*)/); // CR - radius men≈°√≠ho √∫hlu
          const dMatch = cmd.match(/D(-?\d+\.?\d*)/);
          const lMatch = cmd.match(/L(-?\d+\.?\d*)/);
          const aMatch = cmd.match(/A(-?\d+\.?\d*)/);
          const rpMatch = cmd.match(/RP(-?\d+\.?\d*)/);
          const apMatch = cmd.match(/AP(-?\d+\.?\d*)/);
          const iMatch = cmd.match(/I(-?\d+\.?\d*)/);
          const jMatch = cmd.match(/J(-?\d+\.?\d*)/);

          if (gCode === 0) {
            // G0 - Vytvo≈ôen√≠ bodu
            let x = lastPoint.x;
            let y = lastPoint.y;

            if (mode === "G91") {
              x += zMatch ? parseFloat(zMatch[1]) : 0;
              y += xMatch ? parseFloat(xMatch[1]) : 0;
            } else {
              x = zMatch ? parseFloat(zMatch[1]) : x;
              y = xMatch ? parseFloat(xMatch[1]) : y;
            }

            points.push({ x, y });
            lastPoint = { x, y };
            updateSnapPoints();
            draw();
          } else if (gCode === 1) {
            // G1 - P≈ô√≠mka
            let x = lastPoint.x;
            let y = lastPoint.y;

            // Pol√°rn√≠ sou≈ôadnice
            const length = lMatch
              ? parseFloat(lMatch[1])
              : rpMatch
              ? parseFloat(rpMatch[1])
              : null;
            const angle = apMatch
              ? parseFloat(apMatch[1])
              : aMatch
              ? parseFloat(aMatch[1])
              : null;

            if (length !== null && angle !== null) {
              const rad = (angle * Math.PI) / 180;
              x = lastPoint.x + length * Math.cos(rad);
              y = lastPoint.y + length * Math.sin(rad);
            } else {
              if (mode === "G91") {
                x += zMatch ? parseFloat(zMatch[1]) : 0;
                y += xMatch ? parseFloat(xMatch[1]) : 0;
              } else {
                x = zMatch ? parseFloat(zMatch[1]) : x;
                y = xMatch ? parseFloat(xMatch[1]) : y;
              }
            }

            shapes.push({
              type: "line",
              x1: lastPoint.x,
              y1: lastPoint.y,
              x2: x,
              y2: y,
            });

            lastPoint = { x, y };

            // === AUTO-SELECT ENDPOINT ===
            autoSelectEndpoint(x, y);

            updateSnapPoints();
            draw();
          } else if (gCode === 2 || gCode === 3) {
            // G2/G3 - Oblouky (zjednodu≈°en√° verze - kru≈ænice)
            // R = bƒõ≈æn√Ω polomƒõr, CR = polomƒõr s men≈°√≠m √∫hlem rozev≈ôen√≠
            const r = crMatch
              ? parseFloat(crMatch[1])
              : rMatch
              ? parseFloat(rMatch[1])
              : dMatch
              ? parseFloat(dMatch[1]) / 2
              : null;

            if (!r) {
              alert(
                "‚ùå Chyb√≠ polomƒõr!\n\nZadej R nebo CR, nap≈ô.: G2R50 nebo G2CR30"
              );
              continue;
            }

            if (r) {
              shapes.push({
                type: "circle",
                cx: lastPoint.x,
                cy: lastPoint.y,
                r: r,
              });

              commandExecuted = true;
              updateSnapPoints();
              draw();
            }
          }

          if (gCode === 0 || gCode === 1) {
            commandExecuted = true;
          }
        }

        // Validace: Pokud nebyl proveden ≈æ√°dn√Ω p≈ô√≠kaz
        if (!commandExecuted) {
          alert(
            "‚ùå Neplatn√Ω p≈ô√≠kaz!\n\nPou≈æij:\n‚Ä¢ G0 X50 Z100 (bod)\n‚Ä¢ G1 X100 Z200 (ƒç√°ra)\n‚Ä¢ G2 R50 (kru≈ænice)\n\nNebo otev≈ôi ‚ùì Help"
          );
          return false;
        }

        return commands.length > 0;
      }

      window.showDirectionModal = function () {
        const modal = document.getElementById("directionModal");
        if (modal) modal.style.display = "flex";
      };

      window.closeDirectionModal = function () {
        const modal = document.getElementById("directionModal");
        if (modal) modal.style.display = "none";
      };

      // === HELP MODAL FUNCTIONS ===
      window.showControllerHelp = function () {
        const modal = document.getElementById("controllerHelpModal");
        if (modal) modal.style.display = "flex";
      };

      window.closeControllerHelp = function () {
        const modal = document.getElementById("controllerHelpModal");
        if (modal) modal.style.display = "none";
      };

      // Zav≈ô√≠t Help kliknut√≠m mimo
      document
        .getElementById("controllerHelpModal")
        ?.addEventListener("click", (e) => {
          if (e.target.id === "controllerHelpModal")
            window.closeControllerHelp();
        });

      window.insertDirectionCommand = function (direction) {
        // Smƒõrov√© √∫hly
        const directionAngles = {
          E: 0, // ‚Üí
          NE: 45, // ‚Üó
          N: 90, // ‚Üë
          NW: 135, // ‚Üñ
          W: 180, // ‚Üê
          SW: 225, // ‚Üô
          S: 270, // ‚Üì
          SE: 315, // ‚Üò
        };

        const angle = directionAngles[direction];

        // Vlo≈æit p≈ô√≠kaz podle aktu√°ln√≠ho re≈æimu
        if (controllerMode === "G91") {
          // P≈ô√≠r≈Østkov√Ω re≈æim: G1 G91 AP90 L
          controllerInputBuffer = `G1 G91 AP${angle} L`;
        } else {
          // Absolutn√≠ re≈æim: G1 AP90 L (m√©nƒõ ƒçasto pou≈æ√≠van√©, ale OK)
          controllerInputBuffer = `G1 AP${angle} L`;
        }

        updateControllerInputDisplay();
        window.closeDirectionModal();

        // Focus na input
        const input = document.getElementById("controllerInput");
        if (input) input.focus();
      };

      function drawDirection(direction) {
        // Naj√≠t startovn√≠ bod
        let startPoint = null;

        if (shapes.length > 0) {
          const lastShape = shapes[shapes.length - 1];
          if (lastShape.type === "line") {
            startPoint = { x: lastShape.x2, y: lastShape.y2 };
          } else if (lastShape.type === "circle") {
            startPoint = { x: lastShape.cx, y: lastShape.cy };
          }
        }

        if (!startPoint && points.length > 0) {
          const p = points[points.length - 1];
          startPoint = { x: p.x, y: p.y };
        }

        if (!startPoint) {
          alert(
            "Nen√≠ definov√°n ≈æ√°dn√Ω bod! Nejprve vytvo≈ô bod pomoc√≠ G0 nebo nakresli prvn√≠ √∫seƒçku."
          );
          return;
        }

        // Ulo≈æit ƒçekaj√≠c√≠ smƒõr
        pendingDirection = direction;

        // Focus na input
        const input = document.getElementById("controllerInput");
        if (input) input.focus();
      }

      function executeDirectionDraw(direction, input) {
        // Naj√≠t startovn√≠ bod
        let startPoint = null;

        if (shapes.length > 0) {
          const lastShape = shapes[shapes.length - 1];
          if (lastShape.type === "line") {
            startPoint = { x: lastShape.x2, y: lastShape.y2 };
          } else if (lastShape.type === "circle") {
            startPoint = { x: lastShape.cx, y: lastShape.cy };
          }
        }

        if (!startPoint && points.length > 0) {
          const p = points[points.length - 1];
          startPoint = { x: p.x, y: p.y };
        }

        if (!startPoint) {
          alert("Nen√≠ definov√°n ≈æ√°dn√Ω bod!");
          return;
        }

        // Parsovat vstup
        const endPoint = parseControllerInput(
          input,
          startPoint,
          direction,
          controllerMode
        );

        if (endPoint) {
          // Vytvo≈ôit √∫seƒçku
          shapes.push({
            type: "line",
            x1: startPoint.x,
            y1: startPoint.y,
            x2: endPoint.x,
            y2: endPoint.y,
          });

          updateSnapPoints();
          draw();
          updateControllerLastPoint();
        }
      }

      function parseControllerInput(input, startPoint, direction, mode) {
        input = input.trim().toUpperCase();

        // Smƒõrov√© √∫hly pro jednotliv√© smƒõry
        const directionAngles = {
          E: 0, // ‚Üí
          NE: 45, // ‚Üó
          N: 90, // ‚Üë
          NW: 135, // ‚Üñ
          W: 180, // ‚Üê
          SW: 225, // ‚Üô
          S: 270, // ‚Üì
          SE: 315, // ‚Üò
        };

        // Pokud je to jen ƒç√≠slo - d√©lka ve smƒõru
        if (/^-?\d+\.?\d*$/.test(input)) {
          const length = parseFloat(input);
          const angle = directionAngles[direction];
          const rad = (angle * Math.PI) / 180;

          return {
            x: startPoint.x + length * Math.cos(rad),
            y: startPoint.y + length * Math.sin(rad),
          };
        }

        // Parsovat X a Z sou≈ôadnice
        const xMatch = input.match(/X(-?\d+\.?\d*)/);
        const zMatch = input.match(/Z(-?\d+\.?\d*)/);

        if (xMatch || zMatch) {
          if (mode === "G91") {
            // P≈ô√≠r≈Østkov√© sou≈ôadnice
            return {
              x: startPoint.x + (zMatch ? parseFloat(zMatch[1]) : 0),
              y: startPoint.y + (xMatch ? parseFloat(xMatch[1]) : 0),
            };
          } else {
            // Absolutn√≠ sou≈ôadnice (G90)
            return {
              x: zMatch ? parseFloat(zMatch[1]) : startPoint.x,
              y: xMatch ? parseFloat(xMatch[1]) : startPoint.y,
            };
          }
        }

        // Parsovat L/RP (d√©lka) a A/AP (√∫hel) - POL√ÅRN√ç SOU≈òADNICE
        const lMatch = input.match(/L(-?\d+\.?\d*)/);
        const rpMatch = input.match(/RP(-?\d+\.?\d*)/);
        const aMatch = input.match(/A(-?\d+\.?\d*)/);
        const apMatch = input.match(/AP(-?\d+\.?\d*)/);

        const length = lMatch
          ? parseFloat(lMatch[1])
          : rpMatch
          ? parseFloat(rpMatch[1])
          : null;
        const angle = apMatch
          ? parseFloat(apMatch[1])
          : aMatch
          ? parseFloat(aMatch[1])
          : null;

        if (length !== null) {
          const finalAngle =
            angle !== null ? angle : directionAngles[direction];
          const rad = (finalAngle * Math.PI) / 180;

          return {
            x: startPoint.x + length * Math.cos(rad),
            y: startPoint.y + length * Math.sin(rad),
          };
        }

        alert(
          "Neplatn√Ω vstup! Pou≈æij:\n‚Ä¢ D√©lku: 50\n‚Ä¢ Sou≈ôadnice: X100 Z50\n‚Ä¢ Pol√°rn√≠: L50 AP45 nebo RP50 AP45"
        );
        return null;
      }

      // --- VOICE INPUT LOGIC ---
      let recognition = null;
      let isRecording = false;

      if ("webkitSpeechRecognition" in window) {
        // @ts-ignore
        recognition = new webkitSpeechRecognition();
        recognition.continuous = false;
        recognition.interimResults = false;
        recognition.lang = "cs-CZ";

        recognition.onstart = function () {
          isRecording = true;
          const btn = document.getElementById("btnVoice");
          if (btn) btn.classList.add("recording-pulse");
        };

        recognition.onend = function () {
          isRecording = false;
          const btn = document.getElementById("btnVoice");
          if (btn) btn.classList.remove("recording-pulse");
        };

        recognition.onresult = function (event) {
          const text = event.results[0][0].transcript;
          const input = document.getElementById("aiPrompt");
          if (input) {
            // Append text with space
            input.value += (input.value.length > 0 ? " " : "") + text;
            input.focus();
          }
        };

        recognition.onerror = function (event) {
          console.error("Speech error", event.error);
          isRecording = false;
          const btn = document.getElementById("btnVoice");
          if (btn) btn.classList.remove("recording-pulse");

          // Informovat u≈æivatele o probl√©mu s povolen√≠m
          if (
            event.error === "not-allowed" ||
            event.error === "permission-denied"
          ) {
            alert(
              "‚ö†Ô∏è P≈ô√≠stup k mikrofonu byl zam√≠tnut.\n\nPovolte p≈ô√≠stup k mikrofonu v nastaven√≠ prohl√≠≈æeƒçe a zkuste to znovu."
            );
          } else if (event.error === "no-speech") {
            // Tich√Ω error - u≈æivatel nemluvil
          } else {
            alert("Chyba hlasov√©ho rozpozn√°v√°n√≠: " + event.error);
          }
        };
      }

      window.toggleVoice = function () {
        if (!recognition) {
          alert("V√°≈° prohl√≠≈æeƒç nepodporuje hlasov√© zad√°v√°n√≠.");
          return;
        }

        if (isRecording) {
          recognition.stop();
        } else {
          recognition.start();
        }
      };

      // Zav≈ôen√≠ mod√°lu kliknut√≠m mimo
      document
        .getElementById("settingsModal")
        .addEventListener("click", (e) => {
          if (e.target.id === "settingsModal") window.closeSettings();
        });

      document
        .getElementById("quickInputModal")
        .addEventListener("click", (e) => {
          if (e.target.id === "quickInputModal") window.closeQuickInput();
        });

      window.addApiKey = function () {
        const nameInput = document.getElementById("newKeyName");
        const keyInput = document.getElementById("newKeyValue");
        const name = nameInput.value.trim() || "Nov√Ω kl√≠ƒç";
        const key = keyInput.value.trim();

        if (!key) {
          alert("Zadejte pros√≠m API kl√≠ƒç.");
          return;
        }

        const keys = getStoredKeys();

        // Deaktivovat ostatn√≠
        keys.forEach((k) => (k.active = false));

        keys.push({
          name: name,
          key: key,
          active: true,
          created: Date.now(),
        });

        saveStoredKeys(keys);
        nameInput.value = "";
        keyInput.value = "";
      };

      window.saveDefaultKey = function () {
        // Usually not used in this environment unless user clicks it
        alert("Funkce nen√≠ dostupn√°.");
      };

      window.deleteKey = function (index) {
        if (!confirm("Opravdu smazat tento kl√≠ƒç?")) return;
        const keys = getStoredKeys();
        keys.splice(index, 1);

        // Pokud jsme smazali aktivn√≠ a m√°me jin√©, aktivuj prvn√≠
        if (keys.length > 0 && !keys.some((k) => k.active)) {
          keys[0].active = true;
        }

        saveStoredKeys(keys);
      };

      window.selectKey = function (index) {
        const keys = getStoredKeys();
        keys.forEach((k, i) => (k.active = i === index));
        saveStoredKeys(keys);
      };

      function renderKeyList() {
        const list = document.getElementById("keyList");
        const keys = getStoredKeys();

        list.innerHTML = "";

        // Pokud nem√°me ≈æ√°dn√© ulo≈æen√© kl√≠ƒçe, zobraz√≠me mo≈ænost ulo≈æit defaultn√≠
        if (keys.length === 0) {
          const div = document.createElement("div");
          div.className = "key-item demo-active"; // Speci√°ln√≠ styl pro demo

          div.innerHTML = `
                            <div>
                                <div class="key-name">Demo Kl√≠ƒç <span style="color:#a78bfa; font-size:10px; margin-left:5px;">(Syst√©mov√Ω)</span></div>
                                <div class="key-val">Automaticky pou≈æit</div>
                            </div>
                        `;
          list.appendChild(div);
          return;
        }

        // Renderov√°n√≠ ulo≈æen√Ωch kl√≠ƒç≈Ø
        keys.forEach((k, i) => {
          const div = document.createElement("div");
          div.className = `key-item ${k.active ? "active" : ""}`;
          div.onclick = (e) => {
            // Prevence spu≈°tƒõn√≠ p≈ôi kliku na delete button
            if (e.target.tagName !== "BUTTON") window.selectKey(i);
          };

          // Maskov√°n√≠ kl√≠ƒçe (uk√°zat jen zaƒç√°tek a konec)
          const maskedKey =
            k.key.length > 10
              ? k.key.substring(0, 6) +
                "..." +
                k.key.substring(k.key.length - 4)
              : "***";

          div.innerHTML = `
                            <div>
                                <div class="key-name">${k.name} ${
            k.active
              ? '<span style="color:#4ade80; font-size:10px; margin-left:5px;">(Aktivn√≠)</span>'
              : ""
          }</div>
                                <div class="key-val">${maskedKey}</div>
                            </div>
                            <button class="key-delete" onclick="window.deleteKey(${i})">Smazat</button>
                        `;
          list.appendChild(div);
        });
      }

      function updateKeyIndicator() {
        const keys = getStoredKeys();
        const active = keys.find((k) => k.active);
        const el = document.getElementById("keyIndicator");

        if (el) {
          if (active) {
            el.innerHTML = `Kl√≠ƒç: <span style="color:#4ade80">${active.name}</span>`;
          } else if (keys.length === 0) {
            // Pou≈æ√≠v√°me default
            el.innerHTML = `Kl√≠ƒç: <span style="color:#a78bfa">Demo (P≈ôednastaven√Ω)</span>`;
          } else {
            el.innerHTML = `Kl√≠ƒç: <span style="color:#ef4444">≈Ω√°dn√Ω</span>`;
          }
        }
      }

      // === API KEY MANAGER END ===

      // --- LOGIKA PRO MOD√ÅLN√ç OKNO KRU≈ΩNICE ---

      window.openCircleModal = function (center, initialRadius) {
        pendingCircleCenter = center;
        // Pokud je zapnut√Ω pr≈Ømƒõr, initialRadius je vizu√°lnƒõ polomƒõr, ale u≈æivatel chce vidƒõt pr≈Ømƒõr
        // Pokud je pr≈Ømƒõrov√Ω re≈æim, zobraz√≠me pr≈Ømƒõr jako default (2*r)
        // Ale pozor, kru≈ænice se zad√°v√° polomƒõrem.
        // V dialogu m√°me input R a input D.
        document.getElementById("circleInputR").value =
          initialRadius.toFixed(2);
        document.getElementById("circleInputD").value = (
          initialRadius * 2
        ).toFixed(2);
        document.getElementById("circleModal").style.display = "flex";
        setTimeout(() => document.getElementById("circleInputR").focus(), 100);
      };

      window.closeCircleModal = function () {
        document.getElementById("circleModal").style.display = "none";
        pendingCircleCenter = null;
        tempShape = null; // Zru≈°it preview
        draw();
      };

      window.confirmCircle = function () {
        const r = parseFloat(document.getElementById("circleInputR").value);
        if (pendingCircleCenter && !isNaN(r) && r > 0) {
          shapes.push({
            type: "circle",
            cx: pendingCircleCenter.x,
            cy: pendingCircleCenter.y,
            r: r,
          });
          saveState(); // Ulo≈æit pro undo
          updateSnapPoints();
        }
        closeCircleModal();
      };

      window.updateCircleInputs = function (source) {
        const inputR = document.getElementById("circleInputR");
        const inputD = document.getElementById("circleInputD");

        if (source === "R") {
          const r = parseFloat(inputR.value);
          if (!isNaN(r)) inputD.value = (r * 2).toFixed(2);
        } else {
          const d = parseFloat(inputD.value);
          if (!isNaN(d)) inputR.value = (d / 2).toFixed(2);
        }
      };

      // Zav≈ôen√≠ mod√°lu kliknut√≠m mimo
      document.getElementById("circleModal").addEventListener("click", (e) => {
        if (e.target.id === "circleModal") window.closeCircleModal();
      });

      // ===== FUNKCE PRO FIXACI (ARETOV√ÅN√ç) =====
      window.showConstraintModal = function () {
        // Otev≈ôi mod√°ln√≠ okno s typy fixace bez kontroly v√Ωbƒõru
        document.getElementById("constraintModal").style.display = "flex";
        console.log(
          "üîí Fixace modal otev≈ôen - vyber typ fixace a pak klikej na objekty"
        );
      };

      window.closeConstraintModal = function () {
        document.getElementById("constraintModal").style.display = "none";
      };

      // Glob√°ln√≠ n√°zvy typ≈Ø fixac√≠
      const constraintNames = {
        point: "üìç Bod",
        distance: "üìè Vzd√°lenost",
        radius: "‚≠ï Radius",
        angle: "‚à† √öhel",
        polarAngle: "‚ü≤ Pol√°rn√≠ √∫hel",
        horizontal: "‚û°Ô∏è Vodorovnƒõ",
        vertical: "‚¨ÜÔ∏è Svisle",
      };

      window.applyConstraint = function (constraintType) {
        // Zav≈ôi constraint modal
        window.closeConstraintModal();

        // Vstup do constraint m√≥du
        constraintMode = constraintType;
        constraintSelection = [];

        const info = document.getElementById("modeInfo");

        // Pro v≈°echny typy fixace ƒçekej na kliknut√≠ na objekty
        if (info) {
          info.innerHTML = `üîí <strong>${constraintNames[constraintType]}</strong>: Klikej na objekty na pl√°tnƒõ<br/><small>(ESC = zru≈°it | klikej na v≈°echny objekty kter√© chce≈° fixovat)</small>`;
        }

        canvas.style.cursor = "crosshair";
      };

      // ===== APLIKOV√ÅN√ç FIXAC√ç NA OBJEKTY =====
      function applyConstraintsToShape(shape) {
        if (!shape.constraints || shape.constraints.length === 0) return;

        // Zjisti, kter√© body √∫seƒçky jsou fixovan√©
        let startPointFixed = false;
        let endPointFixed = false;

        if (shape.type === "line" && shape.constraints) {
          // Hledej point constraints na bodech
          for (let constraint of shape.constraints) {
            if (constraint.type === "point") {
              const val = constraint.value;
              // Zkontroluj, zda se jedn√° o zaƒç√°tek nebo konec √∫seƒçky
              if (
                Math.abs(shape.x1 - val.x) < 0.01 &&
                Math.abs(shape.y1 - val.y) < 0.01
              ) {
                startPointFixed = true;
              }
              if (
                Math.abs(shape.x2 - val.x) < 0.01 &&
                Math.abs(shape.y2 - val.y) < 0.01
              ) {
                endPointFixed = true;
              }
            }
          }
        }

        shape.constraints.forEach((constraint) => {
          if (constraint.type === "point") {
            // Bod - posun na zadan√© sou≈ôadnice
            if (shape.x !== undefined && shape.y !== undefined) {
              shape.x = constraint.value.x;
              shape.y = constraint.value.y;
            }
          } else if (constraint.type === "horizontal") {
            // Vodorovnost - nastavit stejn√© Y
            if (shape.type === "line") {
              // Pokud je poƒç√°tek fixovan√Ω, mƒõnit konec
              if (startPointFixed && !endPointFixed) {
                shape.y2 = shape.y1;
              }
              // Pokud je konec fixovan√Ω, mƒõnit poƒç√°tek
              else if (endPointFixed && !startPointFixed) {
                shape.y1 = shape.y2;
              }
              // Jinak default - mƒõnit konec
              else {
                shape.y2 = shape.y1;
              }
            }
          } else if (constraint.type === "vertical") {
            // Svislost - nastavit stejn√© X
            if (shape.type === "line") {
              // Pokud je poƒç√°tek fixovan√Ω, mƒõnit konec
              if (startPointFixed && !endPointFixed) {
                shape.x2 = shape.x1;
              }
              // Pokud je konec fixovan√Ω, mƒõnit poƒç√°tek
              else if (endPointFixed && !startPointFixed) {
                shape.x1 = shape.x2;
              }
              // Jinak default - mƒõnit konec
              else {
                shape.x2 = shape.x1;
              }
            }
          } else if (constraint.type === "distance") {
            // Vzd√°lenost - upravit d√©lku ƒç√°ry
            if (shape.type === "line") {
              const dx = shape.x2 - shape.x1;
              const dy = shape.y2 - shape.y1;
              const currentLength = Math.sqrt(dx * dx + dy * dy);
              if (currentLength > 0) {
                const ratio = constraint.value / currentLength;
                const newDx = dx * ratio;
                const newDy = dy * ratio;

                // Pokud je poƒç√°tek fixovan√Ω, mƒõnit konec
                if (startPointFixed && !endPointFixed) {
                  shape.x2 = shape.x1 + newDx;
                  shape.y2 = shape.y1 + newDy;
                }
                // Pokud je konec fixovan√Ω, mƒõnit poƒç√°tek
                else if (endPointFixed && !startPointFixed) {
                  shape.x1 = shape.x2 - newDx;
                  shape.y1 = shape.y2 - newDy;
                }
                // Jinak default - mƒõnit konec, –Ω–∞—á–∞–ª–æ z≈Østane
                else {
                  shape.x2 = shape.x1 + newDx;
                  shape.y2 = shape.y1 + newDy;
                }
              }
            }
          } else if (constraint.type === "radius") {
            // Radius - zmƒõnit polomƒõr kruhu
            if (shape.type === "circle") {
              shape.r = constraint.value;
            }
          } else if (constraint.type === "polarAngle") {
            // Pol√°rn√≠ √∫hel - otoƒçit √∫seƒçku na absolutn√≠ √∫hel v≈Øƒçi horizont√°le
            if (shape.type === "line") {
              // Po≈æadovan√Ω √∫hel v radi√°nech
              const targetAngle = (constraint.value * Math.PI) / 180;

              // D√©lka ƒç√°ry
              const dx = shape.x2 - shape.x1;
              const dy = shape.y2 - shape.y1;
              const length = Math.sqrt(dx * dx + dy * dy);

              // Pokud je poƒç√°tek fixovan√Ω, mƒõnit konec
              if (startPointFixed && !endPointFixed) {
                const newX2 = shape.x1 + length * Math.cos(targetAngle);
                const newY2 = shape.y1 + length * Math.sin(targetAngle);
                shape.x2 = newX2;
                shape.y2 = newY2;
              }
              // Pokud je konec fixovan√Ω, mƒõnit poƒç√°tek
              else if (endPointFixed && !startPointFixed) {
                const newX1 = shape.x2 - length * Math.cos(targetAngle);
                const newY1 = shape.y2 - length * Math.sin(targetAngle);
                shape.x1 = newX1;
                shape.y1 = newY1;
              }
              // Jinak default - mƒõnit konec
              else {
                const newX2 = shape.x1 + length * Math.cos(targetAngle);
                const newY2 = shape.y1 + length * Math.sin(targetAngle);
                shape.x2 = newX2;
                shape.y2 = newY2;
              }
            }
          }
        });
      }

      // ===== KRESLEN√ç FIXAC√ç =====
      function drawConstraints() {
        ctx.save();
        ctx.font = "bold 12px Arial";
        ctx.fillStyle = "#ff0000";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";

        // Kreslen√≠ fixac√≠ pro tvary
        shapes.forEach((shape) => {
          if (!shape.constraints || shape.constraints.length === 0) return;

          shape.constraints.forEach((constraint) => {
            if (constraint.type === "point") {
              // Bod s kart√©zsk√Ωmi sou≈ôadnicemi
              const p = worldToScreen(constraint.value.x, constraint.value.y);
              ctx.fillStyle = "#ff0000";
              ctx.font = "bold 18px Arial";
              ctx.fillText(
                `üìç X:${constraint.value.x.toFixed(
                  displayDecimals
                )} Z:${constraint.value.y.toFixed(displayDecimals)}`,
                p.x + 15,
                p.y - 20
              );
            } else if (constraint.type === "distance") {
              // Vzd√°lenost - k√≥ta posunuta kolmo na ƒç√°ru
              if (shape.type === "line") {
                const p1 = worldToScreen(shape.x1, shape.y1);
                const p2 = worldToScreen(shape.x2, shape.y2);
                const mx = (p1.x + p2.x) / 2;
                const my = (p1.y + p2.y) / 2;

                // Spoƒç√≠tej kolm√Ω vektor k ƒç√°≈ôe pro posun k√≥ty
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                const perpX = (-dy / len) * 35; // Posun kolmo
                const perpY = (dx / len) * 35;

                // Posunut√© body k√≥ty
                const p1Offset = { x: p1.x + perpX, y: p1.y + perpY };
                const p2Offset = { x: p2.x + perpX, y: p2.y + perpY };
                const mOffset = { x: mx + perpX, y: my + perpY };

                ctx.strokeStyle = "#ffff00";
                ctx.lineWidth = 2;

                // Ved√≠c√≠ ƒç√°ry od koncov√Ωch bod≈Ø √∫seƒçky k k√≥ty
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p1Offset.x, p1Offset.y);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(p2.x, p2.y);
                ctx.lineTo(p2Offset.x, p2Offset.y);
                ctx.stroke();

                // Hlavn√≠ k√≥tovac√≠ ƒç√°ra - paralelnƒõ s p≈Øvodn√≠ ƒç√°rou
                ctx.beginPath();
                ctx.moveTo(p1Offset.x, p1Offset.y);
                ctx.lineTo(p2Offset.x, p2Offset.y);
                ctx.stroke();

                // Koncov√© ƒç√°rky - kolm√© na ƒç√°ru
                const endMarkX = (-dy / len) * 6;
                const endMarkY = (dx / len) * 6;

                ctx.beginPath();
                ctx.moveTo(p1Offset.x - endMarkX, p1Offset.y - endMarkY);
                ctx.lineTo(p1Offset.x + endMarkX, p1Offset.y + endMarkY);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(p2Offset.x - endMarkX, p2Offset.y - endMarkY);
                ctx.lineTo(p2Offset.x + endMarkX, p2Offset.y + endMarkY);
                ctx.stroke();

                // K√≥tovac√≠ text - vodorovnƒõ nad k√≥tou, otoƒçeno pod√©l ƒç√°ry
                ctx.save();
                ctx.fillStyle = "#ffff00";
                ctx.strokeStyle = "#000000";
                ctx.lineWidth = 2;
                ctx.font = "bold 18px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                // Posun textu nahoru od k√≥ty (pou≈æij perpendicular vector)
                const textOffsetX = mOffset.x - perpX * 0.5;
                const textOffsetY = mOffset.y - perpY * 0.5;

                // Otoƒçit text pod√©l ƒç√°ry
                const angle = Math.atan2(dy, dx);
                ctx.translate(textOffsetX, textOffsetY);
                ctx.rotate(angle);

                const text = `L=${constraint.value.toFixed(displayDecimals)}`;
                ctx.strokeText(text, 0, 0);
                ctx.fillText(text, 0, 0);

                ctx.restore();
              }
            } else if (constraint.type === "radius") {
              // Radius - ≈°ipka ke kru≈ænici s k√≥tou ze≈°ikma
              if (shape.type === "circle") {
                const c = worldToScreen(shape.cx, shape.cy);
                const circleRadius = shape.r * zoom; // Polomƒõr v pixelech

                ctx.strokeStyle = "#ffff00";
                ctx.fillStyle = "#ffff00";
                ctx.lineWidth = 2;

                // √öhel pro ≈°ipku - ze≈°ikma ke kru≈ænici (45¬∞)
                const angle = Math.PI / 4; // 45¬∞ √∫hel
                const leadDistance = circleRadius + 60; // Vzd√°lenost k√≥ty od kru≈ænice

                // Koncov√Ω bod ≈°ipky (na kru≈ænici)
                const arrowX = c.x + circleRadius * Math.cos(angle);
                const arrowY = c.y + circleRadius * Math.sin(angle);

                // Bod pro text (d√°l od kru≈ænice)
                const textPointX = c.x + leadDistance * Math.cos(angle);
                const textPointY = c.y + leadDistance * Math.sin(angle);

                // Veden√≠ od kru≈ænice k textu (bez ƒç√°ry od st≈ôedu)
                ctx.beginPath();
                ctx.moveTo(arrowX, arrowY);
                ctx.lineTo(textPointX, textPointY);
                ctx.stroke();

                // ≈†ipka - mal√° znaƒçka na konci veden√≠ u kru≈ænice
                const arrowHeadSize = 8;
                const arrowHeadX1 =
                  arrowX -
                  arrowHeadSize * Math.cos(angle) -
                  arrowHeadSize * Math.sin(angle);
                const arrowHeadY1 =
                  arrowY -
                  arrowHeadSize * Math.sin(angle) +
                  arrowHeadSize * Math.cos(angle);
                const arrowHeadX2 =
                  arrowX -
                  arrowHeadSize * Math.cos(angle) +
                  arrowHeadSize * Math.sin(angle);
                const arrowHeadY2 =
                  arrowY -
                  arrowHeadSize * Math.sin(angle) -
                  arrowHeadSize * Math.cos(angle);

                ctx.beginPath();
                ctx.moveTo(arrowHeadX1, arrowHeadY1);
                ctx.lineTo(arrowX, arrowY);
                ctx.lineTo(arrowHeadX2, arrowHeadY2);
                ctx.stroke();

                // Text - ≈ælutƒõ s ƒçern√Ωm obrysem
                ctx.fillStyle = "#ffff00";
                ctx.strokeStyle = "#000000";
                ctx.lineWidth = 2;
                ctx.font = "bold 18px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                const radiusText = `R=${constraint.value.toFixed(
                  displayDecimals
                )}`;
                ctx.strokeText(radiusText, textPointX, textPointY);
                ctx.fillText(radiusText, textPointX, textPointY);
              }
            } else if (constraint.type === "polarAngle") {
              // Pol√°rn√≠ √∫hel - oblouk od horizont√°ly k √∫seƒçce
              if (shape.type === "line") {
                const p1 = worldToScreen(shape.x1, shape.y1);
                const p2 = worldToScreen(shape.x2, shape.y2);

                // St≈ôed oblouku - na prvn√≠m bodƒõ √∫seƒçky
                const centerX = p1.x;
                const centerY = p1.y;

                // Polomƒõr oblouku
                const arcRadius = 40;

                // √öhel linky
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const lineAngle = Math.atan2(dy, dx);

                // Referenƒçn√≠ √∫hel (0¬∞ = doprava, je vodorovn√Ω)
                const refAngle = 0;

                // Kreslen√≠ oblouku
                ctx.strokeStyle = "#00aaff";
                ctx.lineWidth = 2;
                ctx.setLineDash([]);

                ctx.beginPath();
                ctx.arc(
                  centerX,
                  centerY,
                  arcRadius,
                  refAngle,
                  lineAngle,
                  lineAngle < 0 ? true : false
                );
                ctx.stroke();

                // Kreslen√≠ referenƒçn√≠ ƒç√°ry (horizont√°ln√≠ vpravo)
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + arcRadius * 1.3, centerY);
                ctx.stroke();

                // Kreslen√≠ ƒç√°ry √∫seƒçky (od st≈ôedu)
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(p2.x, p2.y);
                ctx.strokeStyle = "#00aaff";
                ctx.lineWidth = 2;
                ctx.stroke();

                // Text - √∫hel v stupn√≠ch
                const textAngle = lineAngle / 2; // St≈ôed mezi dvƒõma √∫hly
                const textRadius = arcRadius + 20;
                const textX = centerX + textRadius * Math.cos(textAngle);
                const textY = centerY + textRadius * Math.sin(textAngle);

                ctx.fillStyle = "#00aaff";
                ctx.strokeStyle = "#000000";
                ctx.lineWidth = 2;
                ctx.font = "bold 14px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                const polarAngleText = `${constraint.value.toFixed(1)}¬∞`;
                ctx.strokeText(polarAngleText, textX, textY);
                ctx.fillText(polarAngleText, textX, textY);
              }
            } else if (constraint.type === "horizontal") {
              // Vodorovnost - zelen√° ƒç√°rkovan√° ƒç√°ra
              if (shape.type === "line") {
                const p1 = worldToScreen(shape.x1, shape.y1);
                const p2 = worldToScreen(shape.x2, shape.y2);
                ctx.strokeStyle = "#00ff00";
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = "#00ff00";
                ctx.font = "bold 12px Arial";
                ctx.fillText(
                  "‚û°Ô∏è Vodorovnƒõ",
                  (p1.x + p2.x) / 2,
                  (p1.y + p2.y) / 2 - 25
                );
              }
            } else if (constraint.type === "vertical") {
              // Svislost - modr√° ƒç√°rkovan√° ƒç√°ra
              if (shape.type === "line") {
                const p1 = worldToScreen(shape.x1, shape.y1);
                const p2 = worldToScreen(shape.x2, shape.y2);
                ctx.strokeStyle = "#0000ff";
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = "#0000ff";
                ctx.font = "bold 12px Arial";
                ctx.fillText(
                  "‚¨ÜÔ∏è Svisle",
                  (p1.x + p2.x) / 2 + 15,
                  (p1.y + p2.y) / 2 - 25
                );
              }
            }
          });
        });

        // Kreslen√≠ fixac√≠ pro body - z vybran√Ωch polo≈æek
        selectedItems.forEach((item) => {
          if (item.category === "point" && item.constraints) {
            item.constraints.forEach((constraint) => {
              const p = worldToScreen(item.x, item.y);

              if (constraint.type === "point") {
                // Bod s kart√©zsk√Ωmi sou≈ôadnicemi - ≈ælutƒõ s ƒçern√Ωm obryem
                // Ukazuj AKTU√ÅLN√ç sou≈ôadnice bodu, ne starou constraint hodnotu
                let displayX = item.y;
                if (xMeasureMode === "diameter") displayX *= 2;

                ctx.fillStyle = "#ffff00";
                ctx.strokeStyle = "#000000";
                ctx.lineWidth = 2;
                ctx.font = "bold 16px Arial";
                ctx.strokeText(
                  `üìç Z:${item.x.toFixed(displayDecimals)} X:${displayX.toFixed(
                    displayDecimals
                  )}`,
                  p.x + 15,
                  p.y - 20
                );
                ctx.fillText(
                  `üìç Z:${item.x.toFixed(displayDecimals)} X:${displayX.toFixed(
                    displayDecimals
                  )}`,
                  p.x + 15,
                  p.y - 20
                );
              }
            });
          }
        });

        // Kreslen√≠ fixac√≠ pro cachedSnapPoints tak√© (endpoint body)
        cachedSnapPoints.forEach((point) => {
          if (point.constraints && point.constraints.length > 0) {
            point.constraints.forEach((constraint) => {
              const p = worldToScreen(point.x, point.y);

              if (constraint.type === "point") {
                // Bod s kart√©zsk√Ωmi sou≈ôadnicemi - ≈ælutƒõ s ƒçern√Ωm obrysem
                // Ukazuj AKTU√ÅLN√ç sou≈ôadnice bodu, ne starou constraint hodnotu
                let displayX = point.y;
                if (xMeasureMode === "diameter") displayX *= 2;

                ctx.fillStyle = "#ffff00";
                ctx.strokeStyle = "#000000";
                ctx.lineWidth = 2;
                ctx.font = "bold 16px Arial";
                ctx.strokeText(
                  `üìç Z:${point.x.toFixed(
                    displayDecimals
                  )} X:${displayX.toFixed(displayDecimals)}`,
                  p.x + 15,
                  p.y - 20
                );
                ctx.fillText(
                  `üìç Z:${point.x.toFixed(
                    displayDecimals
                  )} X:${displayX.toFixed(displayDecimals)}`,
                  p.x + 15,
                  p.y - 20
                );
              }
            });
          }
        });

        ctx.restore();
      }

      window.applyConstraintToSelection = function (constraintType, value) {
        const targetItems =
          constraintSelection.length > 0 ? constraintSelection : selectedItems;
        if (targetItems.length === 0) {
          alert("‚ùå ≈Ω√°dn√© objekty nejsou vybr√°ny!");
          return;
        }

        // Standardn√≠ zpracov√°n√≠ pro constraint typy
        // Aplikuj fixaci
        targetItems.forEach((item) => {
          if (item.shape) {
            // Fixace tvaru
            if (!item.shape.constraints) item.shape.constraints = [];

            let constraintValue = value;
            if (constraintType === "point") {
              constraintValue = { x: value.x, y: value.y };
            }

            item.shape.constraints.push({
              type: constraintType,
              value: constraintValue,
              timestamp: new Date().toISOString(),
            });

            // Hned aplikuj fixaci na geometrii
            applyConstraintsToShape(item.shape);
          } else if (item.category === "point") {
            // Fixace bodu - hledej v cachedSnapPoints a synchronizuj
            if (!item.constraints) item.constraints = [];

            let constraintValue = value;
            if (constraintType === "point") {
              constraintValue = { x: value.x, y: value.y };

              // Zkontroluj, zda se sou≈ôadnice skuteƒçnƒõ zmƒõnily
              const hasMoved =
                Math.abs(value.x - item.x) > 0.01 ||
                Math.abs(value.y - item.y) > 0.01;

              if (hasMoved) {
                // Synchronizuj bod v cachedSnapPoints P≈òED posunem (hledej starou pozici)
                const matchedSnapPoint = cachedSnapPoints.find(
                  (p) =>
                    Math.abs(p.x - item.x) < 0.01 &&
                    Math.abs(p.y - item.y) < 0.01
                );
                if (matchedSnapPoint) {
                  // Posun bod v cachedSnapPoints
                  matchedSnapPoint.x = value.x;
                  matchedSnapPoint.y = value.y;
                }

                // Posun bod na zadan√© sou≈ôadnice POUZE pokud se zmƒõnily
                item.x = value.x;
                item.y = value.y;
              }
            }

            item.constraints.push({
              type: constraintType,
              value: constraintValue,
              timestamp: new Date().toISOString(),
            });

            // Synchronizuj constraints do cachedSnapPoints
            const snapPointForConstraint = cachedSnapPoints.find(
              (p) =>
                Math.abs(p.x - item.x) < 0.01 && Math.abs(p.y - item.y) < 0.01
            );
            if (snapPointForConstraint) {
              if (!snapPointForConstraint.constraints)
                snapPointForConstraint.constraints = [];
              snapPointForConstraint.constraints = item.constraints;
            }
          }
        });

        const info = document.getElementById("modeInfo");
        if (info) {
          info.textContent = `‚úÖ ${constraintNames[constraintType]} fixace aplikov√°na`;
          info.classList.add("show");
          setTimeout(() => info.classList.remove("show"), 2000);
        }

        console.log(`‚úÖ Fixace ${constraintType} aplikov√°na:`, targetItems);
        constraintMode = null;
        constraintSelection = [];
        canvas.style.cursor = "default";
        draw();
      };

      // ===== FUNKCE PRO POTVRZEN√ç HODNOT FIXAC√ç =====
      window.cancelConstraintValue = function () {
        document.getElementById("constraintPointModal").style.display = "none";
        document.getElementById("constraintDistanceModal").style.display =
          "none";
        document.getElementById("constraintRadiusModal").style.display = "none";
        document.getElementById("constraintPolarAngleModal").style.display =
          "none";
        constraintMode = null;
        constraintSelection = [];
        canvas.style.cursor = "default";
      };

      window.confirmConstraintPoint = function () {
        // LOGIKA MAPOV√ÅN√ç:
        // V Canvas/JS je intern√≠ (x, y), ale v LATHE MODU to znamen√° (Z, X)
        // constraintPointX = To co u≈æivatel zad√° jako X (vertik√°ln√≠) ‚Üí mapuje se na intern√≠ Y
        // constraintPointZ = To co u≈æivatel zad√° jako Z (horizont√°ln√≠) ‚Üí mapuje se na intern√≠ X
        let constraintX =
          parseFloat(document.getElementById("constraintPointX").value) || 0;
        const constraintZ =
          parseFloat(document.getElementById("constraintPointZ").value) || 0;

        // Pokud je nastaven diameter mode, X je pr≈Ømƒõr, tak≈æe vydƒõl√≠me 2 aby se vr√°tilo na polomƒõr
        if (xMeasureMode === "diameter") constraintX /= 2;

        // constraintPointX (Y osa v UI) ‚Üí y v intern√≠m k√≥du
        // constraintPointZ (X osa v UI) ‚Üí x v intern√≠m k√≥du
        applyConstraintToSelection("point", { x: constraintZ, y: constraintX });
        window.cancelConstraintValue();
      };

      window.removeConstraint = function (type) {
        // Zav≈ôi v≈°echny mod√°ln√≠ okna
        document.getElementById("constraintPointModal").style.display = "none";
        document.getElementById("constraintDistanceModal").style.display =
          "none";
        document.getElementById("constraintRadiusModal").style.display = "none";
        document.getElementById("constraintAngleModal").style.display = "none";
        document.getElementById("constraintPolarAngleModal").style.display =
          "none";

        // Nastav√≠ se interaktivn√≠ re≈æim pro odstra≈àov√°n√≠
        // U≈æivatel pak klikne na objekty a jejich fixace se sma≈æe
        constraintSelection = [];
        canvas.style.cursor = "crosshair";

        const info = document.getElementById("info");
        if (info) {
          info.innerHTML = `‚ùå <strong>ODSTRANƒöN√ç FIXACE</strong>: Klikni na objekt(y) k smaz√°n√≠ fixace<br/><small>(Klik√°≈°-li na k√≥tu s fixac√≠, fixace se sma≈æe)</small>`;
        }
      };

      window.confirmConstraintDistance = function () {
        const distance =
          parseFloat(
            document.getElementById("constraintDistanceValue").value
          ) || 0;

        applyConstraintToSelection("distance", distance);
        window.cancelConstraintValue();
      };

      window.confirmConstraintRadius = function () {
        const radius =
          parseFloat(document.getElementById("constraintRadiusValue").value) ||
          0;

        applyConstraintToSelection("radius", radius);
        window.cancelConstraintValue();
      };

      window.confirmConstraintPolarAngle = function () {
        const angle =
          parseFloat(
            document.getElementById("constraintPolarAngleValue").value
          ) || 0;

        applyConstraintToSelection("polarAngle", angle);
        window.cancelConstraintValue();
      };

      // Zav≈ôen√≠ mod√°lu kliknut√≠m mimo
      document
        .getElementById("constraintModal")
        .addEventListener("click", (e) => {
          if (e.target.id === "constraintModal") window.closeConstraintModal();
        });

      function init() {
        if (!canvas.parentElement) return;
        canvas.width = canvas.parentElement.clientWidth;
        canvas.height = canvas.parentElement.clientHeight;
        panX = canvas.width / 2;
        panY = canvas.height / 2;
        updateSnapPoints(); // Inicializovat body
        draw();

        // EXPOSE GLOBALS FOR AI MODULE
        window.shapes = shapes;
        window.points = points; // Expose points also
        window.selectedItems = selectedItems; // Expose selections
        window.draw = draw;
        window.updateSnapPoints = updateSnapPoints;
        window.axisMode = axisMode;
        window.undo = undo;
        window.redo = redo;
        // Functions showToolCategory, setMode, showConstraintModal are already window functions defined early

        // Init Key Manager UI
        updateKeyIndicator();
        if (typeof updateApiUsageUI === "function") updateApiUsageUI(); // Initialize API usage display

        // Init Model Selector with change event
        updateModelLimit(); // Set initial limit
        const modelSelect = document.getElementById("aiModelSelect");
        if (modelSelect) {
          modelSelect.addEventListener("change", updateModelLimit);
        }
      }

      function worldToScreen(wx, wy) {
        return {
          x: wx * zoom + panX,
          y: panY - wy * zoom,
        };
      }

      function screenToWorld(sx, sy) {
        return {
          x: (sx - panX) / zoom,
          y: (panY - sy) / zoom,
        };
      }

      // --- MATH FUNKCE PRO PR≈ÆSEƒå√çKY ---

      function intersectLineCircle(line, circle) {
        const dx = line.x2 - line.x1;
        const dy = line.y2 - line.y1;
        const fx = line.x1 - circle.cx;
        const fy = line.y1 - circle.cy;

        const a = dx * dx + dy * dy;
        const b = 2 * (fx * dx + fy * dy);
        const c = fx * fx + fy * fy - circle.r * circle.r;

        const discriminant = b * b - 4 * a * c;
        if (discriminant < 0) return [];

        const t1 = (-b - Math.sqrt(discriminant)) / (2 * a);
        const t2 = (-b + Math.sqrt(discriminant)) / (2 * a);

        const pts = [];
        if (t1 >= 0 && t1 <= 1) {
          pts.push({ x: line.x1 + t1 * dx, y: line.y1 + t1 * dy });
        }
        if (t2 >= 0 && t2 <= 1) {
          pts.push({ x: line.x1 + t2 * dx, y: line.y1 + t2 * dy });
        }
        return pts;
      }

      function intersectCircleCircle(c1, c2) {
        const dx = c2.cx - c1.cx;
        const dy = c2.cy - c1.cy;
        const d = Math.sqrt(dx * dx + dy * dy);

        if (d > c1.r + c2.r || d < Math.abs(c1.r - c2.r) || d === 0) return [];

        const a = (c1.r * c1.r - c2.r * c2.r + d * d) / (2 * d);
        const h = Math.sqrt(Math.max(0, c1.r * c1.r - a * a));

        const x2 = c1.cx + a * (dx / d);
        const y2 = c1.cy + a * (dy / d);

        return [
          {
            x: x2 + h * (dy / d),
            y: y2 - h * (dx / d),
          },
          {
            x: x2 - h * (dy / d),
            y: y2 + h * (dx / d),
          },
        ];
      }

      // --- AKTUALIZACE BOD≈Æ ---

      function updateSnapPoints() {
        cachedSnapPoints = [];

        // 1. Manu√°ln√≠ body
        points.forEach((p) => {
          cachedSnapPoints.push({ x: p.x, y: p.y, type: "point", ref: p });
        });

        // 2. Koncov√© body a st≈ôedy z tvar≈Ø
        shapes.forEach((s) => {
          if (s.type === "line") {
            cachedSnapPoints.push({ x: s.x1, y: s.y1, type: "endpoint" });
            cachedSnapPoints.push({ x: s.x2, y: s.y2, type: "endpoint" });
          } else if (s.type === "circle") {
            cachedSnapPoints.push({ x: s.cx, y: s.cy, type: "center" });
          }
        });

        // 3. Pr≈Øseƒç√≠ky
        for (let i = 0; i < shapes.length; i++) {
          for (let j = i + 1; j < shapes.length; j++) {
            const s1 = shapes[i];
            const s2 = shapes[j];
            let intersects = [];

            if (s1.type === "line" && s2.type === "line") {
              const pt = lineIntersection(s1, s2);
              if (pt) intersects.push(pt);
            } else if (s1.type === "line" && s2.type === "circle") {
              intersects = intersectLineCircle(s1, s2);
            } else if (s1.type === "circle" && s2.type === "line") {
              intersects = intersectLineCircle(s2, s1);
            } else if (s1.type === "circle" && s2.type === "circle") {
              intersects = intersectCircleCircle(s1, s2);
            }

            intersects.forEach((pt) => {
              cachedSnapPoints.push({ x: pt.x, y: pt.y, type: "intersection" });
            });
          }
        }
      }

      // P≈ôichycen√≠ bodu
      function snapPoint(pt) {
        let snapped = { ...pt };
        let snapInfo = null;

        // 1. Zkontrolovat V≈†ECHNY zaj√≠mav√© body (manu√°ln√≠, konce, pr≈Øseƒç√≠ky)
        let bestDist = snapDistance; // Max vzd√°lenost

        for (let p of cachedSnapPoints) {
          const screenP = worldToScreen(p.x, p.y);
          const screenPt = worldToScreen(pt.x, pt.y);
          const dist = Math.sqrt(
            (screenP.x - screenPt.x) ** 2 + (screenP.y - screenPt.y) ** 2
          );

          if (dist < bestDist) {
            bestDist = dist;
            snapped = { x: p.x, y: p.y };
            snapInfo = { type: p.type, x: p.x, y: p.y };
          }
        }

        // Pokud jsme nena≈°li bod, zkus√≠me m≈ô√≠≈æku
        if (!snapInfo && snapToGrid) {
          const gx = Math.round(pt.x / gridSize) * gridSize;
          const gy = Math.round(pt.y / gridSize) * gridSize;
          const screenG = worldToScreen(gx, gy);
          const screenPt = worldToScreen(pt.x, pt.y);
          const dist = Math.sqrt(
            (screenG.x - screenPt.x) ** 2 + (screenG.y - screenPt.y) ** 2
          );

          if (dist < snapDistance) {
            snapped.x = gx;
            snapped.y = gy;
            snapInfo = { type: "grid", x: gx, y: gy };
          }
        }

        return { point: snapped, snapInfo };
      }

      function updateSnap() {
        snapToGrid = document.getElementById("snapGrid").checked;
        snapToPoints = document.getElementById("snapPoints").checked;
        const orthoCheckbox = document.getElementById("orthoMode");
        if (orthoCheckbox) orthoMode = orthoCheckbox.checked;
        snapDistance = parseFloat(
          document.getElementById("snapDistance").value
        );
        // Aktualizovat polar snap
        window.updatePolarSnap();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (document.getElementById("showGrid").checked) {
          drawGrid();
        }

        if (document.getElementById("showAxes").checked) {
          drawAxes();
        }

        shapes.forEach((s) => drawShape(s));
        if (tempShape) {
          // Speci√°ln√≠ barva pro ortogon√°ln√≠ ƒç√°ry
          if (tempShape.ortho) {
            ctx.save();
            ctx.strokeStyle = "#00ff00"; // Zelen√° pro ortho
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]); // ƒå√°rkovan√°
            drawShape(tempShape);
            ctx.restore();
          } else {
            drawShape(tempShape);
          }
        }

        // Draw Selected Items (Highlight + Labels + Circle)
        if (selectedItems.length > 0) {
          selectedItems.forEach((item) => {
            let centerX, centerY;
            let radius = 0;

            if (item.category === "shape") {
              // Kreslen√≠ vybran√©ho tvaru (zv√Ωraznƒõn√≠)
              const s = item.ref;
              ctx.strokeStyle = "#ff66ff"; // Magenta highlight
              ctx.lineWidth = 4;
              ctx.beginPath();
              if (s.type === "line") {
                const p1 = worldToScreen(s.x1, s.y1);
                const p2 = worldToScreen(s.x2, s.y2);
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                centerX = (p1.x + p2.x) / 2;
                centerY = (p1.y + p2.y) / 2;
                // Radius pro krou≈æek (vzd√°lenost od st≈ôedu k nejdel≈°√≠ stranƒõ)
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                radius = Math.sqrt(dx * dx + dy * dy) / 2 + 15;
              } else if (s.type === "circle") {
                const c = worldToScreen(s.cx, s.cy);
                ctx.arc(c.x, c.y, s.r * zoom, 0, Math.PI * 2);
                centerX = c.x;
                centerY = c.y;
                radius = s.r * zoom + 15;
              }
              ctx.stroke();
            } else if (item.category === "point") {
              // Kreslen√≠ vybran√©ho bodu
              const sp = worldToScreen(item.x, item.y);
              ctx.fillStyle = "#ff66ff";
              ctx.beginPath();
              ctx.arc(sp.x, sp.y, 6, 0, Math.PI * 2); // Vƒõt≈°√≠ teƒçka
              ctx.fill();
              ctx.strokeStyle = "#fff";
              ctx.lineWidth = 1;
              ctx.stroke();
              centerX = sp.x;
              centerY = sp.y;
              radius = 20; // Mal√Ω krou≈æek pro bod
            }

            // === NOV√ù: Krou≈æek kolem oznaƒçen√©ho objektu ===
            if (centerX !== undefined && centerY !== undefined && radius > 0) {
              ctx.save();
              ctx.strokeStyle = "#ffaa00"; // Oran≈æov√Ω krou≈æek
              ctx.lineWidth = 2;
              ctx.setLineDash([5, 5]); // ƒå√°rkovan√Ω
              ctx.beginPath();
              ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
              ctx.stroke();
              ctx.restore();
            }

            // Draw Label (A, B, C...)
            if (item.label && centerX !== undefined) {
              ctx.fillStyle = "#ff66ff";
              ctx.fillRect(centerX + 8, centerY - 15, 16, 16);
              ctx.fillStyle = "#000";
              ctx.font = "bold 11px Arial";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(item.label, centerX + 16, centerY - 7);
            }
          });
        }

        // Kreslen√≠ prvn√≠ho bodu (pokud je nastaven startPt a nekresl√≠me ta≈æen√≠m)
        if (startPt && (mode === "line" || mode === "circle")) {
          const sp = worldToScreen(startPt.x, startPt.y);
          ctx.beginPath();
          ctx.arc(sp.x, sp.y, 4, 0, Math.PI * 2);
          ctx.fillStyle = "#00ff00"; // Zelen√Ω bod pro zaƒç√°tek
          ctx.fill();
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 1;
          ctx.stroke();
        }

        // Kreslen√≠ v≈°ech bod≈Ø (manu√°ln√≠ i automatick√©)
        if (document.getElementById("showPoints").checked) {
          cachedSnapPoints.forEach((p) => {
            const sp = worldToScreen(p.x, p.y);
            ctx.beginPath();

            if (p.type === "point") {
              // Manu√°ln√≠ bod - ƒåerven√Ω, trochu vƒõt≈°√≠
              ctx.fillStyle = "#ff4444";
              ctx.arc(sp.x, sp.y, 4, 0, Math.PI * 2);
            } else if (p.type === "intersection") {
              // Pr≈Øseƒç√≠k - B√≠l√Ω
              ctx.fillStyle = "#ffffff";
              ctx.arc(sp.x, sp.y, 3, 0, Math.PI * 2);
            } else {
              // Konec ƒç√°ry / st≈ôed - Svƒõtle modr√Ω/≈°ed√Ω
              ctx.fillStyle = "#a0a0a0";
              ctx.arc(sp.x, sp.y, 3, 0, Math.PI * 2);
            }
            ctx.fill();
          });
        }

        // Zv√Ωraznƒõn√≠ p≈ôichycen√©ho bodu (viditeln√© i bez zobrazen√Ωch bod≈Ø)
        if (mode !== "pan") {
          // Zjistit, zda je kurzor p≈ôichycen√Ω
          const snapResult = snapPoint(cursorPos);
          if (snapResult.snapInfo) {
            const sp = worldToScreen(snapResult.point.x, snapResult.point.y);

            // Velk√Ω ≈ælut√Ω krou≈æek kolem p≈ôichycen√©ho bodu
            ctx.strokeStyle = "#ffff00";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, 10, 0, Math.PI * 2);
            ctx.stroke();

            // Vnit≈ôn√≠ men≈°√≠ krou≈æek
            ctx.strokeStyle = "#ff8800";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, 6, 0, Math.PI * 2);
            ctx.stroke();
          }
        }

        // Zavolej kreslen√≠ fixac√≠ na konci draw()
        drawConstraints();
      }

      function drawGrid() {
        const tl = screenToWorld(0, 0);
        const br = screenToWorld(canvas.width, canvas.height);

        // Vypoƒç√≠tat kolik pixel≈Ø na obrazovce zab√≠r√° jeden d√≠lek m≈ô√≠≈æky
        const gridPixels = gridSize * zoom;

        // Pokud je m≈ô√≠≈æka p≈ô√≠li≈° hust√° (< 3px na ƒç√°ru), zvƒõt≈°it rozestup
        let displayGrid = gridSize;
        let skipFactor = 1;

        if (gridPixels < 3) {
          skipFactor = Math.ceil(3 / gridPixels);
          displayGrid = gridSize * skipFactor;
        }

        // Sekund√°rn√≠ jemnƒõj≈°√≠ m≈ô√≠≈æka (svƒõtlej≈°√≠), pokud je skipFactor > 1
        if (skipFactor > 1 && gridPixels * 5 >= 3) {
          ctx.strokeStyle = "#141414";
          const fineGrid = gridSize * Math.min(5, skipFactor);
          const sx = Math.floor(Math.min(tl.x, br.x) / fineGrid) * fineGrid;
          const ex = Math.ceil(Math.max(tl.x, br.x) / fineGrid) * fineGrid;
          const sy = Math.floor(Math.min(tl.y, br.y) / fineGrid) * fineGrid;
          const ey = Math.ceil(Math.max(tl.y, br.y) / fineGrid) * fineGrid;

          for (let x = sx; x <= ex; x += fineGrid) {
            const p = worldToScreen(x, 0);
            ctx.beginPath();
            ctx.moveTo(p.x, 0);
            ctx.lineTo(p.x, canvas.height);
            ctx.stroke();
          }

          for (let y = sy; y <= ey; y += fineGrid) {
            const p = worldToScreen(0, y);
            ctx.beginPath();
            ctx.moveTo(0, p.y);
            ctx.lineTo(canvas.width, p.y);
            ctx.stroke();
          }
        }

        // Hlavn√≠ m≈ô√≠≈æka
        ctx.strokeStyle = "#1a1a1a";
        ctx.lineWidth = 1;

        const sx = Math.floor(Math.min(tl.x, br.x) / displayGrid) * displayGrid;
        const ex = Math.ceil(Math.max(tl.x, br.x) / displayGrid) * displayGrid;
        const sy = Math.floor(Math.min(tl.y, br.y) / displayGrid) * displayGrid;
        const ey = Math.ceil(Math.max(tl.y, br.y) / displayGrid) * displayGrid;

        for (let x = sx; x <= ex; x += displayGrid) {
          const p = worldToScreen(x, 0);
          ctx.beginPath();
          ctx.moveTo(p.x, 0);
          ctx.lineTo(p.x, canvas.height);
          ctx.stroke();
        }

        for (let y = sy; y <= ey; y += displayGrid) {
          const p = worldToScreen(0, y);
          ctx.beginPath();
          ctx.moveTo(0, p.y);
          ctx.lineTo(canvas.width, p.y);
          ctx.stroke();
        }

        // Zobrazit rozmƒõr m≈ô√≠≈æky a zoom v rohu
        ctx.fillStyle = "#4a4a4a";
        ctx.font = "11px Arial";
        const gridLabel =
          gridSize >= 1 ? `${gridSize}mm` : `${gridSize.toFixed(2)}mm`;
        const displayLabel =
          skipFactor > 1
            ? `M≈ô√≠≈æka: ${gridLabel} (zobrazeno ka≈æd√Ω ${skipFactor}.)`
            : `M≈ô√≠≈æka: ${gridLabel}`;
        ctx.fillText(displayLabel, 10, canvas.height - 40);
        ctx.fillText(
          `Zoom: ${((zoom / 2) * 100).toFixed(0)}%`,
          10,
          canvas.height - 25
        );
      }

      function drawAxes() {
        ctx.strokeStyle = "#3a3a3a";
        ctx.lineWidth = 2;

        const ox = worldToScreen(0, 0);

        // Vodorovn√° osa (osa Z) - ƒåERCHOVAN√Å
        if (ox.y >= 0 && ox.y <= canvas.height) {
          ctx.setLineDash([15, 5, 3, 5]); // Dlouh√°, mezera, teƒçka, mezera
          ctx.beginPath();
          ctx.moveTo(0, ox.y);
          ctx.lineTo(canvas.width, ox.y);
          ctx.stroke();
          ctx.setLineDash([]); // Reset pro zbytek

          // ≈†ipka doprava
          ctx.beginPath();
          ctx.moveTo(canvas.width - 15, ox.y - 5);
          ctx.lineTo(canvas.width - 5, ox.y);
          ctx.lineTo(canvas.width - 15, ox.y + 5);
          ctx.stroke();
        }

        // Svisl√° osa (osa X) - PLN√Å
        if (ox.x >= 0 && ox.x <= canvas.width) {
          ctx.beginPath();
          ctx.moveTo(ox.x, 0);
          ctx.lineTo(ox.x, canvas.height);
          ctx.stroke();

          // ≈†ipka nahoru
          ctx.beginPath();
          ctx.moveTo(ox.x - 5, 15);
          ctx.lineTo(ox.x, 5);
          ctx.lineTo(ox.x + 5, 15);
          ctx.stroke();
        }

        // Popisky os
        if (document.getElementById("showAxisLabels").checked) {
          ctx.fillStyle = "#6ab0ff";
          ctx.font = "bold 14px Arial";

          if (axisMode === "lathe") {
            // Soustruh: Z vodorovnƒõ, X svisle
            if (ox.y >= 0 && ox.y <= canvas.height) {
              ctx.fillText("Z", canvas.width - 25, ox.y - 10);
              ctx.fillStyle = "#888";
              ctx.font = "11px Arial";
              ctx.fillText("(d√©lka)", canvas.width - 60, ox.y - 10);
            }
            if (ox.x >= 0 && ox.x <= canvas.width) {
              ctx.fillStyle = "#6ab0ff";
              ctx.font = "bold 14px Arial";
              ctx.fillText("X", ox.x + 10, 20);
              ctx.fillStyle = "#888";
              ctx.font = "11px Arial";
              // Zmƒõna popisu podle re≈æimu
              const label =
                xMeasureMode === "diameter" ? "(pr≈Ømƒõr ‚åÄ)" : "(polomƒõr R)";
              ctx.fillText(label, ox.x + 10, 35);
            }
          } else {
            // Karusel: X vodorovnƒõ, Y svisle
            if (ox.y >= 0 && ox.y <= canvas.height) {
              ctx.fillText("X", canvas.width - 25, ox.y - 10);
            }
            if (ox.x >= 0 && ox.x <= canvas.width) {
              ctx.fillText("Y", ox.x + 10, 20);
            }
          }

          // Oznaƒçen√≠ poƒç√°tku sou≈ôadnic
          if (
            ox.x >= 0 &&
            ox.x <= canvas.width &&
            ox.y >= 0 &&
            ox.y <= canvas.height
          ) {
            ctx.strokeStyle = "#6ab0ff";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(ox.x, ox.y, 5, 0, Math.PI * 2);
            ctx.stroke();

            ctx.fillStyle = "#6ab0ff";
            ctx.font = "12px Arial";
            ctx.fillText("0", ox.x + 10, ox.y + 15);
          }
        }
      }

      function drawShape(s) {
        let strokeColor = "#4a9eff";
        // Pokud je objekt vybr√°n pro zrcadlen√≠, zv√Ωrazn√≠me ho
        if (selectedShape === s) {
          strokeColor = "#facc15"; // Zlat√° barva pro v√Ωbƒõr
        }
        // Pokud je n√°hled ƒç√°ry a je p≈ôichycen√° na pol√°rn√≠ √∫hel, zmƒõnit barvu na oran≈æovou
        if (s === tempShape && tempShape && tempShape.type === "line" && tempShape.isSnapped) {
          strokeColor = "#ff9800"; // Oran≈æov√° barva p≈ôi p≈ôichycen√≠ na pol√°rn√≠ √∫hel
        }

        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = 2;

        if (s.type === "line") {
          const p1 = worldToScreen(s.x1, s.y1);
          const p2 = worldToScreen(s.x2, s.y2);
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        }

        if (s.type === "circle") {
          const c = worldToScreen(s.cx, s.cy);
          ctx.beginPath();
          ctx.arc(c.x, c.y, s.r * zoom, 0, Math.PI * 2);
          ctx.stroke();

          if (document.getElementById("showDims").checked) {
            ctx.fillStyle = strokeColor;
            ctx.font = "12px Arial";
            // Zobrazit jako pr≈Ømƒõr nebo polomƒõr
            if (xMeasureMode === "diameter") {
              ctx.fillText(
                `‚åÄ${(s.r * 2).toFixed(1)}`,
                c.x + s.r * zoom + 5,
                c.y
              );
            } else {
              ctx.fillText(`R${s.r.toFixed(1)}`, c.x + s.r * zoom + 5, c.y);
            }
          }
        }

        if (s.type === "arc") {
          const c = worldToScreen(s.cx, s.cy);
          const p1 = worldToScreen(s.x1, s.y1);
          const p2 = worldToScreen(s.x2, s.y2);

          // √öhly bod≈Ø
          const angle1 = Math.atan2(p1.y - c.y, p1.x - c.x);
          const angle2 = Math.atan2(p2.y - c.y, p2.x - c.x);

          ctx.save();
          ctx.strokeStyle = s.color || strokeColor;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(
            c.x,
            c.y,
            s.r * zoom,
            angle1,
            angle2,
            s.angle > 180 ? true : false
          );
          ctx.stroke();
          ctx.restore();

          // Kreslen√≠ koncov√Ωch bod≈Ø oblouku
          ctx.fillStyle = s.color || strokeColor;
          ctx.beginPath();
          ctx.arc(p1.x, p1.y, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(p2.x, p2.y, 3, 0, Math.PI * 2);
          ctx.fill();
        }

        // K√ìTOV√ÅN√ç - dimension shapes
        if (s.type === "dimension") {
          ctx.save();
          ctx.strokeStyle = "#ffa500"; // Oran≈æov√° pro k√≥ty
          ctx.fillStyle = "#ffa500";
          ctx.lineWidth = 1;
          ctx.font = "bold 13px Arial";

          if (s.dimType === "linear") {
            // K√≥ta pro d√©lku √∫seƒçky
            const p1 = worldToScreen(s.x1, s.y1);
            const p2 = worldToScreen(s.x2, s.y2);

            // St≈ôed pro text
            const mx = (p1.x + p2.x) / 2;
            const my = (p1.y + p2.y) / 2;

            // √öhel √∫seƒçky
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

            // Offset kolmo na √∫seƒçku (nad n√≠)
            const offsetDist = 20;
            const offsetX = Math.cos(angle + Math.PI / 2) * offsetDist;
            const offsetY = Math.sin(angle + Math.PI / 2) * offsetDist;

            // K√≥tovac√≠ ƒç√°ra (paraleln√≠ s √∫seƒçkou, nad n√≠)
            const dp1x = p1.x + offsetX;
            const dp1y = p1.y + offsetY;
            const dp2x = p2.x + offsetX;
            const dp2y = p2.y + offsetY;

            // Svisl√© ƒç√°ry
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(dp1x, dp1y);
            ctx.moveTo(p2.x, p2.y);
            ctx.lineTo(dp2x, dp2y);
            ctx.stroke();

            // Hlavn√≠ k√≥tovac√≠ ƒç√°ra
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(dp1x, dp1y);
            ctx.lineTo(dp2x, dp2y);
            ctx.stroke();

            // ≈†ipky
            const arrowSize = 8;
            drawArrow(dp1x, dp1y, angle, arrowSize);
            drawArrow(dp2x, dp2y, angle + Math.PI, arrowSize);

            // Text
            const textX = mx + offsetX;
            const textY = my + offsetY - 5;
            ctx.fillStyle = "#1a1a1a";
            ctx.fillRect(textX - 25, textY - 12, 50, 16);
            ctx.fillStyle = "#ffff99"; // Svƒõtlej≈°√≠ ≈ælut√°
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.font = "bold 12px Arial";
            ctx.fillText(`${s.value.toFixed(1)}`, textX, textY);
          } else if (s.dimType === "radius") {
            // K√≥ta pro polomƒõr kru≈ænice
            const c = worldToScreen(s.cx, s.cy);

            // Linie od st≈ôedu k obvodu (≈°ikmo vpravo nahoru)
            const angle = Math.PI / 4;
            const r = s.r * zoom;
            const ex = c.x + r * Math.cos(angle);
            const ey = c.y + r * Math.sin(angle);

            ctx.beginPath();
            ctx.moveTo(c.x, c.y);
            ctx.lineTo(ex, ey);
            ctx.stroke();

            // ≈†ipka na konci
            drawArrow(ex, ey, angle, 8);

            // Text
            const textX = c.x + r * Math.cos(angle) * 0.6;
            const textY = c.y + r * Math.sin(angle) * 0.6 - 8;
            ctx.fillStyle = "#1a1a1a";
            ctx.fillRect(textX - 20, textY - 8, 40, 16);
            ctx.fillStyle = "#ffff99"; // Svƒõtlej≈°√≠ ≈ælut√°
            ctx.textAlign = "center";
            ctx.font = "bold 11px Arial";
            ctx.fillText(`${s.label}${s.value.toFixed(1)}`, textX, textY);
          } else if (s.dimType === "center") {
            // Znaƒçka st≈ôedu (mal√Ω k≈ô√≠≈æek)
            const c = worldToScreen(s.cx, s.cy);
            const size = 8;

            ctx.beginPath();
            ctx.moveTo(c.x - size, c.y);
            ctx.lineTo(c.x + size, c.y);
            ctx.moveTo(c.x, c.y - size);
            ctx.lineTo(c.x, c.y + size);
            ctx.stroke();
          } else if (s.dimType === "coordinate") {
            // K√≥ta pro sou≈ôadnice bodu
            const p = worldToScreen(s.x, s.y);

            // Pozad√≠ pro text
            const text = `Z=${s.valueX.toFixed(1)}\nX=${s.valueY.toFixed(1)}`;
            ctx.fillStyle = "#1a1a1a";
            ctx.fillRect(p.x + 10, p.y - 20, 80, 30);

            // Text sou≈ôadnic
            ctx.fillStyle = "#ffff99"; // Svƒõtlej≈°√≠ ≈ælut√°
            ctx.textAlign = "left";
            ctx.textBaseline = "top";
            ctx.font = "bold 11px Arial";
            ctx.fillText(`Z=${s.valueX.toFixed(1)}`, p.x + 12, p.y - 18);
            ctx.fillText(`X=${s.valueY.toFixed(1)}`, p.x + 12, p.y - 5);

            // ≈†ipka k bodu
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x + 8, p.y - 10);
            ctx.stroke();
          }

          ctx.restore();
        }

        // === VIZUALIZACE FIXAC√ç ===
        if (s.constraints && s.constraints.length > 0) {
          ctx.save();
          ctx.fillStyle = "#ff6b6b";
          ctx.font = "bold 10px Arial";

          let pos = { x: 0, y: 0 };
          if (s.type === "line") {
            const p1 = worldToScreen(s.x1, s.y1);
            const p2 = worldToScreen(s.x2, s.y2);
            pos = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 - 20 };
          } else if (s.type === "circle") {
            const c = worldToScreen(s.cx, s.cy);
            pos = { x: c.x, y: c.y - s.r * zoom - 15 };
          }

          // Ikona z√°mku pro fixaci
          ctx.fillText("üîí", pos.x, pos.y);
          ctx.fillStyle = "#ff6b6b";
          ctx.font = "8px Arial";
          ctx.fillText(
            s.constraints
              .map((c) => {
                const icons = {
                  point: "üìç",
                  distance: "üìè",
                  radius: "‚≠ï",
                  angle: "‚à†",
                  polarAngle: "‚ü≤",
                  horizontal: "‚û°Ô∏è",
                  vertical: "‚¨ÜÔ∏è",
                };
                return icons[c.type] || "?";
              })
              .join(" "),
            pos.x + 8,
            pos.y - 2
          );

          ctx.restore();
        }
      }

      // Helper funkce pro kreslen√≠ ≈°ipky
      function drawArrow(x, y, angle, size) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-size, -size / 2);
        ctx.lineTo(-size, size / 2);
        ctx.closePath();
        ctx.fillStyle = "#ffa500";
        ctx.fill();
        ctx.restore();
      }

      function drawDim(p1, p2, text) {
        const mx = (p1.x + p2.x) / 2;
        const my = (p1.y + p2.y) / 2;

        ctx.strokeStyle = "#ffa64d";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();

        ctx.fillStyle = "#ffa64d";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        ctx.fillText(text, mx, my - 8);
      }

      // Kreslen√≠ sou≈ôadnicemi
      function setPointFromCursor() {
        // Z√≠skat Y (X v soustruhu)
        let yVal = cursorPos.y;
        // Pokud je re≈æim pr≈Ømƒõr, vyn√°sobit 2 pro zobrazen√≠
        if (xMeasureMode === "diameter") yVal *= 2;

        document.getElementById("quickPointZ").value = cursorPos.x.toFixed(2);
        document.getElementById("quickPointX").value = yVal.toFixed(2);
      }

      function setLineStart() {
        let yVal = cursorPos.y;
        if (xMeasureMode === "diameter") yVal *= 2;

        document.getElementById("lineZ1").value = cursorPos.x.toFixed(2);
        document.getElementById("lineX1").value = yVal.toFixed(2);
      }

      function setLineEnd() {
        let yVal = cursorPos.y;
        if (xMeasureMode === "diameter") yVal *= 2;

        document.getElementById("lineZ2").value = cursorPos.x.toFixed(2);
        document.getElementById("lineX2").value = yVal.toFixed(2);
      }

      function setCircleCenter() {
        let yVal = cursorPos.y;
        if (xMeasureMode === "diameter") yVal *= 2;

        document.getElementById("quickCircleZ").value = cursorPos.x.toFixed(2);
        document.getElementById("quickCircleX").value = yVal.toFixed(2);
      }

      function changeXMeasure() {
        const oldMode = xMeasureMode;
        xMeasureMode = document.getElementById("xMeasureSelect").value;

        // Notifikace pro AI kdy≈æ se zmƒõn√≠ re≈æim
        if (oldMode !== xMeasureMode && window.addMessageToChat) {
          const modeIcon = xMeasureMode === "diameter" ? "‚åÄ" : "R";
          const modeName = xMeasureMode === "diameter" ? "PR≈ÆMƒöR" : "POLOMƒöR";
          const oldModeName = oldMode === "diameter" ? "pr≈Ømƒõr" : "polomƒõr";
          const example =
            xMeasureMode === "diameter"
              ? "X=100 znamen√° pr≈Ømƒõr ‚åÄ100mm (polomƒõr 50mm)"
              : "X=50 znamen√° polomƒõr R50mm";

          window.addMessageToChat(
            "system",
            `üîÑ Zmƒõna re≈æimu X osy: ${oldModeName} ‚Üí <strong>${modeIcon} ${modeName}</strong>\n\n` +
              `üí° ${example}\n\n` +
              `‚ÑπÔ∏è AI je nyn√≠ informov√°na o zmƒõnƒõ re≈æimu.`
          );

          console.log(
            `üîÑ X Measure mode changed: ${oldMode} ‚Üí ${xMeasureMode}`
          );
        }

        draw();
      }

      function addLineByCoords() {
        const z1 = parseFloat(document.getElementById("lineZ1").value);
        let x1 = parseFloat(document.getElementById("lineX1").value);
        const z2 = parseFloat(document.getElementById("lineZ2").value);
        let x2 = parseFloat(document.getElementById("lineX2").value);

        // Konverze zpƒõt na polomƒõr pokud je zad√°no v pr≈Ømƒõru
        if (xMeasureMode === "diameter") {
          x1 /= 2;
          x2 /= 2;
        }

        shapes.push({
          type: "line",
          x1: z1,
          y1: x1,
          x2: z2,
          y2: x2,
        });
        updateSnapPoints();
        draw();
      }

      // Pol√°rn√≠ sou≈ôadnice
      function addLinePolar() {
        const z0 = parseFloat(document.getElementById("polarStartZ").value);
        let x0 = parseFloat(document.getElementById("polarStartX").value);

        // Konverze start bodu
        if (xMeasureMode === "diameter") x0 /= 2;

        const dist = parseFloat(document.getElementById("polarDist").value);
        const angle =
          (parseFloat(document.getElementById("polarAngle").value) * Math.PI) /
          180;

        const z1 = z0 + dist * Math.cos(angle);
        const x1 = x0 + dist * Math.sin(angle);

        shapes.push({
          type: "line",
          x1: z0,
          y1: x0,
          x2: z1,
          y2: x1,
        });

        // Aktualizovat poƒç√°teƒçn√≠ bod pro dal≈°√≠ kreslen√≠ (zobrazit v aktu√°ln√≠m re≈æimu)
        let displayX1 = x1;
        if (xMeasureMode === "diameter") displayX1 *= 2;

        document.getElementById("polarStartZ").value = z1.toFixed(2);
        document.getElementById("polarStartX").value = displayX1.toFixed(2);

        updateSnapPoints();
        draw();
      }

      function addPointPolar() {
        const z0 = parseFloat(document.getElementById("polarStartZ").value);
        let x0 = parseFloat(document.getElementById("polarStartX").value);

        if (xMeasureMode === "diameter") x0 /= 2;

        const dist = parseFloat(document.getElementById("polarDist").value);
        const angle =
          (parseFloat(document.getElementById("polarAngle").value) * Math.PI) /
          180;

        const z1 = z0 + dist * Math.cos(angle);
        const x1 = x0 + dist * Math.sin(angle);

        points.push({ x: z1, y: x1 });

        let displayX1 = x1;
        if (xMeasureMode === "diameter") displayX1 *= 2;

        document.getElementById("polarStartZ").value = z1.toFixed(2);
        document.getElementById("polarStartX").value = displayX1.toFixed(2);

        updateSnapPoints();
        draw();
      }

      function quickAddPoint() {
        const z = parseFloat(document.getElementById("quickPointZ").value);
        let x = parseFloat(document.getElementById("quickPointX").value);
        if (isNaN(z) || isNaN(x)) {
          alert("Zadej platn√© sou≈ôadnice");
          return;
        }

        if (xMeasureMode === "diameter") x /= 2;

        points.push({ x: z, y: x });
        document.getElementById("quickPointZ").value = "";
        document.getElementById("quickPointX").value = "";
        updateSnapPoints();
        draw();
      }

      function quickAddCircle() {
        const z = parseFloat(document.getElementById("quickCircleZ").value);
        let x = parseFloat(document.getElementById("quickCircleX").value);
        const r = parseFloat(document.getElementById("quickCircleR").value);

        if (isNaN(z) || isNaN(x) || isNaN(r)) {
          alert("Zadej platn√© sou≈ôadnice a polomƒõr");
          return;
        }

        if (xMeasureMode === "diameter") x /= 2;

        shapes.push({ type: "circle", cx: z, cy: x, r: r });
        document.getElementById("quickCircleZ").value = "";
        document.getElementById("quickCircleX").value = "";
        document.getElementById("quickCircleR").value = "";
        updateSnapPoints();
        draw();
      }

      // Funkce pro hled√°n√≠ pr≈Øseƒç√≠k≈Ø dvou ƒçar
      function lineIntersection(line1, line2) {
        const x1 = line1.x1,
          y1 = line1.y1,
          x2 = line1.x2,
          y2 = line1.y2;
        const x3 = line2.x1,
          y3 = line2.y1,
          x4 = line2.x2,
          y4 = line2.y2;

        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (Math.abs(denom) < 0.0001) return null;

        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

        if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
          return {
            x: x1 + t * (x2 - x1),
            y: y1 + t * (y2 - y1),
          };
        }
        return null;
      }

      // Funkce pro teƒçnu z bodu ke kru≈ænici
      function tangentFromPoint(circle, point) {
        const dx = point.x - circle.cx;
        const dy = point.y - circle.cy;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < circle.r) return null; // Bod uvnit≈ô kru≈ænice

        const angle = Math.atan2(dy, dx);
        const tangentAngle = Math.asin(circle.r / dist);

        const tangents = [];
        for (let sign of [-1, 1]) {
          const a = angle + sign * tangentAngle;
          const touchX =
            circle.cx + circle.r * Math.cos(a + (sign * Math.PI) / 2);
          const touchY =
            circle.cy + circle.r * Math.sin(a + (sign * Math.PI) / 2);
          tangents.push({
            x1: point.x,
            y1: point.y,
            x2: touchX,
            y2: touchY,
          });
        }
        return tangents;
      }

      // Funkce pro kolmici
      function perpendicular(line, point) {
        const dx = line.x2 - line.x1;
        const dy = line.y2 - line.y1;
        const len = Math.sqrt(dx * dx + dy * dy);

        // Smƒõrov√Ω vektor kolmice
        const px = (-dy / len) * 50; // D√©lka kolmice 50mm
        const py = (dx / len) * 50;

        return {
          type: "line",
          x1: point.x - px,
          y1: point.y - py,
          x2: point.x + px,
          y2: point.y + py,
        };
      }

      // Funkce pro rovnobƒõ≈æku
      function parallel(line, distance) {
        const dx = line.x2 - line.x1;
        const dy = line.y2 - line.y1;
        const len = Math.sqrt(dx * dx + dy * dy);

        const offsetX = (-dy / len) * distance;
        const offsetY = (dx / len) * distance;

        return {
          type: "line",
          x1: line.x1 + offsetX,
          y1: line.y1 + offsetY,
          x2: line.x2 + offsetX,
          y2: line.y2 + offsetY,
        };
      }

      // O≈ô√≠znut√≠ ƒç√°ry
      function trimLine(line, cutPoint) {
        const dx = line.x2 - line.x1;
        const dy = line.y2 - line.y1;
        const len = Math.sqrt(dx * dx + dy * dy);

        // Fix: Use cutPoint instead of w, and line instead of s
        const t =
          ((cutPoint.x - line.x1) * dx + (cutPoint.y - line.y1) * dy) /
          (len * len);

        if (t < 0.5) {
          return {
            type: "line",
            x1: cutPoint.x,
            y1: cutPoint.y,
            x2: line.x2,
            y2: line.y2,
          };
        } else {
          return {
            type: "line",
            x1: line.x1,
            y1: line.y1,
            x2: cutPoint.x,
            y2: cutPoint.y,
          };
        }
      }

      // --- V√Ωpoƒçet zrcadlov√©ho bodu ---
      function getMirrorPoint(p, line) {
        // Line: A*x + B*y + C = 0
        // A = y1 - y2
        // B = x2 - x1
        // C = -A*x1 - B*y1
        const A = line.y1 - line.y2;
        const B = line.x2 - line.x1;
        const C = -A * line.x1 - B * line.y1;

        const m = A * A + B * B;
        if (m === 0) return { x: p.x, y: p.y };

        const f = (-2 * (A * p.x + B * p.y + C)) / m;
        return {
          x: p.x + f * A,
          y: p.y + f * B,
        };
      }

      // --- NOV√Å FUNKCE PRO TOGGLE PAN ---
      window.togglePan = function () {
        if (mode === "pan") {
          mode = null; // Vypnout m√≥d
          const btn = document.getElementById("btnPanCanvas");
          if (btn) btn.classList.remove("active");

          const info = document.getElementById("modeInfo");
          if (info) info.classList.remove("show");
        } else {
          setMode("pan");
        }
      };

      // --- RESET VIEW NA V≈†ECHNY OBJEKTY ---
      window.resetView = function () {
        // Fit All - zobrazit v≈°echny objekty
        if (shapes.length === 0 && points.length === 0) {
          // ≈Ω√°dn√© objekty - reset na v√Ωchoz√≠
          zoom = 2;
          panX = canvas.width / 2;
          panY = canvas.height / 2;
          draw();

          const info = document.getElementById("modeInfo");
          if (info) {
            info.textContent = "‚åñ ≈Ω√°dn√© objekty k zobrazen√≠";
            info.classList.add("show");
            setTimeout(() => info.classList.remove("show"), 1500);
          }
          return;
        }

        // Naj√≠t bounding box v≈°ech objekt≈Ø
        let minX = Infinity,
          maxX = -Infinity;
        let minY = Infinity,
          maxY = -Infinity;

        // Zpracovat tvary
        shapes.forEach((s) => {
          if (s.type === "line") {
            minX = Math.min(minX, s.x1, s.x2);
            maxX = Math.max(maxX, s.x1, s.x2);
            minY = Math.min(minY, s.y1, s.y2);
            maxY = Math.max(maxY, s.y1, s.y2);
          } else if (s.type === "circle") {
            minX = Math.min(minX, s.cx - s.r);
            maxX = Math.max(maxX, s.cx + s.r);
            minY = Math.min(minY, s.cy - s.r);
            maxY = Math.max(maxY, s.cy + s.r);
          }
        });

        // Zpracovat body
        points.forEach((p) => {
          minX = Math.min(minX, p.x);
          maxX = Math.max(maxX, p.x);
          minY = Math.min(minY, p.y);
          maxY = Math.max(maxY, p.y);
        });

        // Spoƒç√≠tat st≈ôed a rozsah
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const rangeX = maxX - minX;
        const rangeY = maxY - minY;

        // Vypoƒç√≠tat zoom aby se v≈°e ve≈°lo (s 10% marginem)
        const margin = 1.1;
        const zoomX = (canvas.width / rangeX) * margin;
        const zoomY = (canvas.height / rangeY) * margin;
        zoom = Math.min(zoomX, zoomY, 100); // Max zoom 100
        zoom = Math.max(zoom, 0.1); // Min zoom 0.1

        // Nastavit pan na st≈ôed objekt≈Ø
        panX = canvas.width / 2 - centerX * zoom;
        panY = canvas.height / 2 + centerY * zoom;

        draw();

        // Vizu√°ln√≠ feedback
        const info = document.getElementById("modeInfo");
        if (info) {
          info.textContent = `‚åñ Zobrazeno ${
            shapes.length + points.length
          } objekt≈Ø`;
          info.classList.add("show");
          setTimeout(() => info.classList.remove("show"), 1500);
        }
      };

      window.setMode = function (m) {
        mode = m;
        // Neodstra≈àovat active z tlaƒç√≠tek kategori√≠ (zaƒç√≠naj√≠ btnCat)
        document.querySelectorAll(".tool-btn").forEach((b) => {
          if (!b.id.startsWith("btnCat")) b.classList.remove("active");
        });
        // Odstranit active i z nov√©ho tlaƒç√≠tka na pl√°tnƒõ, pokud p≈ôep√≠n√°m jinam
        const btnPan = document.getElementById("btnPanCanvas");
        if (btnPan) btnPan.classList.remove("active");

        const btnMap = {
          pan: "btnPanCanvas",
          line: "btnLine",
          circle: "btnCircle",
          arc: "btnArc",
          point: "btnPoint",
          trim: "btnTrim",
          extend: "btnExtend",
          tangent: "btnTangent",
          perpendicular: "btnPerpendicular",
          parallel: "btnParallel",
          offset: "btnOffset",
          mirror: "btnMirror",
          erase: "btnErase",
          measure: "btnMeasure",
          dimension: "btnDimension",
          select: "btnAiSelect",
          ai: "btnCatAi",
          align: "align",
          rotate: "rotate",
        };

        if (btnMap[m] && document.getElementById(btnMap[m])) {
          document.getElementById(btnMap[m]).classList.add("active");
        }

        // Highlight tlaƒç√≠tka uvnit≈ô AI panelu (ruƒçn√≠ stylov√°n√≠)
        const btnAiSelect = document.getElementById("btnAiSelect");
        if (btnAiSelect) {
          if (m === "select") {
            btnAiSelect.style.background = "#7c3aed";
            btnAiSelect.style.borderColor = "#8b5cf6";
            btnAiSelect.style.color = "#fff";
          } else {
            btnAiSelect.style.background = "#333";
            btnAiSelect.style.borderColor = "#444";
            btnAiSelect.style.color = "#ccc";
          }
        }

        // Zobrazit n√°povƒõdu pro aktu√°ln√≠ m√≥d
        const modeInfo = document.getElementById("modeInfo");
        const infoTexts = {
          select:
            "üëÜ Klikni na objekty pro v√Ωbƒõr (Shift pro v√≠cen√°sobn√Ω v√Ωbƒõr)",
          point: "üìç Klikni pro vytvo≈ôen√≠ bodu",
          line: "üìè Klikni pro 1. bod, pak klikni pro 2. bod",
          circle: "‚≠ï Klikni st≈ôed, klikni obvod (pak zadej polomƒõr)",
          arc: "üåô Klikni start ‚Üí end ‚Üí zadat √∫hel (stupnƒõ)",
          tangent: "‚üÇ Klikni bod, pak kru≈ænici",
          perpendicular: "‚î¥ Klikni bod, pak ƒç√°ru",
          parallel: "‚à• Klikni bod, pak ƒç√°ru",
          trim: "‚úÇÔ∏è Klikni na ƒç√°ru pro o≈ô√≠znut√≠",
          extend: "‚ÜîÔ∏è Klikni na ƒç√°ru pro prota≈æen√≠ do pr≈Øseƒç√≠ku",
          offset: "‚áÑ Klikni na ƒç√°ru pro odsazen√≠",
          mirror: "ü™û Klikni na objekt (zdroj), pak na ƒç√°ru (osa)",
          erase: "üóëÔ∏è Klikni na objekt pro smaz√°n√≠",
          measure: "üìè Klikni na objekt pro zobrazen√≠ rozmƒõr≈Ø",
          pan: "‚úã T√°hni pro posun pohledu",
          ai: "‚ú® Napi≈° p≈ô√≠kaz pro Gemini AI",
          align: "‚öñÔ∏è Krok 1: Klikni na REFERENƒåN√ç bod objektu",
          rotate: "üîÅ Krok 1: Klikni na ST≈òED rotace",
          dimension: "üìê Klikni na objekty pro vytvo≈ôen√≠ rozmƒõr≈Ø",
        };

        if (modeInfo) {
          if (infoTexts[m]) {
            modeInfo.textContent = infoTexts[m];
            modeInfo.classList.add("show");
            // N√°povƒõda zmiz√≠ po 5s, pokud to nen√≠ pan nebo select
            if (m !== "pan" && m !== "select" && m !== "align") {
              setTimeout(() => {
                if (modeInfo) modeInfo.classList.remove("show");
              }, 5000);
            }
          } else {
            modeInfo.classList.remove("show");
          }
        }

        // Pokud jdu z select m√≥du pryƒç, NEMA≈ΩU v√Ωbƒõr, aby ho AI vidƒõlo
        // Reset kreslic√≠ho stavu
        selectedShape = null;
        startPt = null;
        drawing = false;
        tempShape = null;
        draw();
      };

      window.deleteAllDimensions = function () {
        // Spoƒç√≠tat kolik se sma≈æe
        const countBefore = shapes.filter((s) => s.type === "dimension").length;

        if (countBefore === 0) {
          alert("‚ùå Nejsou ≈æ√°dn√© k√≥ty k smaz√°n√≠!");
          return;
        }

        if (confirm(`Opravdu smazat v≈°ech ${countBefore} k√≥t(y)?`)) {
          // Odfiltrovat v≈°echny dimension objekty
          shapes = shapes.filter((s) => s.type !== "dimension");

          saveState(); // Ulo≈æit pro undo
          updateSnapPoints();
          draw();

          alert(`‚úÖ Smaz√°no ${countBefore} k√≥t(y)`);
        }
      };

      window.dimensionAll = function () {
        // Okotovat v≈°echny ƒç√°ry a kru≈ænice automaticky
        saveState(); // Ulo≈æit pro undo
        let countAdded = 0;

        // Proj√≠t v≈°echny objekty
        for (let s of shapes) {
          if (s.type === "circle") {
            // P≈ôidat radius dimension pro kru≈ænici
            const displayR = xMeasureMode === "diameter" ? s.r * 2 : s.r;
            const label = xMeasureMode === "diameter" ? "‚åÄ" : "R";

            shapes.push({
              type: "dimension",
              dimType: "radius",
              target: s,
              value: displayR,
              label: label,
              cx: s.cx,
              cy: s.cy,
              r: s.r,
            });

            // P≈ôidat znaƒçku st≈ôedu (mal√Ω k≈ô√≠≈æek)
            shapes.push({
              type: "dimension",
              dimType: "center",
              cx: s.cx,
              cy: s.cy,
            });

            countAdded++;
          } else if (s.type === "line") {
            // P≈ôidat linear dimension pro ƒç√°ru (d√©lka)
            const dx = s.x2 - s.x1;
            const dy = s.y2 - s.y1;
            const len = Math.sqrt(dx * dx + dy * dy);

            shapes.push({
              type: "dimension",
              dimType: "linear",
              target: s,
              value: len,
              x1: s.x1,
              y1: s.y1,
              x2: s.x2,
              y2: s.y2,
            });

            countAdded++;
          }
        }

        if (countAdded === 0) {
          alert("‚ùå Nejsou ≈æ√°dn√© ƒç√°ry nebo kru≈ænice k ok√≥tov√°n√≠!");
          return;
        }

        updateSnapPoints();
        draw();
        alert(`‚úÖ Ok√≥tov√°no ${countAdded} objekt≈Ø (ƒç√°ry + kru≈ænice)`);
      };

      window.toggleAiSelect = function () {
        const isSelecting = mode === "select";

        if (isSelecting) {
          // Konƒç√≠me v√Ωbƒõr, vrac√≠me se do AI chatu
          setMode("pan");
          window.toggleAiPanel(true);
        } else {
          // Zaƒç√≠n√°me v√Ωbƒõr, minimalizujeme panel
          setMode("select");
          window.toggleAiPanel(false);
        }
      };

      window.toggleAiSelect = function () {
        const isSelecting = mode === "select";

        if (isSelecting) {
          // Konƒç√≠me v√Ωbƒõr, vrac√≠me se do AI chatu
          setMode("pan");
          window.toggleAiPanel(true);
        } else {
          // Zaƒç√≠n√°me v√Ωbƒõr, minimalizujeme panel
          setMode("select");
          window.toggleAiPanel(false);
        }
      };

      // ===== POLAR SNAP =====
      window.togglePolarSnapLegacy = function () {
        const checkbox = document.getElementById("polarSnapCheckboxLegacy");
        polarSnapEnabled = checkbox ? checkbox.checked : false;
        console.log(`Polar Snap (Legacy): ${polarSnapEnabled ? "ENABLED" : "DISABLED"}`);
      };

      window.togglePolarSnap = function () {
        const checkbox = document.getElementById("polarSnapCheckbox");
        polarSnapEnabled = checkbox ? checkbox.checked : false;
        console.log(`Polar Snap: ${polarSnapEnabled ? "ENABLED" : "DISABLED"}`);
      };

      window.updatePolarSnap = function () {
        // Aktualizovat povolen√≠
        const checkbox = document.getElementById("polarSnapCheckbox");
        polarSnapEnabled = checkbox ? checkbox.checked : false;

        // Aktualizovat interval
        const angleInput = document.getElementById("polarSnapAngle");
        const newInterval = angleInput ? parseInt(angleInput.value) : 15;

        if (newInterval !== polarSnapInterval) {
          polarSnapInterval = newInterval;
          generatePolarSnapAngles();
          console.log(`Polar Snap updated: interval=${polarSnapInterval}¬∞, angles=${polarSnapAngles.join(", ")}`);
        }
      };

      function generatePolarSnapAngles() {
        // Generovat √∫hly na z√°kladƒõ intervalu
        polarSnapAngles = [];
        for (let i = 0; i < 360; i += polarSnapInterval) {
          polarSnapAngles.push(i);
        }
      }

      function snapToPolarAngle(angle) {
        if (!polarSnapEnabled || polarSnapAngles.length === 0) return angle;

        // Naj√≠t nejbli≈æ≈°√≠ pol√°rn√≠ √∫hel
        let nearest = polarSnapAngles[0];
        let minDiff = Math.abs(angle - nearest);

        for (let a of polarSnapAngles) {
          const diff = Math.abs(angle - a);
          if (diff < minDiff) {
            minDiff = diff;
            nearest = a;
          }
        }

        // Snappovat jen kdy≈æ je √∫hel bl√≠zko (do tolerance)
        // Tolerance je fixnƒõ 3¬∞ kolem ka≈æd√©ho snap √∫hlu
        const tolerance = 3;
        if (minDiff < tolerance) {
          return nearest;
        }
        return angle;
      }

      // ===== ARC TOOL =====
      window.createArc = function (x1, y1, x2, y2, angle) {
        // angle je √∫hel oblouku v stupn√≠ch
        // Vypoƒç√≠t√°me st≈ôed a polomƒõr
        const mid_x = (x1 + x2) / 2;
        const mid_y = (y1 + y2) / 2;
        const d = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

        // Polovina √∫hlu v radi√°nech
        const half_angle = (angle * Math.PI) / 360;

        // Polomƒõr oblouku
        const r = d / 2 / Math.sin(half_angle);

        // Smƒõr mezi body
        const dx = x2 - x1;
        const dy = y2 - y1;
        const dir_angle = Math.atan2(dy, dx);

        // St≈ôed oblouku (kolmo na polovinu d√©lky)
        const perp_angle = dir_angle + Math.PI / 2;
        const h = r * Math.cos(half_angle);
        const cx = mid_x + h * Math.cos(perp_angle);
        const cy = mid_y + h * Math.sin(perp_angle);

        const newArc = {
          type: "arc",
          cx: cx,
          cy: cy,
          r: r,
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2,
          angle: angle,
          color: currentColor || "#ffffff",
        };

        shapes.push(newArc);
        saveState();
        updateSnapPoints();
        draw();
      };

      // ===== ROTATE TOOL =====
      window.beginRotate = function () {
        if (selectedItems.length === 0) {
          alert("‚ùå Nejprve vyberte objekty pro rotaci!");
          return;
        }
        rotateStep = 0;
        rotateCenter = null;
        setMode("rotate");
      };

      // ===== COLOR PICKER =====
      window.showColorPicker = function () {
        if (selectedItems.length === 0) {
          alert("‚ùå Nejprve vyberte objekty pro zmƒõnu barvy!");
          return;
        }

        const colorInput = document.createElement("input");
        colorInput.type = "color";
        colorInput.value = currentColor;
        colorInput.onchange = function () {
          currentColor = this.value;
          // Aplikovat barvu na v≈°echny vybran√© objekty
          for (let item of selectedItems) {
            if (item.type === "shape") {
              for (let s of shapes) {
                if (s === item.obj) {
                  s.color = currentColor;
                }
              }
            }
          }
          saveState();
          draw();
        };
        colorInput.click();
      };

      // ===== BOOLEAN OPERATIONS =====
      window.booleanUnion = function () {
        if (selectedItems.length < 2) {
          alert("‚ùå Vyberte minim√°lnƒõ 2 objekty pro sjednocen√≠!");
          return;
        }
        alert("üîó Sjednocen√≠: Funkce bude implementov√°na - zat√≠m ve v√Ωvoji");
      };

      window.booleanIntersect = function () {
        if (selectedItems.length < 2) {
          alert("‚ùå Vyberte minim√°lnƒõ 2 objekty pro pr≈Ønik!");
          return;
        }
        alert("üîó Pr≈Ønik: Funkce bude implementov√°na - zat√≠m ve v√Ωvoji");
      };

      window.booleanDifference = function () {
        if (selectedItems.length < 2) {
          alert("‚ùå Vyberte minim√°lnƒõ 2 objekty pro rozd√≠l!");
          return;
        }
        alert("üîó Rozd√≠l: Funkce bude implementov√°na - zat√≠m ve v√Ωvoji");
      };

      window.performRotate = function () {
        if (!rotateCenter || selectedItems.length === 0) {
          alert("‚ö†Ô∏è Nejd≈ô√≠ve vyberte objekty a st≈ôed rotace!");
          return;
        }

        saveState();
        const angleRad = (rotateAngle * Math.PI) / 180;
        const cos_a = Math.cos(angleRad);
        const sin_a = Math.sin(angleRad);

        for (let item of selectedItems) {
          if (item.type === "shape") {
            const s = item.obj;

            if (s.type === "line") {
              // Rotovat oba konce ƒç√°ry
              const dx1 = s.x1 - rotateCenter.x;
              const dy1 = s.y1 - rotateCenter.y;
              s.x1 = rotateCenter.x + (dx1 * cos_a - dy1 * sin_a);
              s.y1 = rotateCenter.y + (dx1 * sin_a + dy1 * cos_a);

              const dx2 = s.x2 - rotateCenter.x;
              const dy2 = s.y2 - rotateCenter.y;
              s.x2 = rotateCenter.x + (dx2 * cos_a - dy2 * sin_a);
              s.y2 = rotateCenter.y + (dx2 * sin_a + dy2 * cos_a);
            } else if (s.type === "circle") {
              // Rotovat st≈ôed kru≈ænice
              const dx = s.cx - rotateCenter.x;
              const dy = s.cy - rotateCenter.y;
              s.cx = rotateCenter.x + (dx * cos_a - dy * sin_a);
              s.cy = rotateCenter.y + (dx * sin_a + dy * cos_a);
            } else if (s.type === "arc") {
              // Rotovat oblouk
              const dx_start = s.x1 - rotateCenter.x;
              const dy_start = s.y1 - rotateCenter.y;
              s.x1 = rotateCenter.x + (dx_start * cos_a - dy_start * sin_a);
              s.y1 = rotateCenter.y + (dx_start * sin_a + dy_start * cos_a);

              const dx_end = s.x2 - rotateCenter.x;
              const dy_end = s.y2 - rotateCenter.y;
              s.x2 = rotateCenter.x + (dx_end * cos_a - dy_end * sin_a);
              s.y2 = rotateCenter.y + (dx_end * sin_a + dy_end * cos_a);

              const dx_c = s.cx - rotateCenter.x;
              const dy_c = s.cy - rotateCenter.y;
              s.cx = rotateCenter.x + (dx_c * cos_a - dy_c * sin_a);
              s.cy = rotateCenter.y + (dx_c * sin_a + dy_c * cos_a);
            }
          } else if (item.type === "point") {
            const p = item.obj;
            const dx = p.x - rotateCenter.x;
            const dy = p.y - rotateCenter.y;
            p.x = rotateCenter.x + (dx * cos_a - dy * sin_a);
            p.y = rotateCenter.y + (dx * sin_a + dy * cos_a);
          }
        }

        rotateStep = 0;
        rotateCenter = null;
        rotateAngle = 0;
        selectedItems = [];
        updateSnapPoints();
        draw();
        alert(`‚úÖ Rotace o ${rotateAngle}¬∞ aplikov√°na`);
        setMode("pan");
      };

      window.toggleAiPanel = function (showFull) {
        const flexStyle = showFull ? "flex" : "none";
        const blockStyle = showFull ? "block" : "none";

        const header = document.getElementById("aiHeaderRow");
        const history = document.getElementById("aiChatHistory");
        const input = document.getElementById("aiInputZone");
        const list = document.getElementById("aiSelectionList");

        if (header) header.style.display = flexStyle;
        if (history) history.style.display = flexStyle;
        if (input) input.style.display = blockStyle;
        // List is special: only show if we have items
        if (list)
          list.style.display =
            showFull && selectedItems.length > 0 ? "flex" : "none";
      };

      window.clearSelection = function () {
        selectedItems = [];
        updateSelectionUI();
        draw();
        // Pokud jsme byli v re≈æimu v√Ωbƒõru, vr√°t√≠me pln√Ω panel, ale z≈Østaneme v re≈æimu (nebo ne? UX volba)
        // Zde radƒõji nech√°me u≈æivatele v re≈æimu v√Ωbƒõru, dokud neklikne znovu na tlaƒç√≠tko
      };

      function updateSelectionUI() {
        const selInfo = document.getElementById("aiSelectionInfo");
        const btnClear = document.getElementById("btnClearSelection");
        const list = document.getElementById("aiSelectionList");
        const count = selectedItems.length;

        if (selInfo) {
          selInfo.textContent = `${count} vybr√°no`;
          selInfo.style.display = count > 0 ? "inline" : "none";
        }
        if (btnClear) {
          btnClear.style.display = count > 0 ? "block" : "none";
        }

        // Update Chips List
        if (list) {
          list.innerHTML = "";
          if (count > 0 && mode !== "select") {
            // Show list when NOT in selection mode (i.e. back in chat)
            list.style.display = "flex";
            selectedItems.forEach((item) => {
              const chip = document.createElement("div");
              chip.className = "selection-chip";
              chip.innerHTML = `<span class="letter-badge">${
                item.label
              }</span> ${item.category === "point" ? "Bod" : "Tvar"}`;
              list.appendChild(chip);
            });
          } else {
            list.style.display = "none";
          }
        }
      }

      function changeScale() {
        const s = parseFloat(document.getElementById("scaleSelect").value);
        zoom = 2 * s;
        draw();
      }

      function changeDecimals() {
        displayDecimals = parseInt(
          document.getElementById("decimalsSelect").value
        );
        draw();
      }

      function changeAxisMode() {
        axisMode = document.getElementById("axisMode").value;
        window.axisMode = axisMode; // Sync for AI
        updateCoordinateLabels();
        draw();
      }

      function updateCoordinateLabels() {
        // Aktualizovat popisky podle re≈æimu
        const labels =
          axisMode === "lathe"
            ? { axis1: "Z", axis2: "X" }
            : { axis1: "X", axis2: "Y" };
      }

      function updateGridSpacing() {
        gridSize = parseFloat(document.getElementById("gridSpacing").value);
        draw();
      }

      function setGridSpacing(size) {
        gridSize = size;
        document.getElementById("gridSpacing").value = size;
        draw();
      }

      // P≈ôep√≠n√°n√≠ rozbalovac√≠ch sekc√≠ v menu
      function toggleSection(sectionId) {
        const section = document.getElementById(sectionId + "Section");
        const toggle = document.getElementById(sectionId + "Toggle");

        if (section && toggle) {
          if (section.style.display === "none") {
            section.style.display = "block";
            toggle.textContent = "‚ñ≤";
          } else {
            section.style.display = "none";
            toggle.textContent = "‚ñº";
          }
        }
      }

      // P≈ôep√≠n√°n√≠ sekc√≠ v panelu sou≈ôadnic
      window.toggleCoordSection = function (sectionId) {
        const section = document.getElementById(sectionId);
        const toggle = document.getElementById(sectionId + "Toggle");

        if (section && toggle) {
          if (section.style.display === "none") {
            section.style.display = "block";
            toggle.textContent = "‚ñ≤";
          } else {
            section.style.display = "none";
            toggle.textContent = "‚ñº";
          }
        }
      };

      // P≈ôep√≠n√°n√≠ kategori√≠ n√°stroj≈Ø
      window.showToolCategory = function (category) {
        const menuId =
          "tools" + category.charAt(0).toUpperCase() + category.slice(1);
        const menuEl = document.getElementById(menuId);
        const btnId =
          "btnCat" + category.charAt(0).toUpperCase() + category.slice(1);
        const btnEl = document.getElementById(btnId);

        // Pokud klikneme na ji≈æ aktivn√≠ kategorii, zav≈ôeme ji (toggle)
        if (currentCategory === category && menuEl.style.display !== "none") {
          menuEl.style.display = "none";
          if (btnEl) btnEl.classList.remove("active");
          currentCategory = null;
          // Zru≈°it re≈æim kreslen√≠ kdy≈æ se zav≈ôe menu
          if (mode !== "pan" && mode !== "select") {
            setMode("pan");
          }
          if (category === "ai") setMode("pan"); // Reset mode if closing AI
          return;
        }

        // Skr√Ωt v≈°echny submenu
        document.querySelectorAll(".tool-submenu").forEach((menu) => {
          menu.style.display = "none";
        });

        // Deaktivovat v≈°echna tlaƒç√≠tka
        document.querySelectorAll(".toolbar .tool-btn").forEach((btn) => {
          if (btn.id && btn.id.startsWith("btnCat")) {
            btn.classList.remove("active");
          }
        });

        // Zru≈°it re≈æim kreslen√≠ kdy≈æ se zmƒõn√≠ kategorie
        if (mode !== "pan" && mode !== "select" && category !== "ai") {
          setMode("pan");
        }

        // Zobrazit vybran√©
        if (menuEl) {
          menuEl.style.display = "flex";
          if (btnEl) btnEl.classList.add("active");
          currentCategory = category;

          if (category === "ai") {
            setMode("pan"); // Defaultnƒõ Pan pro pohyb
            window.toggleAiPanel(true); // Ensure full panel is shown

            // Focus na input p≈ôi otev≈ôen√≠
            setTimeout(() => {
              const input = document.getElementById("aiPrompt");
              if (input) input.focus();
            }, 200);

            // Aktualizovat info o v√Ωbƒõru
            updateSelectionUI();
          }
        }
      };

      // Rychl√© p≈ôid√°n√≠ bodu ze sou≈ôadnic
      function quickAddPoint() {
        const z = parseFloat(document.getElementById("quickPointZ").value);
        let x = parseFloat(document.getElementById("quickPointX").value);
        if (isNaN(z) || isNaN(x)) {
          alert("Zadej platn√© sou≈ôadnice");
          return;
        }
        points.push({ x: z, y: x });
        document.getElementById("quickPointZ").value = "";
        document.getElementById("quickPointX").value = "";
        updateSnapPoints();
        draw();
      }

      // Rychl√© p≈ôid√°n√≠ kru≈ænice ze sou≈ôadnic
      function quickAddCircle() {
        const z = parseFloat(document.getElementById("quickCircleZ").value);
        let x = parseFloat(document.getElementById("quickCircleX").value);
        const r = parseFloat(document.getElementById("quickCircleR").value);
        if (isNaN(z) || isNaN(x) || isNaN(r)) {
          alert("Zadej platn√© sou≈ôadnice a polomƒõr");
          return;
        }
        shapes.push({ type: "circle", cx: z, cy: x, r: r });
        document.getElementById("quickCircleZ").value = "";
        document.getElementById("quickCircleX").value = "";
        document.getElementById("quickCircleR").value = "";
        updateSnapPoints();
        draw();
      }

      function clearAll() {
        if (confirm("Vymazat v≈°e?")) {
          shapes.length = 0; // Vymazat obsah pole bez zmƒõny reference
          points.length = 0;
          selectedItems.length = 0;
          updateSnapPoints();
          draw();
        }
      }

      window.calculateIntersections = function () {
        const intersections = [];

        // Naj√≠t v≈°echny pr≈Øseƒç√≠ky mezi objekty
        for (let i = 0; i < shapes.length; i++) {
          for (let j = i + 1; j < shapes.length; j++) {
            const s1 = shapes[i];
            const s2 = shapes[j];

            let pts = [];

            // ƒå√°ra √ó Kru≈ænice
            if (s1.type === "line" && s2.type === "circle") {
              pts = intersectLineCircle(s1, s2);
            } else if (s1.type === "circle" && s2.type === "line") {
              pts = intersectLineCircle(s2, s1);
            }
            // Kru≈ænice √ó Kru≈ænice
            else if (s1.type === "circle" && s2.type === "circle") {
              pts = intersectCircleCircle(s1, s2);
            }
            // ƒå√°ra √ó ƒå√°ra
            else if (s1.type === "line" && s2.type === "line") {
              const pt = lineIntersection(s1, s2);
              if (pt) pts = [pt];
            }

            // P≈ôidat pr≈Øseƒç√≠ky do seznamu
            pts.forEach((pt) => {
              intersections.push({
                x: pt.x,
                y: pt.y,
                shape1: i,
                shape2: j,
              });
            });
          }
        }

        if (intersections.length === 0) {
          alert("Nebyly nalezeny ≈æ√°dn√© pr≈Øseƒç√≠ky.");
          return;
        }

        // Vytvo≈ôit zpr√°vu s v√Ωsledky
        const axisMode = window.axisMode || "lathe";
        let message = `Nalezeno ${intersections.length} pr≈Øseƒç√≠k${
          intersections.length > 1 ? "≈Ø" : ""
        }:\n\n`;

        intersections.forEach((pt, idx) => {
          const displayX = axisMode === "lathe" ? pt.y : pt.x;
          const displayY = axisMode === "lathe" ? pt.x : pt.y;

          if (axisMode === "lathe") {
            message += `${idx + 1}. Z${displayY.toFixed(2)} X${displayX.toFixed(
              2
            )}\n`;
          } else {
            message += `${idx + 1}. X${displayX.toFixed(2)} Y${displayY.toFixed(
              2
            )}\n`;
          }
        });

        alert(message);

        // Volitelnƒõ: p≈ôidat pr≈Øseƒç√≠ky jako body
        const addPoints = confirm(
          "Chcete p≈ôidat pr≈Øseƒç√≠ky jako konstrukƒçn√≠ body?"
        );
        if (addPoints) {
          intersections.forEach((pt) => {
            points.push({ x: pt.x, y: pt.y, label: "‚äó" });
          });
          updateSnapPoints();
          draw();
        }
      };

      // === UNDO/REDO SYSTEM ===
      let undoStack = [];
      let redoStack = [];
      const MAX_HISTORY = 10;

      function saveState() {
        // Ulo≈æit aktu√°ln√≠ stav
        const state = {
          shapes: JSON.parse(JSON.stringify(shapes)),
          points: JSON.parse(JSON.stringify(points)),
        };

        undoStack.push(state);

        // Omezit velikost historie
        if (undoStack.length > MAX_HISTORY) {
          undoStack.shift(); // Odstranit nejstar≈°√≠
        }

        // P≈ôi nov√© akci vymazat redo stack
        redoStack = [];
      }

      function undo() {
        if (undoStack.length === 0) {
          const info = document.getElementById("snapInfo");
          if (info) {
            info.textContent = "‚ö†Ô∏è Nen√≠ co vr√°tit zpƒõt";
            info.style.display = "block";
            setTimeout(() => (info.style.display = "none"), 1000);
          }
          return;
        }

        // Ulo≈æit aktu√°ln√≠ stav do redo
        const currentState = {
          shapes: JSON.parse(JSON.stringify(shapes)),
          points: JSON.parse(JSON.stringify(points)),
        };
        redoStack.push(currentState);

        // Omezit redo stack
        if (redoStack.length > MAX_HISTORY) {
          redoStack.shift();
        }

        // Obnovit p≈ôedchoz√≠ stav
        const prevState = undoStack.pop();
        shapes.length = 0;
        shapes.push(...JSON.parse(JSON.stringify(prevState.shapes)));
        points.length = 0;
        points.push(...JSON.parse(JSON.stringify(prevState.points)));

        updateSnapPoints();
        draw();

        // Vizu√°ln√≠ feedback
        const info = document.getElementById("snapInfo");
        if (info) {
          info.textContent = `‚Ü∂ Zpƒõt (zb√Ωv√° ${undoStack.length})`;
          info.style.display = "block";
          setTimeout(() => (info.style.display = "none"), 1000);
        }
      }

      function redo() {
        if (redoStack.length === 0) {
          const info = document.getElementById("snapInfo");
          if (info) {
            info.textContent = "‚ö†Ô∏è Nen√≠ co vr√°tit vp≈ôed";
            info.style.display = "block";
            setTimeout(() => (info.style.display = "none"), 1000);
          }
          return;
        }

        // Ulo≈æit aktu√°ln√≠ stav do undo
        const currentState = {
          shapes: JSON.parse(JSON.stringify(shapes)),
          points: JSON.parse(JSON.stringify(points)),
        };
        undoStack.push(currentState);

        // Omezit undo stack
        if (undoStack.length > MAX_HISTORY) {
          undoStack.shift();
        }

        // Obnovit dal≈°√≠ stav
        const nextState = redoStack.pop();
        shapes.length = 0;
        shapes.push(...JSON.parse(JSON.stringify(nextState.shapes)));
        points.length = 0;
        points.push(...JSON.parse(JSON.stringify(nextState.points)));

        updateSnapPoints();
        draw();

        // Vizu√°ln√≠ feedback
        const info = document.getElementById("snapInfo");
        if (info) {
          info.textContent = `‚Ü∑ Vp≈ôed (zb√Ωv√° ${redoStack.length})`;
          info.style.display = "block";
          setTimeout(() => (info.style.display = "none"), 1000);
        }
      }

      function resetView() {
        // Fit All - zobrazit v≈°echny objekty
        if (shapes.length === 0 && points.length === 0) {
          // ≈Ω√°dn√© objekty - reset na v√Ωchoz√≠
          zoom = 2;
          panX = canvas.width / 2;
          panY = canvas.height / 2;
          draw();

          const info = document.getElementById("modeInfo");
          if (info) {
            info.textContent = "‚åñ ≈Ω√°dn√© objekty k zobrazen√≠";
            info.classList.add("show");
            setTimeout(() => info.classList.remove("show"), 1500);
          }
          return;
        }

        // Naj√≠t bounding box v≈°ech objekt≈Ø
        let minX = Infinity,
          maxX = -Infinity;
        let minY = Infinity,
          maxY = -Infinity;

        // Zpracovat tvary
        shapes.forEach((s) => {
          if (s.type === "line") {
            minX = Math.min(minX, s.x1, s.x2);
            maxX = Math.max(maxX, s.x1, s.x2);
            minY = Math.min(minY, s.y1, s.y2);
            maxY = Math.max(maxY, s.y1, s.y2);
          } else if (s.type === "circle") {
            minX = Math.min(minX, s.cx - s.r);
            maxX = Math.max(maxX, s.cx + s.r);
            minY = Math.min(minY, s.cy - s.r);
            maxY = Math.max(maxY, s.cy + s.r);
          }
        });

        // Zpracovat body
        points.forEach((p) => {
          minX = Math.min(minX, p.x);
          maxX = Math.max(maxX, p.x);
          minY = Math.min(minY, p.y);
          maxY = Math.max(maxY, p.y);
        });

        // Spoƒç√≠tat st≈ôed a rozsah
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const rangeX = maxX - minX;
        const rangeY = maxY - minY;

        // Vypoƒç√≠tat zoom aby se v≈°e ve≈°lo (s 10% marginem)
        const margin = 1.1;
        const zoomX = (canvas.width / rangeX) * margin;
        const zoomY = (canvas.height / rangeY) * margin;
        zoom = Math.min(zoomX, zoomY, 100); // Max zoom 100
        zoom = Math.max(zoom, 0.1); // Min zoom 0.1

        // Nastavit pan na st≈ôed objekt≈Ø
        panX = canvas.width / 2 - centerX * zoom;
        panY = canvas.height / 2 + centerY * zoom;

        draw();

        // Vizu√°ln√≠ feedback
        const info = document.getElementById("modeInfo");
        if (info) {
          info.textContent = `‚åñ Zobrazeno ${
            shapes.length + points.length
          } objekt≈Ø`;
          info.classList.add("show");
          setTimeout(() => info.classList.remove("show"), 1500);
        }
      }

      // === NOV√â FUNKCE ===

      // Vycentrovat na poƒç√°tek sou≈ôadnic (0,0)
      function centerToOrigin() {
        // Nastavit pan tak, aby byl bod (0,0) p≈ôesnƒõ uprost≈ôed canvasu
        panX = canvas.width / 2;
        panY = canvas.height / 2;
        // M≈Ø≈æe≈° tak√© nastavit rozumn√Ω zoom, nebo ponechat st√°vaj√≠c√≠
        // zoom = 2; // Odkomentuj pokud chce≈° v≈ædy stejn√Ω zoom
        draw();

        // Vizu√°ln√≠ feedback
        const info = document.getElementById("modeInfo");
        if (info) {
          info.textContent = "‚äï Vycentrov√°no na (0,0)";
          info.classList.add("show");
          setTimeout(() => info.classList.remove("show"), 1500);
        }
      }

      // Zru≈°it aktu√°ln√≠ m√≥d kreslen√≠
      function clearMode() {
        // Zru≈°it aktu√°ln√≠ m√≥d
        mode = null;

        // Zru≈°it constraint m√≥d
        constraintMode = null;
        constraintSelection = [];
        window.cancelConstraintValue();

        // Zru≈°it align m√≥d
        alignStep = 0;
        alignRefPoint = null;
        alignTargetPoint = null;
        alignLine = null;
        alignAxis = null;

        // Zru≈°it startPt (pokud byl nƒõjak√Ω rozdƒõlan√Ω tvar)
        startPt = null;
        tempShape = null;
        selectedShape = null;

        // Odstranit active ze v≈°ech tlaƒç√≠tek (kromƒõ kategori√≠)
        document.querySelectorAll(".tool-btn").forEach((b) => {
          if (!b.id.startsWith("btnCat")) b.classList.remove("active");
        });

        // Odstranit active z Posun tlaƒç√≠tka
        const btnPan = document.getElementById("btnPanCanvas");
        if (btnPan) btnPan.classList.remove("active");

        // Skr√Ωt mode info
        const info = document.getElementById("modeInfo");
        if (info) info.classList.remove("show");

        // P≈ôekreslit canvas
        draw();

        // Kr√°tk√Ω vizu√°ln√≠ feedback
        const snapInfo = document.getElementById("snapInfo");
        if (snapInfo) {
          snapInfo.textContent = "‚úï M√≥d zru≈°en";
          snapInfo.style.display = "block";
          setTimeout(() => {
            snapInfo.style.display = "none";
          }, 1000);
        }
      }

      // === KONEC NOV√ùCH FUNKC√ç ===

      function exportPNG() {
        const link = document.createElement("a");
        link.download = "soustruzeni_" + Date.now() + ".png";
        link.href = canvas.toDataURL();
        link.click();
      }

      function saveProject() {
        // Vytvo≈ôit objekt s projektem
        const project = {
          version: "1.0",
          date: new Date().toISOString(),
          settings: {
            axisMode: axisMode,
            xMeasureMode: xMeasureMode,
            gridSize: gridSize,
            zoom: zoom,
            panX: panX,
            panY: panY,
          },
          shapes: shapes,
          points: points,
        };

        // P≈ôev√©st na JSON
        const json = JSON.stringify(project, null, 2);

        // Vytvo≈ôit blob a st√°hnout
        const blob = new Blob([json], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");

        // Generovat n√°zev souboru s datem a ƒçasem
        const now = new Date();
        const dateStr = now.toISOString().slice(0, 10); // YYYY-MM-DD
        const timeStr = now.toTimeString().slice(0, 5).replace(":", "-"); // HH-MM
        link.download = `projekt_${dateStr}_${timeStr}.json`;

        link.href = url;
        link.click();
        URL.revokeObjectURL(url);

        // Zobrazit potvrzen√≠
        const modeInfo = document.getElementById("modeInfo");
        if (modeInfo) {
          modeInfo.textContent = "üíæ Projekt ulo≈æen!";
          modeInfo.classList.add("show");
          setTimeout(() => {
            modeInfo.classList.remove("show");
          }, 3000);
        }
      }

      function loadProject(input) {
        const file = input.files[0];
        if (!file) return;

        // Zkontrolovat p≈ô√≠ponu
        if (!file.name.endsWith(".json")) {
          alert("‚ùå Chyba: M≈Ø≈æe≈° naƒç√≠st pouze .json soubory!");
          input.value = "";
          return;
        }

        const reader = new FileReader();

        reader.onload = function (e) {
          try {
            const project = JSON.parse(e.target.result);

            // Validace struktury
            if (!project.shapes || !Array.isArray(project.shapes)) {
              throw new Error(
                "Neplatn√° struktura projektu - chyb√≠ pole shapes"
              );
            }

            // Potvrdit naƒçten√≠ (pokud u≈æ nƒõco nakreslen√©ho)
            if (shapes.length > 0 || points.length > 0) {
              const confirm = window.confirm(
                "‚ö†Ô∏è Naƒçten√≠m projektu p≈ôep√≠≈°e≈° aktu√°ln√≠ kreslen√≠.\n\n" +
                  "Chce≈° pokraƒçovat?"
              );
              if (!confirm) {
                input.value = "";
                return;
              }
            }

            // Naƒç√≠st data
            shapes.length = 0;
            shapes.push(...(project.shapes || []));
            points.length = 0;
            points.push(...(project.points || []));

            // Naƒç√≠st nastaven√≠ (pokud existuj√≠)
            if (project.settings) {
              if (project.settings.axisMode) {
                axisMode = project.settings.axisMode;
                const axisSelect = document.getElementById("axisMode");
                if (axisSelect) axisSelect.value = axisMode;
                updateCoordinateLabels();
              }

              if (project.settings.xMeasureMode) {
                xMeasureMode = project.settings.xMeasureMode;
                const xMeasureSelect =
                  document.getElementById("xMeasureSelect");
                if (xMeasureSelect) xMeasureSelect.value = xMeasureMode;
              }

              if (project.settings.gridSize !== undefined) {
                gridSize = project.settings.gridSize;
                const gridInput = document.getElementById("gridSpacing");
                if (gridInput) gridInput.value = gridSize;
              }

              if (project.settings.zoom !== undefined) {
                zoom = project.settings.zoom;
              }

              if (project.settings.panX !== undefined) {
                panX = project.settings.panX;
              }

              if (project.settings.panY !== undefined) {
                panY = project.settings.panY;
              }
            }

            // Aktualizovat snap body a p≈ôekreslit
            updateSnapPoints();
            draw();

            // Zobrazit potvrzen√≠
            const modeInfo = document.getElementById("modeInfo");
            if (modeInfo) {
              modeInfo.textContent = `‚úÖ Projekt naƒçten! (${shapes.length} tvar≈Ø, ${points.length} bod≈Ø)`;
              modeInfo.classList.add("show");
              setTimeout(() => {
                modeInfo.classList.remove("show");
              }, 4000);
            }
          } catch (error) {
            console.error("Chyba p≈ôi naƒç√≠t√°n√≠ projektu:", error);
            alert("‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ projektu:\n\n" + error.message);
          }

          // Vyƒçistit input
          input.value = "";
        };

        reader.onerror = function () {
          alert("‚ùå Chyba p≈ôi ƒçten√≠ souboru!");
          input.value = "";
        };

        reader.readAsText(file);
      }

      function toggleSelection(item) {
        const index = selectedItems.findIndex((i) => {
          if (item.category === "point" && i.category === "point") {
            // Porovn√°n√≠ sou≈ôadnic bodu
            return (
              Math.abs(item.x - i.x) < 0.0001 && Math.abs(item.y - i.y) < 0.0001
            );
          } else if (item.category === "shape" && i.category === "shape") {
            // Porovn√°n√≠ reference objektu
            return item.ref === i.ref;
          }
          return false;
        });

        if (index > -1) {
          // Remove
          selectedItems.splice(index, 1);
        } else {
          // Add with label
          const labels = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
          // Find first unused label or just use length
          const label = labels[selectedItems.length % labels.length];

          selectedItems.push({ ...item, label: label });
        }

        updateSelectionUI();
      }

      // === AUTO-SELECT ENDPOINT AFTER LINE CREATION ===
      function autoSelectEndpoint(x, y) {
        // Vymazat p≈ôedchoz√≠ oznaƒçen√≠ (aby se nenavy≈°ovaly)
        selectedItems = [];

        // Vytvo≈ôit bod na konci √∫seƒçky (pokud tam je≈°tƒõ nen√≠)
        const existingPoint = points.find(
          (p) => Math.abs(p.x - x) < 0.01 && Math.abs(p.y - y) < 0.01
        );

        if (!existingPoint) {
          points.push({ x, y });
          updateSnapPoints();
        }

        // Oznaƒçit koncov√Ω bod
        const labels = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        selectedItems.push({
          category: "point",
          x: x,
          y: y,
          label: labels[0], // V≈ædy 'A' pro nov√Ω bod
        });

        updateSelectionUI();
        draw();
      }

      // === TOUCH CURSOR FUNKCE ===
      function showTouchCursor(screenX, screenY) {
        const touchCursor = document.getElementById("touchCursor");
        if (!touchCursor) return;

        touchCursorActive = true;
        touchCursor.classList.add("active");

        // Um√≠stit k≈ô√≠≈æek nad prst s offsetem
        touchCursor.style.left = screenX + "px";
        touchCursor.style.top = screenY - touchCursorOffset + "px";
      }

      function hideTouchCursor() {
        const touchCursor = document.getElementById("touchCursor");
        if (!touchCursor) return;

        touchCursorActive = false;
        touchCursor.classList.remove("active");
      }

      function updateTouchCursor(screenX, screenY) {
        if (!touchCursorActive) return;

        const touchCursor = document.getElementById("touchCursor");
        if (!touchCursor) return;

        touchCursor.style.left = screenX + "px";
        touchCursor.style.top = screenY - touchCursorOffset + "px";
      }

      function getTouchCursorPosition(screenX, screenY) {
        // Pokud je touch cursor aktivn√≠, vr√°tit pozici k≈ô√≠≈æku m√≠sto prstu
        if (touchCursorActive) {
          return {
            x: screenX,
            y: screenY - touchCursorOffset,
          };
        }
        return { x: screenX, y: screenY };
      }

      canvas.addEventListener("pointerdown", (e) => {
        const rect = canvas.getBoundingClientRect();
        const sx = e.clientX - rect.left;
        const sy = e.clientY - rect.top;

        // ===== CONSTRAINT MODE HANDLING =====
        if (constraintMode) {
          let w = screenToWorld(sx, sy);
          let snapResult = { point: w, snapInfo: null };
          if (constraintMode !== "pan") {
            snapResult = snapPoint(w);
            w = snapResult.point;
          }

          // Naj√≠t vybran√Ω objekt pro fixaci
          let targetItem = null;

          // 1. Zkusit bod (konstrukƒçn√≠ body)
          if (snapResult.snapInfo && snapResult.snapInfo.type !== "grid") {
            targetItem = {
              category: "point",
              type: snapResult.snapInfo.type,
              x: snapResult.point.x, // Pou≈æij snapResult.point (p≈ôichycen√° pozice), ne snapInfo
              y: snapResult.point.y,
              label: snapResult.snapInfo.type,
            };
          }

          // 1.5. Zkusit koncov√© body ƒçar (start a end points)
          if (!targetItem) {
            const rawW = screenToWorld(sx, sy);
            for (let s of shapes) {
              if (s.type === "line") {
                // Zkusit start point
                const dist1 = Math.sqrt(
                  (rawW.x - s.x1) ** 2 + (rawW.y - s.y1) ** 2
                );
                if (dist1 < 5 / zoom) {
                  targetItem = {
                    category: "point",
                    type: "endpoint",
                    x: s.x1,
                    y: s.y1,
                    label: "konec √∫seƒçky",
                  };
                  break;
                }

                // Zkusit end point
                const dist2 = Math.sqrt(
                  (rawW.x - s.x2) ** 2 + (rawW.y - s.y2) ** 2
                );
                if (dist2 < 5 / zoom) {
                  targetItem = {
                    category: "point",
                    type: "endpoint",
                    x: s.x2,
                    y: s.y2,
                    label: "konec √∫seƒçky",
                  };
                  break;
                }
              }
            }
          }

          // 2. Zkusit tvar
          if (!targetItem) {
            const rawW = screenToWorld(sx, sy);
            for (let s of shapes) {
              let hit = false;
              if (s.type === "line") {
                const dx = s.x2 - s.x1;
                const dy = s.y2 - s.y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                const dist =
                  Math.abs((rawW.y - s.y1) * dx - (rawW.x - s.x1) * dy) / len;
                if (dist < 10 / zoom) hit = true;
              } else if (s.type === "circle") {
                const dist = Math.sqrt(
                  (rawW.x - s.cx) ** 2 + (rawW.y - s.cy) ** 2
                );
                if (Math.abs(dist - s.r) < 10 / zoom) hit = true;
              }

              if (hit) {
                targetItem = {
                  category: "shape",
                  type: s.type,
                  ref: s,
                  shape: s,
                };
                break;
              }
            }
          }

          if (targetItem) {
            constraintSelection.push(targetItem);

            // Aktualizuj info panel - uka≈æ kolik objekt≈Ø je vybr√°no
            const info = document.getElementById("modeInfo");
            const constraintNames = {
              point: "üìç Bod",
              distance: "üìè Vzd√°lenost",
              radius: "‚≠ï Radius",
              angle: "‚à† √öhel",
              polarAngle: "‚ü≤ Pol√°rn√≠ √∫hel",
              horizontal: "‚û°Ô∏è Vodorovnƒõ",
              vertical: "‚¨ÜÔ∏è Svisle",
            };

            if (info) {
              info.innerHTML = `‚úÖ <strong>${constraintNames[constraintMode]}</strong>: Vybr√°l jsi ${constraintSelection.length} objektu(≈Ø)<br/><small>(Pokraƒçuj v klik√°n√≠ na dal≈°√≠ objekty nebo popi≈° hodnotu)</small>`;
            }

            // Otev≈ôi mod√°ln√≠ okno podle typu fixace
            if (constraintMode === "point") {
              // Bod m≈Ø≈æe b√Ωt:
              // 1. Manu√°ln√≠ bod
              // 2. Pr≈Øseƒç√≠k (intersection)
              // 3. St≈ôed kru≈ænice (center)
              // 4. Koncov√Ω bod (endpoint)

              // Zkontroluj snapInfo aby se zjistilo co jsme snapped
              if (
                snapResult.snapInfo &&
                (snapResult.snapInfo.type === "point" ||
                  snapResult.snapInfo.type === "intersection" ||
                  snapResult.snapInfo.type === "center")
              ) {
                // Pokud je nastaven diameter mode, mus√≠me br√°t v potaz ≈æe X m≈Ø≈æe b√Ωt pr≈Ømƒõr
                let displayX = snapResult.point.y;
                if (xMeasureMode === "diameter") displayX *= 2;

                document.getElementById("constraintPointX").value =
                  displayX.toFixed(2);
                document.getElementById("constraintPointZ").value =
                  snapResult.point.x.toFixed(2);
                document.getElementById("constraintPointModal").style.display =
                  "flex";
              } else if (targetItem.category === "point") {
                // Fallback - star√Ω k√≥d pro manu√°ln√≠ body
                // Pokud je nastaven diameter mode, mus√≠me br√°t v potaz ≈æe X m≈Ø≈æe b√Ωt pr≈Ømƒõr
                let displayX = targetItem.y;
                if (xMeasureMode === "diameter") displayX *= 2;

                document.getElementById("constraintPointX").value =
                  displayX.toFixed(2);
                document.getElementById("constraintPointZ").value =
                  targetItem.x.toFixed(2);
                document.getElementById("constraintPointModal").style.display =
                  "flex";
              } else {
                alert(
                  "‚ö†Ô∏è Pro fixaci Bod mus√≠≈° vybrat BOD, PR≈ÆSEƒå√çK nebo ST≈òED KRU≈ΩNICE!"
                );
                constraintSelection.pop(); // Odeber posledn√≠
              }
            } else if (constraintMode === "distance") {
              // Spoƒç√≠tej aktu√°ln√≠ d√©lku ƒç√°ry
              let distanceValue = 10; // Default pokud to nen√≠ ƒç√°ra
              const shape = targetItem.ref || targetItem;
              if (shape && shape.type === "line") {
                const dx = shape.x2 - shape.x1;
                const dy = shape.y2 - shape.y1;
                distanceValue = Math.sqrt(dx * dx + dy * dy);
              }
              document.getElementById("constraintDistanceValue").value =
                distanceValue.toFixed(2);
              document.getElementById("constraintDistanceModal").style.display =
                "flex";
            } else if (constraintMode === "radius") {
              if (
                targetItem.category === "shape" &&
                targetItem.type === "circle"
              ) {
                document.getElementById("constraintRadiusValue").value =
                  targetItem.ref.r.toFixed(2);
              } else {
                document.getElementById("constraintRadiusValue").value = "5";
              }
              document.getElementById("constraintRadiusModal").style.display =
                "flex";
            } else if (constraintMode === "angle") {
              // √öhel - MUS√ç B√ùT PR√ÅVƒö 2 √öSEƒåKY, Mƒö≈ò√ç SE √öHEL MEZI NIMI
              if (constraintSelection.length === 2) {
                const line1 =
                  constraintSelection[0].ref || constraintSelection[0];
                const line2 =
                  constraintSelection[1].ref || constraintSelection[1];

                if (line1.type === "line" && line2.type === "line") {
                  // Vypoƒç√≠tej √∫hly obou ƒçar
                  const angle1 =
                    Math.atan2(line1.y2 - line1.y1, line1.x2 - line1.x1) *
                    (180 / Math.PI);
                  const angle2 =
                    Math.atan2(line2.y2 - line2.y1, line2.x2 - line2.x1) *
                    (180 / Math.PI);

                  // Vypoƒç√≠tej rozd√≠l (√∫hel mezi nimi)
                  let angleDiff = Math.abs(angle2 - angle1);
                  // Zajisti, aby byl √∫hel mezi 0¬∞ a 180¬∞
                  if (angleDiff > 180) angleDiff = 360 - angleDiff;

                  document.getElementById("constraintAngleValue").value =
                    angleDiff.toFixed(1);
                  document.getElementById(
                    "constraintAngleModal"
                  ).style.display = "flex";
                } else {
                  alert(
                    "‚ö†Ô∏è Pro fixaci √öhlu mezi √∫seƒçkami mus√≠≈° vybrat DVƒö √öSEƒåKY!"
                  );
                  constraintSelection.pop();
                }
              } else if (constraintSelection.length === 1) {
                // ƒåek√° na druhou √∫seƒçku
                const info = document.getElementById("modeInfo");
                if (info) {
                  info.innerHTML = `‚úÖ <strong>‚à† √öhel mezi √∫seƒçkami</strong>: Vybr√°l jsi 1/2 √∫seƒçky<br/><small>Klikni na druhou √∫seƒçku (ESC = zru≈°it)</small>`;
                }
              }
            } else if (constraintMode === "polarAngle") {
              // Pol√°rn√≠ √∫hel - Mƒö≈ò√ç SE √öHEL JEDN√â √öSEƒåKY V≈ÆƒåI HORIZONT√ÅLE
              if (constraintSelection.length === 1) {
                const line =
                  constraintSelection[0].ref || constraintSelection[0];
                if (line.type === "line") {
                  // Spoƒç√≠tej √∫hel v≈Øƒçi horizont√°le (0¬∞ = doprava, 90¬∞ = nahoru)
                  const angle =
                    Math.atan2(line.y2 - line.y1, line.x2 - line.x1) *
                    (180 / Math.PI);
                  // Ujisti se, ≈æe je √∫hel kladn√Ω (0-360)
                  const positiveAngle = angle < 0 ? angle + 360 : angle;
                  document.getElementById("constraintPolarAngleValue").value =
                    positiveAngle.toFixed(1);
                  document.getElementById(
                    "constraintPolarAngleModal"
                  ).style.display = "flex";
                } else {
                  alert("‚ö†Ô∏è Pro pol√°rn√≠ √∫hel mus√≠≈° vybrat √öSEƒåKU!");
                  constraintSelection.pop();
                }
              } else {
                // ƒåek√° na √∫seƒçku
                const info = document.getElementById("modeInfo");
                if (info) {
                  info.innerHTML = `üéØ <strong>‚ü≤ Pol√°rn√≠ √∫hel</strong>: Klikni na √öSEƒåKU<br/><small>(ESC = zru≈°it)</small>`;
                }
              }
            } else if (constraintMode === "horizontal") {
              // Vodorovnost - aplikuj rovnou bez mod√°ln√≠ho okna
              applyConstraintToSelection("horizontal", null);
            } else if (constraintMode === "vertical") {
              // Svislost - aplikuj rovnou bez mod√°ln√≠ho okna
              applyConstraintToSelection("vertical", null);
            } else if (
              constraintMode === "horizontal" ||
              constraintMode === "vertical"
            ) {
              // Pro vodorovnost a svislost aplikuj rovnou
              applyConstraintToSelection(constraintMode, null);
              constraintMode = null;
              constraintSelection = [];
              canvas.style.cursor = "default";
            } else if (constraintMode === "removeConstraint") {
              // Re≈æim odstra≈àov√°n√≠ fixace - sma≈æ fixaci z klikan√©ho objektu
              if (targetItem) {
                if (
                  targetItem.constraints &&
                  targetItem.constraints.length > 0
                ) {
                  const countBefore = targetItem.constraints.length;
                  targetItem.constraints = []; // Sma≈æ v≈°echny fixace
                  const info = document.getElementById("info");
                  if (info) {
                    info.innerHTML = `‚úÖ Odstranƒõno ${countBefore} fixace(√≠)! Pokraƒçuj nebo stiskni ESC`;
                  }
                } else {
                  const info = document.getElementById("info");
                  if (info) {
                    info.innerHTML = `‚ö†Ô∏è Tento objekt nem√° ≈æ√°dn√© fixace. Pokraƒçuj nebo stiskni ESC`;
                  }
                }
              }
            }
          }

          return; // Skip zbytku
        }

        // Touch cursor pro dotykov√° za≈ô√≠zen√≠
        if (e.pointerType === "touch" && mode !== "pan") {
          // Spustit timeout pro zobrazen√≠ touch cursoru
          touchCursorTimeout = setTimeout(() => {
            showTouchCursor(sx, sy);
          }, touchCursorDelay);
        }

        let w = screenToWorld(sx, sy);

        // P≈ôichycen√≠ - V≈ΩDY pro v≈°echny m√≥dy kromƒõ 'pan'
        let snapResult = { point: w, snapInfo: null };
        if (mode !== "pan") {
          snapResult = snapPoint(w);
          w = snapResult.point;
        }

        // Aktualizace panelu snap-info (≈ælut√Ω panel) p≈ôi kliknut√≠
        const snapInfoEl = document.getElementById("snapInfo");
        let zVal = w.x.toFixed(2);
        let xVal = w.y.toFixed(2); // Vnit≈ôn√≠ hodnota (polomƒõr)

        // Zobrazen√≠ pro u≈æivatele
        let displayX = xVal;
        if (xMeasureMode === "diameter")
          displayX = (parseFloat(xVal) * 2).toFixed(2);

        let infoText = "";

        if (axisMode === "lathe") {
          infoText = `Oznaƒçeno: Z=${zVal} X=${displayX} mm`;
        } else {
          infoText = `Oznaƒçeno: X=${zVal} Y=${displayX} mm`;
        }

        if (snapResult.snapInfo) {
          if (snapResult.snapInfo.type === "point") infoText += " (bod)";
          else if (snapResult.snapInfo.type === "endpoint")
            infoText += " (konec)";
          else if (snapResult.snapInfo.type === "center")
            infoText += " (st≈ôed)";
          else if (snapResult.snapInfo.type === "intersection")
            infoText += " (pr≈Øseƒç√≠k)";
          else if (snapResult.snapInfo.type === "grid") infoText += " (m≈ô√≠≈æka)";
        }

        if (snapInfoEl) {
          snapInfoEl.textContent = infoText;
          snapInfoEl.classList.add("show");
        }

        if (mode === "select") {
          // LOGIKA V√ùBƒöRU
          let hitFound = false;

          // 1. Zkusit vybrat bod (priorita) - snapnut√Ω bod
          if (snapResult.snapInfo && snapResult.snapInfo.type !== "grid") {
            toggleSelection({
              category: "point",
              type: snapResult.snapInfo.type,
              x: snapResult.snapInfo.x,
              y: snapResult.snapInfo.y,
            });
            hitFound = true;
          }

          // 2. Pokud nen√≠ bod, zkusit vybrat tvar (ƒç√°ra/kru≈ænice)
          if (!hitFound) {
            // Naj√≠t ƒç√°ru/kru≈ænici pod kurzorem (bez snapu)
            const rawW = screenToWorld(sx, sy); // Pou≈æijeme syrov√© sou≈ôadnice pro hit test

            for (let s of shapes) {
              let hit = false;
              if (s.type === "line") {
                const dx = s.x2 - s.x1;
                const dy = s.y2 - s.y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                const dist =
                  Math.abs((rawW.y - s.y1) * dx - (rawW.x - s.x1) * dy) / len;
                if (dist < 10 / zoom) hit = true;
              } else if (s.type === "circle") {
                const dist = Math.sqrt(
                  (rawW.x - s.cx) ** 2 + (rawW.y - s.cy) ** 2
                );
                if (Math.abs(dist - s.r) < 10 / zoom) hit = true;
              }

              if (hit) {
                toggleSelection({
                  category: "shape",
                  type: s.type,
                  ref: s,
                });
                hitFound = true;
                break; // Vybereme jen jeden tvar najednou
              }
            }
          }

          draw(); // P≈ôekreslit pro zobrazen√≠ v√Ωbƒõru
          return;
        }

        if (mode === "pan") {
          drawing = true;
          lastTouch = { x: sx, y: sy };
          panStartPosition = { x: sx, y: sy }; // Ulo≈æit startovn√≠ pozici
          panHasMoved = false; // Reset flag
        } else if (mode === "point") {
          points.push(w);
          saveState(); // Ulo≈æit pro undo
          updateSnapPoints();
          draw();
        } else if (mode === "line") {
          // KLIK-KLIK INTERAKCE PRO ƒå√ÅRU
          if (!startPt) {
            // Prvn√≠ kliknut√≠
            startPt = w;
          } else {
            // Druh√© kliknut√≠ - dokonƒçen√≠
            shapes.push({
              type: "line",
              x1: startPt.x,
              y1: startPt.y,
              x2: w.x,
              y2: w.y,
            });
            saveState(); // Ulo≈æit pro undo

            // === AUTO-SELECT ENDPOINT ===
            autoSelectEndpoint(w.x, w.y);

            startPt = null;
            tempShape = null;
            updateSnapPoints();
          }
          draw();
        } else if (mode === "circle") {
          // KLIK-KLIK INTERAKCE PRO KRU≈ΩNICI S MOD√ÅLEM
          if (!startPt) {
            // Prvn√≠ kliknut√≠ - st≈ôed
            startPt = w;
          } else {
            // Druh√© kliknut√≠ - polomƒõr
            const r = Math.sqrt(
              (w.x - startPt.x) ** 2 + (w.y - startPt.y) ** 2
            );
            if (r > 0) {
              openCircleModal(startPt, r);
            }
            startPt = null;
            tempShape = null;
          }
          draw();
        } else if (mode === "arc") {
          // 3-KLIK INTERAKCE PRO OBLOUK: start ‚Üí end ‚Üí zadat √∫hel
          if (arcStep === 0) {
            // Prvn√≠ kliknut√≠ - start
            arcStart = w;
            arcStep = 1;
            const modeInfo = document.getElementById("modeInfo");
            if (modeInfo)
              modeInfo.textContent = "üåô Krok 2: Klikni na END bod oblouku";
          } else if (arcStep === 1) {
            // Druh√© kliknut√≠ - end
            arcEnd = w;
            arcStep = 2;
            // Otev≈ô√≠t dialog pro zad√°n√≠ √∫hlu
            const angle = prompt(
              "Zadej √∫hel oblouku (stupnƒõ, nap≈ô. 90):",
              "90"
            );
            if (angle !== null) {
              arcAngle = parseFloat(angle) || 90;
              window.createArc(
                arcStart.x,
                arcStart.y,
                arcEnd.x,
                arcEnd.y,
                arcAngle
              );
              // Reset
              arcStep = 0;
              arcStart = null;
              arcEnd = null;
              arcAngle = 0;
              setMode("arc");
            } else {
              arcStep = 0;
              arcStart = null;
              arcEnd = null;
            }
          }
          draw();
        } else if (mode === "rotate") {
          // ROTACE: 1. klik = st≈ôed, 2. zadat √∫hel
          if (rotateStep === 0) {
            // Naj√≠t st≈ôed rotace
            let foundPoint = null;
            const rawW = screenToWorld(sx, sy);

            // Hledej p≈ôichycuj√≠c√≠ bod
            for (let p of points) {
              const d = Math.sqrt((rawW.x - p.x) ** 2 + (rawW.y - p.y) ** 2);
              if (d < 5 / zoom) {
                foundPoint = p;
                break;
              }
            }

            if (!foundPoint) {
              // Hledej endpoint ƒç√°ry
              for (let s of shapes) {
                if (s.type === "line") {
                  const d1 = Math.sqrt(
                    (rawW.x - s.x1) ** 2 + (rawW.y - s.y1) ** 2
                  );
                  if (d1 < 5 / zoom) {
                    foundPoint = { x: s.x1, y: s.y1 };
                    break;
                  }
                  const d2 = Math.sqrt(
                    (rawW.x - s.x2) ** 2 + (rawW.y - s.y2) ** 2
                  );
                  if (d2 < 5 / zoom) {
                    foundPoint = { x: s.x2, y: s.y2 };
                    break;
                  }
                }
              }
            }

            if (foundPoint) {
              rotateCenter = foundPoint;
              rotateStep = 1;
              const modeInfo = document.getElementById("modeInfo");
              if (modeInfo)
                modeInfo.textContent = `üîÅ St≈ôed: (${foundPoint.x.toFixed(
                  2
                )}, ${foundPoint.y.toFixed(2)}) - Zadej √∫hel rotace`;

              const angle = prompt("Zadej √∫hel rotace (stupnƒõ):", "45");
              if (angle !== null) {
                rotateAngle = parseFloat(angle) || 0;
                window.performRotate();
              } else {
                rotateStep = 0;
                rotateCenter = null;
              }
            } else {
              alert("‚ö†Ô∏è Klikni na bod nebo endpoint ƒç√°ry!");
            }
          }
          draw();
        } else if (mode === "tangent") {
          // Naj√≠t kru≈ænici pod kurzorem
          let foundCircle = null;
          for (let s of shapes) {
            if (s.type === "circle") {
              const dist = Math.sqrt((w.x - s.cx) ** 2 + (w.y - s.cy) ** 2);
              if (Math.abs(dist - s.r) < 5 / zoom) {
                foundCircle = s;
                break;
              }
            }
          }

          if (foundCircle && startPt) {
            const tangents = tangentFromPoint(foundCircle, startPt);
            if (tangents) {
              tangents.forEach((t) => shapes.push({ type: "line", ...t }));
              startPt = null;
              updateSnapPoints();
              draw();
            }
          } else {
            startPt = w;
            draw();
          }
        } else if (mode === "perpendicular") {
          // Naj√≠t ƒç√°ru pod kurzorem
          let foundLine = null;
          for (let s of shapes) {
            if (s.type === "line") {
              const dx = s.x2 - s.x1;
              const dy = s.y2 - s.y1;
              const len = Math.sqrt(dx * dx + dy * dy);
              const dist =
                Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
              if (dist < 5 / zoom) {
                foundLine = s;
                break;
              }
            }
          }

          if (foundLine && startPt) {
            shapes.push(perpendicular(foundLine, startPt));
            startPt = null;
            updateSnapPoints();
            draw();
          } else {
            startPt = w;
            draw();
          }
        } else if (mode === "parallel") {
          let foundLine = null;
          for (let s of shapes) {
            if (s.type === "line") {
              const dx = s.x2 - s.x1;
              const dy = s.y2 - s.y1;
              const len = Math.sqrt(dx * dx + dy * dy);
              const dist =
                Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
              if (dist < 5 / zoom) {
                foundLine = s;
                break;
              }
            }
          }

          if (foundLine && startPt) {
            const offsetDist = 10; // Default or prompt user
            shapes.push(parallel(foundLine, offsetDist));
            startPt = null;
            updateSnapPoints();
            draw();
          } else {
            startPt = w;
            draw();
          }
        } else if (mode === "trim") {
          // Naj√≠t ƒç√°ru k o≈ô√≠znut√≠
          for (let i = 0; i < shapes.length; i++) {
            const s = shapes[i];
            if (s.type === "line") {
              const dx = s.x2 - s.x1;
              const dy = s.y2 - s.y1;
              const len = Math.sqrt(dx * dx + dy * dy);
              const t = ((w.x - s.x1) * dx + (w.y - s.y1) * dy) / (len * len);
              if (t >= 0 && t <= 1) {
                const px = s.x1 + t * dx;
                const py = s.y1 + t * dy;
                const dist = Math.sqrt((w.x - px) ** 2 + (w.y - py) ** 2);
                if (dist < 5 / zoom) {
                  shapes[i] = trimLine(s, w);
                  updateSnapPoints();
                  draw();
                  break;
                }
              }
            }
          }
        } else if (mode === "offset") {
          // Odsazen√≠ objektu
          for (let s of shapes) {
            if (s.type === "line") {
              const dx = s.x2 - s.x1;
              const dy = s.y2 - s.y1;
              const len = Math.sqrt(dx * dx + dy * dy);
              const dist =
                Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
              if (dist < 5 / zoom) {
                // Zeptat se u≈æivatele na vzd√°lenost offsetu
                const userInput = prompt(
                  "Zadej vzd√°lenost odsazen√≠ (mm):",
                  offsetDistance
                );
                if (userInput !== null) {
                  const newDist = parseFloat(userInput);
                  if (!isNaN(newDist) && newDist > 0) {
                    offsetDistance = newDist; // Ulo≈æit pro p≈ô√≠≈°tƒõ
                    shapes.push(parallel(s, offsetDistance));
                    updateSnapPoints();
                    draw();
                  } else {
                    alert("Neplatn√° hodnota! Zadej kladn√© ƒç√≠slo.");
                  }
                }
                break;
              }
            }
          }
        } else if (mode === "mirror") {
          // KROK 1: Vybrat objekt k zrcadlen√≠ (Line, Circle, Point)
          if (!selectedShape) {
            let found = null;

            // Zkusit body
            /*
                               (Pozn√°mka: Pro body pou≈æ√≠v√°me pole 'points', ale pro zjednodu≈°en√≠
                               v tomto m√≥du zat√≠m zrcadl√≠me hlavnƒõ 'shapes'. Pokud by se mƒõly zrcadlit
                               i konstrukƒçn√≠ body, museli bychom prohled√°vat i pole points.)
                            */

            // Hledat v shapes
            for (let s of shapes) {
              if (s.type === "line") {
                const dx = s.x2 - s.x1;
                const dy = s.y2 - s.y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                const dist =
                  Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
                if (dist < 5 / zoom) {
                  found = s;
                  break;
                }
              } else if (s.type === "circle") {
                const dist = Math.sqrt((w.x - s.cx) ** 2 + (w.y - s.cy) ** 2);
                if (Math.abs(dist - s.r) < 5 / zoom) {
                  found = s;
                  break;
                }
              }
            }

            if (found) {
              selectedShape = found;
              draw(); // P≈ôekreslit pro zv√Ωraznƒõn√≠
            }
          }
          // KROK 2: Vybrat osu zrcadlen√≠ (mus√≠ to b√Ωt Line)
          else {
            let axisLine = null;
            for (let s of shapes) {
              if (s.type === "line") {
                const dx = s.x2 - s.x1;
                const dy = s.y2 - s.y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                const dist =
                  Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
                if (dist < 5 / zoom) {
                  axisLine = s;
                  break;
                }
              }
            }

            if (axisLine) {
              // Prov√©st zrcadlen√≠
              if (selectedShape.type === "line") {
                const p1 = getMirrorPoint(
                  { x: selectedShape.x1, y: selectedShape.y1 },
                  axisLine
                );
                const p2 = getMirrorPoint(
                  { x: selectedShape.x2, y: selectedShape.y2 },
                  axisLine
                );
                shapes.push({
                  type: "line",
                  x1: p1.x,
                  y1: p1.y,
                  x2: p2.x,
                  y2: p2.y,
                });
              } else if (selectedShape.type === "circle") {
                const c = getMirrorPoint(
                  { x: selectedShape.cx, y: selectedShape.cy },
                  axisLine
                );
                shapes.push({
                  type: "circle",
                  cx: c.x,
                  cy: c.y,
                  r: selectedShape.r,
                });
              }

              // Reset
              selectedShape = null;
              updateSnapPoints();
              draw();
            }
          }
        } else if (mode === "erase") {
          // GUMA - smazat objekt
          let foundIndex = -1;

          // Hledat v shapes
          for (let i = 0; i < shapes.length; i++) {
            const s = shapes[i];
            if (s.type === "line") {
              const dx = s.x2 - s.x1;
              const dy = s.y2 - s.y1;
              const len = Math.sqrt(dx * dx + dy * dy);
              const dist =
                Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
              if (dist < 5 / zoom) {
                foundIndex = i;
                break;
              }
            } else if (s.type === "circle") {
              const dist = Math.sqrt((w.x - s.cx) ** 2 + (w.y - s.cy) ** 2);
              if (Math.abs(dist - s.r) < 5 / zoom) {
                foundIndex = i;
                break;
              }
            }
          }

          if (foundIndex !== -1) {
            shapes.splice(foundIndex, 1);
            updateSnapPoints();
            draw();
          }

          // Hledat v points
          for (let i = 0; i < points.length; i++) {
            const p = points[i];
            const dist = Math.sqrt((w.x - p.x) ** 2 + (w.y - p.y) ** 2);
            if (dist < 5 / zoom) {
              points.splice(i, 1);
              updateSnapPoints();
              draw();
              break;
            }
          }
        } else if (mode === "extend") {
          // PROTA≈ΩEN√ç - prodlou≈æit ƒç√°ru do pr≈Øseƒç√≠ku
          for (let i = 0; i < shapes.length; i++) {
            const s = shapes[i];
            if (s.type === "line") {
              const dx = s.x2 - s.x1;
              const dy = s.y2 - s.y1;
              const len = Math.sqrt(dx * dx + dy * dy);
              const dist =
                Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
              if (dist < 5 / zoom) {
                // Zjistit, kter√Ωm koncem prodlou≈æit (podle bl√≠zkosti ke kurzoru)
                const dist1 = Math.sqrt((w.x - s.x1) ** 2 + (w.y - s.y1) ** 2);
                const dist2 = Math.sqrt((w.x - s.x2) ** 2 + (w.y - s.y2) ** 2);

                // Naj√≠t nejbli≈æ≈°√≠ pr≈Øseƒç√≠k
                let closestIntersect = null;
                let minDist = Infinity;

                for (let j = 0; j < shapes.length; j++) {
                  if (i === j) continue;
                  const other = shapes[j];

                  if (other.type === "line") {
                    const isect = lineLineIntersect(s, other);
                    if (isect) {
                      const d =
                        dist1 < dist2
                          ? Math.sqrt(
                              (isect.x - s.x1) ** 2 + (isect.y - s.y1) ** 2
                            )
                          : Math.sqrt(
                              (isect.x - s.x2) ** 2 + (isect.y - s.y2) ** 2
                            );
                      if (d < minDist) {
                        minDist = d;
                        closestIntersect = isect;
                      }
                    }
                  } else if (other.type === "circle") {
                    const isects = lineCircleIntersect(s, other);
                    for (const isect of isects) {
                      const d =
                        dist1 < dist2
                          ? Math.sqrt(
                              (isect.x - s.x1) ** 2 + (isect.y - s.y1) ** 2
                            )
                          : Math.sqrt(
                              (isect.x - s.x2) ** 2 + (isect.y - s.y2) ** 2
                            );
                      if (d < minDist) {
                        minDist = d;
                        closestIntersect = isect;
                      }
                    }
                  }
                }

                if (closestIntersect) {
                  if (dist1 < dist2) {
                    s.x1 = closestIntersect.x;
                    s.y1 = closestIntersect.y;
                  } else {
                    s.x2 = closestIntersect.x;
                    s.y2 = closestIntersect.y;
                  }
                  updateSnapPoints();
                  draw();
                }
                break;
              }
            }
          }
        } else if (mode === "measure") {
          // Mƒö≈òEN√ç - zobrazit rozmƒõry objektu
          let found = false;

          // Mƒõ≈ôen√≠ kru≈ænice
          for (let s of shapes) {
            if (s.type === "circle") {
              const dist = Math.sqrt((w.x - s.cx) ** 2 + (w.y - s.cy) ** 2);
              if (Math.abs(dist - s.r) < 5 / zoom) {
                const displayR = xMeasureMode === "diameter" ? s.r * 2 : s.r;
                const label = xMeasureMode === "diameter" ? "‚åÄ" : "R";
                alert(
                  `Kru≈ænice:\n${label} = ${displayR.toFixed(
                    3
                  )} mm\nSt≈ôed: Z=${s.cx.toFixed(3)}, X=${s.cy.toFixed(3)}`
                );
                found = true;
                break;
              }
            } else if (s.type === "line") {
              const dx = s.x2 - s.x1;
              const dy = s.y2 - s.y1;
              const len = Math.sqrt(dx * dx + dy * dy);
              const dist =
                Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
              if (dist < 5 / zoom) {
                alert(
                  `√öseƒçka:\nD√©lka = ${len.toFixed(3)} mm\nOd [Z=${s.x1.toFixed(
                    3
                  )}, X=${s.y1.toFixed(3)}]\nDo [Z=${s.x2.toFixed(
                    3
                  )}, X=${s.y2.toFixed(3)}]`
                );
                found = true;
                break;
              }
            }
          }

          // Mƒõ≈ôen√≠ bodu
          if (!found) {
            for (let p of points) {
              const dist = Math.sqrt((w.x - p.x) ** 2 + (w.y - p.y) ** 2);
              if (dist < 5 / zoom) {
                const displayY = xMeasureMode === "diameter" ? p.y * 2 : p.y;
                alert(
                  `Bod:\nZ = ${p.x.toFixed(3)} mm\nX = ${displayY.toFixed(
                    3
                  )} mm`
                );
                found = true;
                break;
              }
            }
          }
        } else if (mode === "align") {
          // ZAROVN√ÅN√ç A POSUN - 4-krokov√Ω proces
          if (alignStep === 0) {
            // Krok 1: Vybrat referenƒçn√≠ bod (na objektu)
            let foundPoint = false;

            // Zkusit naj√≠t bod p≈ô√≠mo
            for (let p of points) {
              const dist = Math.sqrt((w.x - p.x) ** 2 + (w.y - p.y) ** 2);
              if (dist < 5 / zoom) {
                alignRefPoint = { x: p.x, y: p.y };
                alignStep = 1;
                foundPoint = true;
                const info = document.getElementById("modeInfo");
                if (info) {
                  info.innerHTML = `‚úì Referenƒçn√≠ bod vybr√°n: (${p.x.toFixed(
                    1
                  )}, ${p.y.toFixed(1)})<br/>
                                   Krok 2: Klikni na TARGET bod kde m√° b√Ωt p≈ôesunuta`;
                }
                break;
              }
            }

            // Zkusit naj√≠t koncov√Ω bod ƒç√°ry
            if (!foundPoint) {
              for (let s of shapes) {
                if (s.type === "line") {
                  const dist1 = Math.sqrt(
                    (w.x - s.x1) ** 2 + (w.y - s.y1) ** 2
                  );
                  if (dist1 < 5 / zoom) {
                    alignRefPoint = { x: s.x1, y: s.y1 };
                    alignStep = 1;
                    foundPoint = true;
                    const info = document.getElementById("modeInfo");
                    if (info) {
                      info.innerHTML = `‚úì Referenƒçn√≠ bod vybr√°n (start ƒç√°ry): (${s.x1.toFixed(
                        1
                      )}, ${s.y1.toFixed(1)})<br/>
                                       Krok 2: Klikni na TARGET bod`;
                    }
                    break;
                  }
                  const dist2 = Math.sqrt(
                    (w.x - s.x2) ** 2 + (w.y - s.y2) ** 2
                  );
                  if (dist2 < 5 / zoom) {
                    alignRefPoint = { x: s.x2, y: s.y2 };
                    alignStep = 1;
                    foundPoint = true;
                    const info = document.getElementById("modeInfo");
                    if (info) {
                      info.innerHTML = `‚úì Referenƒçn√≠ bod vybr√°n (end ƒç√°ry): (${s.x2.toFixed(
                        1
                      )}, ${s.y2.toFixed(1)})<br/>
                                       Krok 2: Klikni na TARGET bod`;
                    }
                    break;
                  }
                }
              }
            }

            if (!foundPoint) {
              const info = document.getElementById("modeInfo");
              if (info)
                info.textContent =
                  "‚ùå Klikni na existuj√≠c√≠ bod (bod, start nebo end ƒç√°ry)";
            }
          } else if (alignStep === 1) {
            // Krok 2: Vybrat target bod
            let foundPoint = false;

            for (let p of points) {
              const dist = Math.sqrt((w.x - p.x) ** 2 + (w.y - p.y) ** 2);
              if (dist < 5 / zoom) {
                alignTargetPoint = { x: p.x, y: p.y };
                alignStep = 2;
                foundPoint = true;

                // Posunout v≈°echny objekty
                const dx = alignTargetPoint.x - alignRefPoint.x;
                const dy = alignTargetPoint.y - alignRefPoint.y;

                for (let s of shapes) {
                  if (s.type === "point") {
                    s.x += dx;
                    s.y += dy;
                  } else if (s.type === "line") {
                    s.x1 += dx;
                    s.y1 += dy;
                    s.x2 += dx;
                    s.y2 += dy;
                  } else if (s.type === "circle") {
                    s.cx += dx;
                    s.cy += dy;
                  }
                }

                for (let p of points) {
                  p.x += dx;
                  p.y += dy;
                }

                const info = document.getElementById("modeInfo");
                if (info) {
                  info.innerHTML = `‚úì Posun aplikov√°n (${dx.toFixed(
                    1
                  )}, ${dy.toFixed(1)})<br/>
                                   Krok 3: Klikni na √öSEƒåKU kterou chce≈° zarovnat`;
                }
                foundPoint = true;
                break;
              }
            }

            if (!foundPoint) {
              const info = document.getElementById("modeInfo");
              if (info) info.textContent = "‚ùå Klikni na existuj√≠c√≠ c√≠lov√Ω bod";
            }
          } else if (alignStep === 2) {
            // Krok 3: Vybrat √∫seƒçku pro zarovn√°n√≠
            for (let s of shapes) {
              if (s.type === "line") {
                const dx = s.x2 - s.x1;
                const dy = s.y2 - s.y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                const dist =
                  Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
                if (dist < 5 / zoom) {
                  alignLine = s;
                  alignStep = 3;

                  const info = document.getElementById("modeInfo");
                  if (info) {
                    info.innerHTML = `‚úì √öseƒçka vybr√°na<br/>
                                     Krok 4: Vyber osu<br/>
                                     [Z] = vodorovnƒõ | [X] = svisle`;
                  }
                  break;
                }
              }
            }
          } else if (alignStep === 3) {
            // Krok 4: Osa zarovn√°n√≠ - kl√°vesnice
            // Bude zpracov√°no v keydown eventu
          }
        } else if (mode === "dimension") {
          // K√ìTOV√ÅN√ç - vytvo≈ôit permanentn√≠ k√≥tu NEBO upravit existuj√≠c√≠ k√≥tu

          // NEJD≈ò√çV zkusit kliknout na existuj√≠c√≠ k√≥tu k √∫pravƒõ
          let foundDimension = false;
          for (let s of shapes) {
            if (s.type === "dimension") {
              if (s.dimType === "linear" && s.target) {
                // Hit test na line√°rn√≠ k√≥tu
                const mx = (s.x1 + s.x2) / 2;
                const my = (s.y1 + s.y2) / 2;
                const dist = Math.sqrt((w.x - mx) ** 2 + (w.y - my) ** 2);
                if (dist < 10 / zoom) {
                  // Kliknut na line√°rn√≠ k√≥tu - otev≈ô√≠t dialog
                  const newValue = prompt(
                    "Nov√° hodnota d√©lky (mm):",
                    s.value.toFixed(2)
                  );
                  if (newValue !== null) {
                    const numValue = parseFloat(newValue);
                    if (!isNaN(numValue) && numValue > 0) {
                      s.value = numValue;
                      saveState();
                      draw();
                      foundDimension = true;
                      break;
                    }
                  }
                }
              } else if (s.dimType === "radius") {
                // Hit test na radius k√≥tu
                const dist = Math.sqrt((w.x - s.cx) ** 2 + (w.y - s.cy) ** 2);
                if (Math.abs(dist - s.r * 0.6) < 10 / zoom) {
                  // Kliknut na radius k√≥tu - otev≈ô√≠t dialog
                  const newValue = prompt(
                    "Nov√° hodnota polomƒõru (mm):",
                    s.value.toFixed(2)
                  );
                  if (newValue !== null) {
                    const numValue = parseFloat(newValue);
                    if (!isNaN(numValue) && numValue > 0) {
                      s.value = numValue;
                      saveState();
                      draw();
                      foundDimension = true;
                      break;
                    }
                  }
                }
              } else if (s.dimType === "coordinate") {
                // Hit test na coordinate k√≥tu
                const dist = Math.sqrt((w.x - s.x) ** 2 + (w.y - s.y) ** 2);
                if (dist < 15 / zoom) {
                  // Kliknut na coordinate k√≥tu - upravit Z
                  const newZ = prompt(
                    "Nov√° hodnota Z (mm):",
                    s.valueX.toFixed(2)
                  );
                  if (newZ !== null && !isNaN(parseFloat(newZ))) {
                    const newX = prompt(
                      "Nov√° hodnota X (mm):",
                      s.valueY.toFixed(2)
                    );
                    if (newX !== null && !isNaN(parseFloat(newX))) {
                      s.valueX = parseFloat(newZ);
                      s.valueY = parseFloat(newX);
                      saveState();
                      draw();
                      foundDimension = true;
                      break;
                    }
                  }
                }
              }
            }
          }

          if (foundDimension) return; // Vr√°tit se hned

          // Pokud nebylo kliknuto na existuj√≠c√≠ k√≥tu, vytvo≈ôit novou
          saveState(); // Ulo≈æit pro undo
          let found = false;

          // NEJD≈ò√çV ZKONTROLOVAT KONCOV√â BODY ƒåAREK (ENDPOINTS)
          for (let s of shapes) {
            if (s.type === "line") {
              // Zkusit start point
              const dist1 = Math.sqrt((w.x - s.x1) ** 2 + (w.y - s.y1) ** 2);
              if (dist1 < 5 / zoom) {
                const displayY1 = xMeasureMode === "diameter" ? s.y1 * 2 : s.y1;
                shapes.push({
                  type: "dimension",
                  dimType: "coordinate",
                  x: s.x1,
                  y: s.y1,
                  valueX: s.x1,
                  valueY: displayY1,
                });
                updateSnapPoints();
                draw();
                found = true;
                break;
              }

              // Zkusit end point
              const dist2 = Math.sqrt((w.x - s.x2) ** 2 + (w.y - s.y2) ** 2);
              if (dist2 < 5 / zoom) {
                const displayY2 = xMeasureMode === "diameter" ? s.y2 * 2 : s.y2;
                shapes.push({
                  type: "dimension",
                  dimType: "coordinate",
                  x: s.x2,
                  y: s.y2,
                  valueX: s.x2,
                  valueY: displayY2,
                });
                updateSnapPoints();
                draw();
                found = true;
                break;
              }
            }
          }

          if (found) return; // Pokud byl vytvo≈ôen endpoint, skonƒçit zde

          // K√≥tov√°n√≠ kru≈ænice - polomƒõr + znaƒçka st≈ôedu
          for (let s of shapes) {
            if (s.type === "circle") {
              const dist = Math.sqrt((w.x - s.cx) ** 2 + (w.y - s.cy) ** 2);
              if (Math.abs(dist - s.r) < 5 / zoom) {
                const displayR = xMeasureMode === "diameter" ? s.r * 2 : s.r;
                const label = xMeasureMode === "diameter" ? "‚åÄ" : "R";

                // P≈ôidat k√≥tu pro polomƒõr
                shapes.push({
                  type: "dimension",
                  dimType: "radius",
                  target: s,
                  value: displayR,
                  label: label,
                  cx: s.cx,
                  cy: s.cy,
                  r: s.r,
                });

                // P≈ôidat znaƒçku st≈ôedu (mal√Ω k≈ô√≠≈æek)
                shapes.push({
                  type: "dimension",
                  dimType: "center",
                  cx: s.cx,
                  cy: s.cy,
                });

                updateSnapPoints();
                draw();
                found = true;
                break;
              }
            } else if (s.type === "line") {
              // K√≥tov√°n√≠ √∫seƒçky - d√©lka
              const dx = s.x2 - s.x1;
              const dy = s.y2 - s.y1;
              const len = Math.sqrt(dx * dx + dy * dy);
              const dist =
                Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
              if (dist < 5 / zoom) {
                shapes.push({
                  type: "dimension",
                  dimType: "linear",
                  target: s,
                  value: len,
                  x1: s.x1,
                  y1: s.y1,
                  x2: s.x2,
                  y2: s.y2,
                });

                updateSnapPoints();
                draw();
                found = true;
                break;
              }
            }
          }

          // K√≥tov√°n√≠ bodu/pr≈Øseƒç√≠ku - sou≈ôadnice (manu√°ln√≠ body)
          if (!found) {
            for (let p of points) {
              const dist = Math.sqrt((w.x - p.x) ** 2 + (w.y - p.y) ** 2);
              if (dist < 5 / zoom) {
                const displayY = xMeasureMode === "diameter" ? p.y * 2 : p.y;

                shapes.push({
                  type: "dimension",
                  dimType: "coordinate",
                  x: p.x,
                  y: p.y,
                  valueX: p.x,
                  valueY: displayY,
                });

                updateSnapPoints();
                draw();
                found = true;
                break;
              }
            }
          }
        }
      });

      canvas.addEventListener("pointermove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const sx = e.clientX - rect.left;
        const sy = e.clientY - rect.top;

        // DEBUG
        if (startPt && mode === "line") {
          // Polar snap debug - removed for cleaner console
        }

        // Aktualizace touch cursoru p≈ôi pohybu
        if (touchCursorActive) {
          updateTouchCursor(sx, sy);
        }

        // Pokud je touch cursor aktivn√≠, pou≈æ√≠t jeho pozici
        let adjustedPos = getTouchCursorPosition(sx, sy);
        let w = screenToWorld(adjustedPos.x, adjustedPos.y);

        // P≈ôichycen√≠ - V≈ΩDY pro v≈°echny m√≥dy kromƒõ pan
        let snapResult = { point: w, snapInfo: null };
        if (mode !== "pan") {
          snapResult = snapPoint(w);
          w = snapResult.point;
        }

        // Ulo≈æit aktu√°ln√≠ polohu kurzoru
        cursorPos = w;

        // Zobrazen√≠ sou≈ôadnic podle m√≥du
        let displayX = w.y;
        if (xMeasureMode === "diameter") displayX *= 2;

        let coordText;
        if (axisMode === "lathe") {
          coordText = `Z: ${w.x.toFixed(2)} | X: ${displayX.toFixed(2)} mm`;
        } else {
          coordText = `X: ${w.x.toFixed(2)} | Y: ${displayX.toFixed(2)} mm`;
        }
        const coordsEl = document.getElementById("coords");
        if (coordsEl) coordsEl.textContent = coordText;

        // Pokud jsme v m√≥du pan a t√°hneme
        if (mode === "pan" && drawing && lastTouch) {
          // Detekce pohybu
          const dx = sx - panStartPosition.x;
          const dy = sy - panStartPosition.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // Pokud se my≈° pohnula v√≠c ne≈æ 5px, pova≈æujeme to za ta≈æen√≠
          if (distance > 5) {
            panHasMoved = true;
          }

          panX += sx - lastTouch.x;
          panY += sy - lastTouch.y;
          lastTouch = { x: sx, y: sy };
          draw();
          return;
        }

        // Vykreslov√°n√≠ n√°hledu (ghosting) p≈ôi klik-klik metodƒõ
        if (startPt) {
          if (mode === "line") {
            let endX = w.x;
            let endY = w.y;

            // Ortogon√°ln√≠ p≈ôichycen√≠ (vodorovn√©/svisl√© ƒç√°ry)
            if (orthoMode) {
              const dx = Math.abs(endX - startPt.x);
              const dy = Math.abs(endY - startPt.y);

              // Pokud je ƒç√°ra skoro vodorovn√° nebo svisl√° (tolerance 1.5¬∞)
              const angle = (Math.atan2(dy, dx) * 180) / Math.PI;

              if (angle < 1.5 || angle > 178.5) {
                // Vodorovn√° ƒç√°ra
                endY = startPt.y;
              } else if (angle > 88.5 && angle < 91.5) {
                // Svisl√° ƒç√°ra
                endX = startPt.x;
              }
            }

            // Pol√°rn√≠ p≈ôichycen√≠
            let isSnapped = false;
            if (polarSnapEnabled) {
              const dx = endX - startPt.x;
              const dy = endY - startPt.y;
              let angle = (Math.atan2(dy, dx) * 180) / Math.PI;
              if (angle < 0) angle += 360;

              const snappedAngle = snapToPolarAngle(angle);

              if (snappedAngle !== angle) {
                const distance = Math.sqrt(dx * dx + dy * dy);
                const radians = (snappedAngle * Math.PI) / 180;
                endX = startPt.x + distance * Math.cos(radians);
                endY = startPt.y + distance * Math.sin(radians);
                isSnapped = true;
              }
            }

            tempShape = {
              type: "line",
              x1: startPt.x,
              y1: startPt.y,
              x2: endX,
              y2: endY,
              ortho: endX === startPt.x || endY === startPt.y,
              isSnapped: isSnapped,
            };
            draw();
          } else if (mode === "circle") {
            const r = Math.sqrt(
              (w.x - startPt.x) ** 2 + (w.y - startPt.y) ** 2
            );
            tempShape = { type: "circle", cx: startPt.x, cy: startPt.y, r };
            draw();
          }
        }
      });

      canvas.addEventListener("pointerup", (e) => {
        // Zru≈°it timeout a skr√Ωt touch cursor
        if (touchCursorTimeout) {
          clearTimeout(touchCursorTimeout);
          touchCursorTimeout = null;
        }
        hideTouchCursor();

        // === PAN MODE: Pokud se my≈° nepohnula, jde o kliknut√≠ ‚Üí SELECT ===
        if (mode === "pan" && !panHasMoved && panStartPosition) {
          // U≈æivatel jen kliknul, ne≈•ahal ‚Üí oznaƒçit objekt
          const rect = canvas.getBoundingClientRect();
          const sx = e.clientX - rect.left;
          const sy = e.clientY - rect.top;

          let adjustedPos = getTouchCursorPosition(sx, sy);
          let w = screenToWorld(adjustedPos.x, adjustedPos.y);
          let snapResult = snapPoint(w);

          let hitFound = false;

          // 1. Zkusit vybrat bod (priorita) - snapnut√Ω bod
          if (snapResult.snapInfo && snapResult.snapInfo.type !== "grid") {
            toggleSelection({
              category: "point",
              type: snapResult.snapInfo.type,
              x: snapResult.snapInfo.x,
              y: snapResult.snapInfo.y,
            });
            hitFound = true;
          }

          // 2. Pokud nen√≠ bod, zkusit vybrat tvar (ƒç√°ra/kru≈ænice)
          if (!hitFound) {
            const rawW = screenToWorld(sx, sy);

            for (let s of shapes) {
              let hit = false;
              if (s.type === "line") {
                const dx = s.x2 - s.x1;
                const dy = s.y2 - s.y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                const dist =
                  Math.abs((rawW.y - s.y1) * dx - (rawW.x - s.x1) * dy) / len;
                if (dist < 10 / zoom) hit = true;
              } else if (s.type === "circle") {
                const dist = Math.sqrt(
                  (rawW.x - s.cx) ** 2 + (rawW.y - s.cy) ** 2
                );
                if (Math.abs(dist - s.r) < 10 / zoom) hit = true;
              }

              if (hit) {
                toggleSelection({
                  category: "shape",
                  type: s.type,
                  ref: s,
                });
                hitFound = true;
                break;
              }
            }
          }

          draw(); // P≈ôekreslit pro zobrazen√≠ v√Ωbƒõru
        }

        // Pouze pro Pan ukonƒçujeme drag
        if (mode === "pan") {
          drawing = false;
          lastTouch = null;
          panStartPosition = null;
          panHasMoved = false;
        }
        // Pro Line/Circle se nic nedƒõje na up, v≈°e ≈ôe≈°√≠ click (pointerdown)
      });

      canvas.addEventListener("pointercancel", (e) => {
        // Zru≈°it touch cursor p≈ôi p≈ôeru≈°en√≠ (nap≈ô. scroll, gesture)
        if (touchCursorTimeout) {
          clearTimeout(touchCursorTimeout);
          touchCursorTimeout = null;
        }
        hideTouchCursor();
      });

      canvas.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const mx = e.clientX - rect.left;
          const my = e.clientY - rect.top;
          const before = screenToWorld(mx, my);

          zoom *= e.deltaY < 0 ? 1.1 : 0.9;
          zoom = Math.max(0.1, Math.min(100, zoom));

          const after = screenToWorld(mx, my);
          panX += (after.x - before.x) * zoom;
          panY -= (after.y - before.y) * zoom;

          draw();
        },
        { passive: false }
      );

      let touches = [];
      canvas.addEventListener(
        "touchstart",
        (e) => {
          touches = Array.from(e.touches);
          if (touches.length === 2) {
            e.preventDefault();
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            lastDist = Math.sqrt(dx * dx + dy * dy);
          }
        },
        { passive: false }
      );

      canvas.addEventListener(
        "touchmove",
        (e) => {
          if (e.touches.length === 2) {
            e.preventDefault();
            const t = Array.from(e.touches);
            const dx = t[0].clientX - t[1].clientX;
            const dy = t[0].clientY - t[1].clientY;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (lastDist > 0) {
              const rect = canvas.getBoundingClientRect();
              const cx = (t[0].clientX + t[1].clientX) / 2 - rect.left;
              const cy = (t[0].clientY + t[1].clientY) / 2 - rect.top;
              const before = screenToWorld(cx, cy);

              zoom *= dist > lastDist ? 1.02 : 0.98;
              zoom = Math.max(0.1, Math.min(100, zoom));

              const after = screenToWorld(cx, cy);
              panX += (after.x - before.x) * zoom;
              panY -= (after.y - before.y) * zoom;

              draw();
            }
            lastDist = dist;
          }
        },
        { passive: false }
      );

      canvas.addEventListener("touchend", (e) => {
        lastDist = 0;
      });

      window.addEventListener("load", () => {
        init();
        updateCoordinateLabels();
      });
      window.addEventListener("resize", init);

      // Kl√°vesov√© zkratky
      window.addEventListener("keydown", (e) => {
        // ESC - Zru≈°it aktu√°ln√≠ m√≥d
        if (e.key === "Escape") {
          e.preventDefault();
          clearMode();
        }

        // Align mode: Z = zarovnat vodorovnƒõ (Z osa), X = zarovnat svisle (X osa)
        if (mode === "align" && alignStep === 3) {
          if (e.key.toLowerCase() === "z") {
            e.preventDefault();
            // Zarovnat na osu Z (vodorovnƒõ) - v≈°echny Y sou≈ôadnice se vyrovnaj√≠ na Y poƒç√°tku
            const targetY = alignRefPoint.y;
            const angle = Math.atan2(
              alignLine.y2 - alignLine.y1,
              alignLine.x2 - alignLine.x1
            );

            // Otoƒçit √∫seƒçku aby byla vodorovn√° a posunout
            for (let s of shapes) {
              if (s.type === "line") {
                // Rotace kolem referenƒçn√≠ho bodu
                const dx1 = s.x1 - alignRefPoint.x;
                const dy1 = s.y1 - alignRefPoint.y;
                const dx2 = s.x2 - alignRefPoint.x;
                const dy2 = s.y2 - alignRefPoint.y;

                const rot1x = dx1 * Math.cos(-angle) - dy1 * Math.sin(-angle);
                const rot1y = dx1 * Math.sin(-angle) + dy1 * Math.cos(-angle);
                const rot2x = dx2 * Math.cos(-angle) - dy2 * Math.sin(-angle);
                const rot2y = dx2 * Math.sin(-angle) + dy2 * Math.cos(-angle);

                s.x1 = alignRefPoint.x + rot1x;
                s.y1 = alignRefPoint.y; // Y na c√≠lov√Ω bod
                s.x2 = alignRefPoint.x + rot2x;
                s.y2 = alignRefPoint.y;
              } else if (s.type === "point") {
                const dx = s.x - alignRefPoint.x;
                const dy = s.y - alignRefPoint.y;
                const rotx = dx * Math.cos(-angle) - dy * Math.sin(-angle);
                const roty = dx * Math.sin(-angle) + dy * Math.cos(-angle);
                s.x = alignRefPoint.x + rotx;
                s.y = alignRefPoint.y;
              } else if (s.type === "circle") {
                const dx = s.cx - alignRefPoint.x;
                const dy = s.cy - alignRefPoint.y;
                const rotx = dx * Math.cos(-angle) - dy * Math.sin(-angle);
                const roty = dx * Math.sin(-angle) + dy * Math.cos(-angle);
                s.cx = alignRefPoint.x + rotx;
                s.cy = alignRefPoint.y;
              }
            }

            for (let p of points) {
              const dx = p.x - alignRefPoint.x;
              const dy = p.y - alignRefPoint.y;
              const rotx = dx * Math.cos(-angle) - dy * Math.sin(-angle);
              const roty = dx * Math.sin(-angle) + dy * Math.cos(-angle);
              p.x = alignRefPoint.x + rotx;
              p.y = alignRefPoint.y;
            }

            saveState();
            updateSnapPoints();
            draw();
            clearMode();
            alert("‚úÖ Zarovn√°no na osu Z (vodorovnƒõ)");
          } else if (e.key.toLowerCase() === "x") {
            e.preventDefault();
            // Zarovnat na osu X (svisle) - v≈°echny X sou≈ôadnice se vyrovnaj√≠ na X poƒç√°tku
            const targetX = alignRefPoint.x;
            const angle = Math.atan2(
              alignLine.y2 - alignLine.y1,
              alignLine.x2 - alignLine.x1
            );

            // Otoƒçit √∫seƒçku aby byla svisl√° a posunout
            for (let s of shapes) {
              if (s.type === "line") {
                // Rotace kolem referenƒçn√≠ho bodu
                const dx1 = s.x1 - alignRefPoint.x;
                const dy1 = s.y1 - alignRefPoint.y;
                const dx2 = s.x2 - alignRefPoint.x;
                const dy2 = s.y2 - alignRefPoint.y;

                const rot1x =
                  dx1 * Math.cos(-angle - Math.PI / 2) -
                  dy1 * Math.sin(-angle - Math.PI / 2);
                const rot1y =
                  dx1 * Math.sin(-angle - Math.PI / 2) +
                  dy1 * Math.cos(-angle - Math.PI / 2);
                const rot2x =
                  dx2 * Math.cos(-angle - Math.PI / 2) -
                  dy2 * Math.sin(-angle - Math.PI / 2);
                const rot2y =
                  dx2 * Math.sin(-angle - Math.PI / 2) +
                  dy2 * Math.cos(-angle - Math.PI / 2);

                s.x1 = alignRefPoint.x; // X na c√≠lov√Ω bod
                s.y1 = alignRefPoint.y + rot1y;
                s.x2 = alignRefPoint.x;
                s.y2 = alignRefPoint.y + rot2y;
              } else if (s.type === "point") {
                const dx = s.x - alignRefPoint.x;
                const dy = s.y - alignRefPoint.y;
                const rotx =
                  dx * Math.cos(-angle - Math.PI / 2) -
                  dy * Math.sin(-angle - Math.PI / 2);
                const roty =
                  dx * Math.sin(-angle - Math.PI / 2) +
                  dy * Math.cos(-angle - Math.PI / 2);
                s.x = alignRefPoint.x;
                s.y = alignRefPoint.y + roty;
              } else if (s.type === "circle") {
                const dx = s.cx - alignRefPoint.x;
                const dy = s.cy - alignRefPoint.y;
                const rotx =
                  dx * Math.cos(-angle - Math.PI / 2) -
                  dy * Math.sin(-angle - Math.PI / 2);
                const roty =
                  dx * Math.sin(-angle - Math.PI / 2) +
                  dy * Math.cos(-angle - Math.PI / 2);
                s.cx = alignRefPoint.x;
                s.cy = alignRefPoint.y + roty;
              }
            }

            for (let p of points) {
              const dx = p.x - alignRefPoint.x;
              const dy = p.y - alignRefPoint.y;
              const rotx =
                dx * Math.cos(-angle - Math.PI / 2) -
                dy * Math.sin(-angle - Math.PI / 2);
              const roty =
                dx * Math.sin(-angle - Math.PI / 2) +
                dy * Math.cos(-angle - Math.PI / 2);
              p.x = alignRefPoint.x;
              p.y = alignRefPoint.y + roty;
            }

            saveState();
            updateSnapPoints();
            draw();
            clearMode();
            alert("‚úÖ Zarovn√°no na osu X (svisle)");
          }
        }

        // Ctrl+S nebo Cmd+S - Ulo≈æit projekt
        if ((e.ctrlKey || e.metaKey) && e.key === "s") {
          e.preventDefault();
          saveProject();
        }

        // Ctrl+O nebo Cmd+O - Otev≈ô√≠t projekt
        if ((e.ctrlKey || e.metaKey) && e.key === "o") {
          e.preventDefault();
          document.getElementById("loadProjectInput").click();
        }

        // Ctrl+Z nebo Cmd+Z - Zpƒõt (Undo)
        if ((e.ctrlKey || e.metaKey) && e.key === "z" && !e.shiftKey) {
          e.preventDefault();
          undo();
        }

        // Ctrl+Y nebo Ctrl+Shift+Z nebo Cmd+Shift+Z - Vp≈ôed (Redo)
        if (
          (e.ctrlKey || e.metaKey) &&
          (e.key === "y" || (e.key === "z" && e.shiftKey))
        ) {
          e.preventDefault();
          redo();
        }
      });
<<<<<<< HEAD

      // === IMPORT Z SIMDXF JSON ===
      function importSimDxfProject(input) {
        const file = input.files[0];
        if (!file) return;

        // Zkontrolovat p≈ô√≠ponu
        if (!file.name.endsWith(".json")) {
          alert("‚ùå Chyba: M≈Ø≈æe≈° naƒç√≠st pouze .json soubory!");
          input.value = "";
          return;
        }

        const reader = new FileReader();

        reader.onload = function (e) {
          try {
            const simDxfData = JSON.parse(e.target.result);

            // Validace struktury SimDxf JSON
            if (!simDxfData.points || !Array.isArray(simDxfData.points)) {
              throw new Error(
                "Neplatn√Ω form√°t SimDxf - chyb√≠ pole points"
              );
            }

            // Potvrdit import (pokud u≈æ nƒõco nakreslen√©ho)
            if (shapes.length > 0 || points.length > 0) {
              const confirm = window.confirm(
                "‚ö†Ô∏è Importem z SimDxf p≈ôep√≠≈°e≈° aktu√°ln√≠ kreslen√≠.\n\n" +
                  "Chce≈° pokraƒçovat?"
              );
              if (!confirm) {
                input.value = "";
                return;
              }
            }

            // Konvertovat SimDxf na 2D_AI form√°t
            const converted = convertSimDxfToShapes(simDxfData);

            // Vyƒçistit st√°vaj√≠c√≠ kreslen√≠
            shapes.length = 0;
            points.length = 0;

            // Naƒç√≠st konvertovan√° data
            shapes.push(...converted.shapes);
            points.push(...converted.points);

            // Nastavit poƒç√°tek (Auto-Zero)
            // Pokud m√° SimDxf nastaveno, respektujeme to
            if (simDxfData.machineType) {
              // Informaƒçn√≠ zpr√°va
              const modeInfo = document.getElementById("modeInfo");
              if (modeInfo) {
                modeInfo.textContent = `üì• Import z SimDxf: ${simDxfData.machineType || "Import"}`;
                modeInfo.classList.add("show");
                setTimeout(() => {
                  modeInfo.classList.remove("show");
                }, 3000);
              }
            }

            // Vykreslen√≠
            fitCanvasToShapes();
            draw();

            // Resetovat file input
            input.value = "";
          } catch (error) {
            alert(`‚ùå Chyba p≈ôi importu: ${error.message}`);
            input.value = "";
            console.error(error);
          }
        };

        reader.readAsText(file);
      }

      function convertSimDxfToShapes(simDxfData) {
        const newShapes = [];
        const newPoints = [];
        const processedPoints = {};

        // SimDxf form√°t:
        // points: [{ x (Z-osa), z (X-osa), type, break, id, r, cx, cz, cw }, ...]
        // 2D_AI form√°t:
        // shapes: [{ type: "line", x1, y1, x2, y2 }, ...]

        const pointsList = simDxfData.points || [];

        for (let i = 0; i < pointsList.length; i++) {
          const current = pointsList[i];
          const next = pointsList[i + 1];

          // Konverze sou≈ôadnic: SimDxf (x=Z, z=X) ‚Üí 2D_AI (x=X, y=Y/Z)
          // x v SimDxf (Z-osa) ‚Üí x v 2D_AI
          // z v SimDxf (X/radial) ‚Üí y v 2D_AI
          const x1 = convertCoordinate(current.x, "z");
          const y1 = convertCoordinate(current.z, "x");

          // Pokud existuje p≈ôestup (break flag), p≈ôid√°me bod
          if (current.break) {
            newPoints.push({ type: "point", x: x1, y: y1, id: `simDxf_${current.id}` });
          }

          if (!next) continue; // Posledn√≠ bod

          const x2 = convertCoordinate(next.x, "z");
          const y2 = convertCoordinate(next.z, "x");

          // Zpracov√°n√≠ podle typu
          if (current.type === "arc" && current.r !== undefined) {
            // Arc - konvertujeme na kruh (aproximace)
            // Center: cx (Z) ‚Üí x, cz (X) ‚Üí y
            // Polomƒõr: r z≈Øst√°v√° stejn√Ω
            const cx = convertCoordinate(current.cx, "z");
            const cy = convertCoordinate(current.cz, "x");
            const r = Math.abs(current.r);

            newShapes.push({
              type: "circle",
              cx: cx,
              cy: cy,
              r: r,
              id: `simDxf_arc_${current.id}`,
            });
          } else {
            // Line - p≈ô√≠mka
            newShapes.push({
              type: "line",
              x1: x1,
              y1: y1,
              x2: x2,
              y2: y2,
              id: `simDxf_line_${current.id}`,
            });
          }
        }

        return { shapes: newShapes, points: newPoints };
      }

      function convertCoordinate(value, axis) {
        // Jednoduch√© mapov√°n√≠ sou≈ôadnic
        // SimDxf sou≈ôadnice jsou v mm (typicky 0-100+)
        // Vra≈•√≠me jako je (bez zmƒõny mƒõ≈ô√≠tka)
        return parseFloat(value) || 0;
      }

      function fitCanvasToShapes() {
        // Pokud m√°me nƒõjak√© tvary, p≈ôizp≈Øsob√≠me canvas na jejich velikost
        if (shapes.length === 0) {
          zoom = 1;
          panX = canvas.width / 2;
          panY = canvas.height / 2;
          return;
        }

        let minX = Infinity,
          maxX = -Infinity,
          minY = Infinity,
          maxY = -Infinity;

        // Naj√≠t hranice v≈°ech tvar≈Ø
        for (const shape of shapes) {
          if (shape.type === "line") {
            minX = Math.min(minX, shape.x1, shape.x2);
            maxX = Math.max(maxX, shape.x1, shape.x2);
            minY = Math.min(minY, shape.y1, shape.y2);
            maxY = Math.max(maxY, shape.y1, shape.y2);
          } else if (shape.type === "circle") {
            minX = Math.min(minX, shape.cx - shape.r);
            maxX = Math.max(maxX, shape.cx + shape.r);
            minY = Math.min(minY, shape.cy - shape.r);
            maxY = Math.max(maxY, shape.cy + shape.r);
          } else if (shape.type === "point") {
            minX = Math.min(minX, shape.x);
            maxX = Math.max(maxX, shape.x);
            minY = Math.min(minY, shape.y);
            maxY = Math.max(maxY, shape.y);
          }
        }

        // P≈ôidat margini
        const width = maxX - minX || 100;
        const height = maxY - minY || 100;
        const margin = 50;

        // Vypoƒç√≠tat zoom aby se ve≈°lo
        const zoomX = (canvas.width - 2 * margin) / width;
        const zoomY = (canvas.height - 2 * margin) / height;
        zoom = Math.min(zoomX, zoomY, 5);

        // Vykreslit na st≈ôed
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        panX = canvas.width / 2 - centerX * zoom;
        panY = canvas.height / 2 - centerY * zoom;
      }
    </script>
  </body>
</html>
=======
    </script>
  </body>
</html>


>>>>>>> e52642107a8edc8ab34a98eec0d608b52fdb2926
