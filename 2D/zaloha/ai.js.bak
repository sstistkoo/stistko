/**
 * AI.JS - Google Gemini AI integration
 * - Chat interface and prompts
 * - AI memory system
 * - API integration
 * - Usage tracking
 */

// GlobÃ¡lnÃ­ promÄ›nnÃ© jsou inicializovÃ¡ny v globals.js

// API Usage Stats
let apiUsageStats = {
  totalCalls: 0,
  totalTokensIn: 0,
  totalTokensOut: 0,
  dailyCalls: 0,
  lastReset: new Date().toISOString(),
};

// Inicializuj API stats na zaÄÃ¡tku
document.addEventListener("DOMContentLoaded", () => {
  loadApiStats();
  updateApiUsageUI();
});

// Enable dragging of AI panel
// Prevent duplicate event listeners
let aiDraggingEnabled = false;

window.enableAIDragging = function () {
  // ZabrÃ¡nit duplicitnÃ­m event listenerÅ¯m
  if (aiDraggingEnabled) return;

  const toolsAi = document.getElementById('toolsAi');
  const panel = document.getElementById('aiPanel');
  const header = document.getElementById('aiHeaderRow');
  if (!panel || !header || !toolsAi) return;

  aiDraggingEnabled = true;

  // Detekce mobilnÃ­ho zaÅ™Ã­zenÃ­
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;

  // Na mobilnÃ­ch zaÅ™Ã­zenÃ­ch zakÃ¡zat dragging a nastavit pevnou pozici
  if (isMobile) {
    // Odstranit cursor: move a nastavit pevnou pozici
    header.style.cursor = 'default';
    panel.style.position = 'fixed';
    panel.style.top = '10px';
    panel.style.bottom = '15px';
    panel.style.left = '50%';
    panel.style.transform = 'translateX(-50%)';
    panel.style.right = 'auto';
    panel.style.width = '96%';
    panel.style.maxWidth = '100%';
    panel.style.maxHeight = 'calc(100vh - 25px)';
    panel.style.height = 'auto';
    panel.style.overflowY = 'auto';
    panel.style.webkitOverflowScrolling = 'touch';
    panel.style.zIndex = '3001';

    // Zajistit Å¾e overlay mÃ¡ takÃ© vysokÃ½ z-index
    if (toolsAi) {
      toolsAi.style.zIndex = '3000';
      toolsAi.style.background = 'rgba(0, 0, 0, 0.85)';
    }

    return; // Vypnout dragging na mobilech
  }

  // Restore saved position jen na desktopu
  try {
    const saved = localStorage.getItem('aiPanelPosition');
    if (saved) {
      const pos = JSON.parse(saved);
      if (pos.left) panel.style.left = pos.left;
      if (pos.top) panel.style.top = pos.top;
      panel.style.right = 'auto';
      panel.style.transform = 'none'; // DÅ¯leÅ¾itÃ©: zruÅ¡it translateX(-50%)
    }
  } catch (e) {}

  let dragging = false;
  let startX = 0, startY = 0, origX = 0, origY = 0;

  const onStart = (clientX, clientY) => {
    const rect = panel.getBoundingClientRect();
    dragging = true;
    startX = clientX;
    startY = clientY;
    origX = rect.left;
    origY = rect.top;
    document.body.style.userSelect = 'none';
    // PÅ™i zaÄÃ¡tku pÅ™etahovÃ¡nÃ­ zruÅ¡it transform pro pÅ™esnÃ© pozicovÃ¡nÃ­
    panel.style.transform = 'none';
  };

  const onMove = (clientX, clientY) => {
    if (!dragging) return;
    const dx = clientX - startX;
    const dy = clientY - startY;
    panel.style.left = (origX + dx) + 'px';
    panel.style.top = (origY + dy) + 'px';
    panel.style.right = 'auto';
    panel.style.transform = 'none'; // Zajistit Å¾e transform je vypnutÃ½
  };

  const onEnd = () => {
    if (!dragging) return;
    dragging = false;
    document.body.style.userSelect = '';
    try {
      localStorage.setItem('aiPanelPosition', JSON.stringify({
        left: panel.style.left,
        top: panel.style.top,
        transform: 'none' // UloÅ¾it info Å¾e panel byl pÅ™esunut
      }));
    } catch (e) {}
  };

  // Kontrola zda cÃ­l nenÃ­ interaktivnÃ­ prvek
  const isInteractive = (el) => {
    const tag = el.tagName.toLowerCase();
    return tag === 'select' || tag === 'button' || tag === 'input' || tag === 'textarea' || tag === 'a' || el.closest('select, button, input, textarea, a');
  };

  header.addEventListener('mousedown', (e) => {
    if (isInteractive(e.target)) return; // Nekreslit pÅ™i kliknutÃ­ na interaktivnÃ­ prvky
    onStart(e.clientX, e.clientY);
  });
  document.addEventListener('mousemove', (e) => { onMove(e.clientX, e.clientY); });
  document.addEventListener('mouseup', onEnd);

  // Touch support - pouze na desktopu
  header.addEventListener('touchstart', (e) => {
    if (isInteractive(e.target)) return;
    const t = e.touches[0];
    onStart(t.clientX, t.clientY);
  }, { passive: true });
  document.addEventListener('touchmove', (e) => { const t = e.touches[0]; if (t) onMove(t.clientX, t.clientY); }, { passive: false });
  document.addEventListener('touchend', onEnd);
};

document.addEventListener('DOMContentLoaded', () => {
  try { window.enableAIDragging(); } catch (e) { console.warn('enableAIDragging failed', e); }
});

// Inicializuj request timestamps
window.requestTimestamps = (() => {
  try {
    const stored = localStorage.getItem("ai_request_timestamps");
    if (stored) {
      const timestamps = JSON.parse(stored);
      const now = Date.now();
      return timestamps.filter(ts => now - ts < 60000);
    }
  } catch (e) {}
  return [];
})();

// UloÅ¾ timestamps do localStorage
window.saveRequestTimestamps = function() {
  try {
    localStorage.setItem("ai_request_timestamps", JSON.stringify(window.requestTimestamps));
  } catch (e) {
    console.warn("âš ï¸ Nelze uloÅ¾it timestamps:", e);
  }
};

// UloÅ¾ API stats
function saveApiStats() {
  try {
    localStorage.setItem("api_usage_stats", JSON.stringify(apiUsageStats));
    updateApiUsageUI();
  } catch (e) {
    console.warn("âš ï¸ Nelze uloÅ¾it API stats:", e);
  }
}

// NaÄti API stats
function loadApiStats() {
  const stored = localStorage.getItem("api_usage_stats");
  if (stored) {
    try {
      apiUsageStats = JSON.parse(stored);
      checkAndResetDailyStats();
    } catch (e) {
      console.warn("Could not parse API stats", e);
    }
  }
  scheduleMidnightReset();
}

// Zkontroluj a resetuj dennÃ­ statistiky
function checkAndResetDailyStats() {
  const lastResetDate = new Date(apiUsageStats.lastReset);
  const today = new Date();

  if (
    lastResetDate.getDate() !== today.getDate() ||
    lastResetDate.getMonth() !== today.getMonth() ||
    lastResetDate.getFullYear() !== today.getFullYear()
  ) {
    console.log("ğŸ”„ NovÃ½ den - resetuji dennÃ­ statistiky");
    apiUsageStats.dailyCalls = 0;
    apiUsageStats.lastReset = new Date().toISOString();
    saveApiStats();
  }
}

// NaplÃ¡nuj reset v 10:00
function scheduleMidnightReset() {
  const now = new Date();
  const resetTime = new Date(now);
  resetTime.setHours(10, 0, 0, 0);

  if (resetTime <= now) {
    resetTime.setDate(resetTime.getDate() + 1);
  }

  const timeUntilReset = resetTime - now;

  setTimeout(() => {
    console.log("ğŸŒ… 10:00 - resetuji dennÃ­ limit API");
    apiUsageStats.dailyCalls = 0;
    apiUsageStats.lastReset = new Date().toISOString();
    saveApiStats();
    updateApiUsageUI();
    scheduleMidnightReset();
  }, timeUntilReset);
}

// VymazÃ¡nÃ­ AI chatu
window.clearAIChat = function () {
  const modal = document.getElementById('clearChatModal');
  if (modal) {
    modal.classList.remove('d-none');
    modal.style.display = 'flex';
  }
};

window.confirmClearChat = function() {
  const chatWindow = document.getElementById('chatWindow');
  if (chatWindow) {
    chatWindow.innerHTML = '';
    chatWindow.style.display = 'none';
  }
  window.closeClearChatModal();
};

window.closeClearChatModal = function() {
  const modal = document.getElementById('clearChatModal');
  if (modal) {
    modal.style.display = 'none';
    modal.classList.add('d-none');
  }
};

// Aktualizuj UI s API stats
function updateApiUsageUI() {
  const usage = document.getElementById("apiUsageInfo");
  if (!usage) return;

  const apiCallsCount = window.requestTimestamps?.length || 0;
  const API_FREE_LIMIT = window.getCurrentModelLimit?.() || 15;

  // Zjisti aktuÃ¡lnÃ­ho providera
  const providerSelect = document.getElementById("aiProviderSelect");
  const provider = providerSelect?.value || "gemini";

  let keyName = "Å½Ã¡dnÃ½ klÃ­Ä";
  let providerIcon = "ğŸ¤–";

  if (provider === "groq") {
    keyName = window.getCurrentGroqApiKeyName?.() || "Å½Ã¡dnÃ½ Groq klÃ­Ä";
    providerIcon = "âš¡";
  } else {
    keyName = window.getCurrentApiKeyName?.() || "Å½Ã¡dnÃ½ klÃ­Ä";
    providerIcon = "ğŸ¤–";
  }

  const percentage = Math.round((apiCallsCount / API_FREE_LIMIT) * 100);
  const color =
    apiCallsCount >= API_FREE_LIMIT
      ? "#ff4444"
      : apiCallsCount > 10
      ? "#ff9900"
      : "#44ff44";

  usage.innerHTML = `
    <div style="font-size: 10px; color: #aaa; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 4px;">
      <span>ğŸ”‘ ${keyName}</span>
      <span style="color: ${color}; font-weight: bold">${apiCallsCount}/${API_FREE_LIMIT}</span>
      <span style="color: #666;">Dnes: ${apiUsageStats.dailyCalls || 0} | Celkem: ${apiUsageStats.totalCalls}</span>
    </div>
  `;
}

// ZruÅ¡ aktuÃ¡lnÃ­ AI request
window.cancelAIRequest = function() {
  window.processingAI = false;

  const promptInput = document.getElementById("aiPrompt");
  const btnCancel = document.getElementById("btnCancel");
  const btnGenerate = document.getElementById("btnGenerate");

  if (promptInput) promptInput.disabled = false;
  if (btnCancel) btnCancel.style.display = "none";
  if (btnGenerate) btnGenerate.style.display = "inline-block";

  const container = document.getElementById("aiChatHistory");
  if (container) {
    const loadingDivs = container.querySelectorAll("div[style*='loading-dots']");
    loadingDivs.forEach(div => div.remove());

    const cancelMsg = document.createElement("div");
    cancelMsg.className = "chat-msg model";
    cancelMsg.style.color = "#ef4444";
    cancelMsg.textContent = "âŒ PoÅ¾adavek zruÅ¡en";
    container.appendChild(cancelMsg);
    container.scrollTop = container.scrollHeight;
  }
};
// Mapy limitÅ¯ pro jednotlivÃ© modely (Requests Per Minute)
window.MODEL_LIMITS = {
  // Gemini models
  "gemini-2.5-flash-lite": { rpm: 15, name: "Gemini 2.5 Flash Lite" },
  "gemini-2.5-flash": { rpm: 10, name: "Gemini 2.5 Flash" },
  "gemini-3-pro-preview": { rpm: 2, name: "Gemini 3 Pro" },
  "gemini-2.0-flash-exp": { rpm: 15, name: "Gemini 2.0 Flash Exp" },

  // Groq models - vyÅ¡Å¡Ã­ limity dÃ­ky rychlosti
  "openai/gpt-oss-120b": { rpm: 30, name: "GPT OSS 120B" },
  "moonshotai/kimi-k2-instruct-0905": { rpm: 30, name: "Kimi K2" },
  "llama-3.3-70b-versatile": { rpm: 30, name: "Llama 3.3 70B" },
  "qwen/qwen3-32b": { rpm: 30, name: "Qwen 3 32B" },
  "openai/gpt-oss-20b": { rpm: 30, name: "GPT OSS 20B" },
  "llama-3.1-8b-instant": { rpm: 30, name: "Llama 3.1 8B" },
  "meta-llama/llama-4-scout-17b-16e-instruct": { rpm: 30, name: "Llama 4 Scout" },
  "meta-llama/llama-4-maverick-17b-128e-instruct": { rpm: 30, name: "Llama 4 Maverick" }
};

// Groq modely s podporou vision
window.GROQ_VISION_MODELS = [
  "meta-llama/llama-4-maverick-17b-128e-instruct",
  "meta-llama/llama-4-scout-17b-16e-instruct"
];

// Aktualizuj modely podle vybranÃ©ho providera
// Podporuje dynamickÃ© naÄÃ­tÃ¡nÃ­ free modelÅ¯ z AI modulu
window.updateModelsForProvider = function() {
  const providerSelect = document.getElementById("aiProviderSelect");
  const modelSelect = document.getElementById("aiModelSelect");

  if (!providerSelect || !modelSelect) return;

  const provider = providerSelect.value;

  // V Auto mÃ³du - pouÅ¾ij loadAutoModeModels
  if (window.aiModelMode === 'auto') {
    if (window.loadAutoModeModels) {
      window.loadAutoModeModels(provider);
    }
    return;
  }

  // V Manual mÃ³du - naÄti FREE modely z API
  if (window.loadManualModeModels) {
    window.loadManualModeModels(provider);
    return;
  }

  // Fallback na statickÃ© modely
  modelSelect.innerHTML = ""; // VyÄisti stÃ¡vajÃ­cÃ­ modely

  // NaÄti enabled modely
  const enabledModels = window.loadEnabledModels ? window.loadEnabledModels() : null;

  // ZÃ­skej modely z AI modulu pokud je dostupnÃ½
  if (typeof AI !== 'undefined' && AI.ALL_MODELS && AI.ALL_MODELS[provider]) {
    const aiModels = AI.ALL_MODELS[provider];
    let firstEnabled = null;

    // PÅ™idej "NaÄÃ­tÃ¡m..." placeholder pokud budeme dynamicky naÄÃ­tat
    if (aiModels.length === 0) {
      const loadingOpt = document.createElement("option");
      loadingOpt.value = "";
      loadingOpt.textContent = "â³ NaÄÃ­tÃ¡m modely...";
      loadingOpt.disabled = true;
      modelSelect.appendChild(loadingOpt);
      return;
    }

    aiModels.forEach(model => {
      if (!enabledModels || enabledModels.has(model.value)) {
        const option = document.createElement("option");
        option.value = model.value;
        // Zobraz FREE tag u free modelÅ¯
        const freeTag = model.free ? ' ğŸ†“' : '';
        const rpmInfo = model.rpm ? ` (${model.rpm} RPM)` : '';
        option.textContent = `${model.name || model.value}${rpmInfo}${freeTag}`;
        modelSelect.appendChild(option);
        if (!firstEnabled) firstEnabled = option;
      }
    });

    if (firstEnabled) firstEnabled.selected = true;

  } else {
    // Fallback na statickÃ© modely pokud AI modul nenÃ­ dostupnÃ½
    window.loadStaticModels(provider, modelSelect, enabledModels);
  }

  // Aktualizuj upload tlaÄÃ­tko viditelnost podle modelu
  if (window.updateImageUploadVisibility) window.updateImageUploadVisibility();

  // Aktualizuj API usage UI
  if (updateApiUsageUI) updateApiUsageUI();
};

// NaÄti dynamickÃ© free modely z AI modulu/API
window.loadDynamicModels = async function(provider, modelSelect) {
  // Zobraz loading stav
  modelSelect.innerHTML = '<option value="" disabled>â³ NaÄÃ­tÃ¡m free modely...</option>';

  try {
    if (typeof AI !== 'undefined') {
      // ZÃ­skej vÅ¡echny modely pro providera
      let models = AI.ALL_MODELS[provider] || [];

      // Filtruj pouze free modely
      const freeModels = models.filter(m => m.free !== false && (m.rpm > 0 || m.free === true));

      if (freeModels.length > 0) {
        modelSelect.innerHTML = '';

        // PÅ™idej header
        const headerOpt = document.createElement("option");
        headerOpt.disabled = true;
        headerOpt.textContent = `â•â•â• FREE MODELY (${freeModels.length}) â•â•â•`;
        headerOpt.style.fontWeight = "bold";
        modelSelect.appendChild(headerOpt);

        freeModels.forEach((model, idx) => {
          const option = document.createElement("option");
          option.value = model.value;
          const qualityIcon = model.quality >= 90 ? 'ğŸ†' : model.quality >= 70 ? 'â­' : 'âš¡';
          option.textContent = `${qualityIcon} ${model.name || model.value} (${model.rpm || '?'} RPM)`;
          modelSelect.appendChild(option);
          if (idx === 0) option.selected = true;
        });

        // Aktualizuj auto info
        const autoModel = document.getElementById('aiAutoModel');
        if (autoModel && freeModels[0]) {
          autoModel.textContent = freeModels[0].name || freeModels[0].value;
        }
      } else {
        // Å½Ã¡dnÃ© free modely
        modelSelect.innerHTML = '<option value="" disabled>âŒ Å½Ã¡dnÃ© free modely</option>';
      }
    }
  } catch (err) {
    console.error('Chyba pÅ™i naÄÃ­tÃ¡nÃ­ dynamickÃ½ch modelÅ¯:', err);
    modelSelect.innerHTML = '<option value="" disabled>âŒ Chyba naÄÃ­tÃ¡nÃ­</option>';
  }

  // Aktualizuj UI
  if (window.updateImageUploadVisibility) window.updateImageUploadVisibility();
  if (updateApiUsageUI) updateApiUsageUI();
};

// Fallback - statickÃ© modely
window.loadStaticModels = function(provider, modelSelect, enabledModels) {
  if (provider === "gemini") {
    // Gemini modely
    const geminiModels = [
      { value: "gemini-2.5-flash-lite", label: "âš¡ Gemini 2.5 Flash-Lite (VyÅ¡Å¡Ã­ limit) ğŸ†“" },
      { value: "gemini-2.5-flash", label: "âš¡ Gemini 2.5 Flash (RychlÃ½) ğŸ†“" },
      { value: "gemini-3-pro-preview", label: "ğŸ§ª Gemini 3 Pro (NejchytÅ™ejÅ¡Ã­)" },
      { value: "gemini-2.0-flash-exp", label: "âš¡ Gemini 2.0 Flash (Exp) ğŸ†“" }
    ];

    let firstEnabled = null;
    geminiModels.forEach(model => {
      // Filtruj pouze enabled modely
      if (!enabledModels || enabledModels.has(model.value)) {
        const option = document.createElement("option");
        option.value = model.value;
        option.textContent = model.label;
        modelSelect.appendChild(option);
        if (!firstEnabled) firstEnabled = option;
      }
    });
    if (firstEnabled) firstEnabled.selected = true;

  } else if (provider === "groq") {
    // Groq modely - organizovanÃ© do skupin
    const groqModels = [
      { label: "â•â•â• NEJCHYTÅ˜EJÅ Ã â•â•â•", disabled: true },
      { value: "openai/gpt-oss-120b", label: "ğŸ§  GPT OSS 120B (~500 tok/s)" },
      { value: "moonshotai/kimi-k2-instruct-0905", label: "ğŸ§  Kimi K2 (256K kontext)" },

      { label: "â•â•â• CHAT â•â•â•", disabled: true },
      { value: "llama-3.3-70b-versatile", label: "ğŸ’¬ Llama 3.3 70B (nejlepÅ¡Ã­ pro chat)" },
      { value: "qwen/qwen3-32b", label: "ğŸ’» Qwen 3 32B (silnÃ½ na kÃ³d)" },

      { label: "â•â•â• RYCHLÃ‰ â•â•â•", disabled: true },
      { value: "openai/gpt-oss-20b", label: "âš¡ GPT OSS 20B (~1000 tok/s)" },
      { value: "llama-3.1-8b-instant", label: "âš¡ Llama 3.1 8B (~560 tok/s)" },
      { value: "meta-llama/llama-4-scout-17b-16e-instruct", label: "âš¡ Llama 4 Scout (~750 tok/s)" },

      { label: "â•â•â• VISION / OCR â•â•â•", disabled: true },
      { value: "meta-llama/llama-4-maverick-17b-128e-instruct", label: "ğŸ‘ï¸ Llama 4 Maverick (Vision)" },
      { value: "meta-llama/llama-4-scout-17b-16e-instruct", label: "ğŸ‘ï¸ Llama 4 Scout (Vision)" }
    ];

    let firstEnabled = null;
    let currentGroup = null;
    groqModels.forEach((model) => {
      if (model.disabled) {
        currentGroup = model.label; // Pamatuj si nÃ¡zev skupiny
      } else {
        // Filtruj pouze enabled modely
        if (!enabledModels || enabledModels.has(model.value)) {
          // Pokud je to prvnÃ­ model ve skupinÄ›, pÅ™idej header
          if (currentGroup) {
            const groupOption = document.createElement("option");
            groupOption.disabled = true;
            groupOption.textContent = currentGroup;
            groupOption.style.fontWeight = "bold";
            groupOption.style.background = "#1a1a1a";
            modelSelect.appendChild(groupOption);
            currentGroup = null; // Reset aby se nepÅ™idal vÃ­cekrÃ¡t
          }

          const option = document.createElement("option");
          option.value = model.value;
          option.textContent = model.label;
          modelSelect.appendChild(option);
          if (!firstEnabled) firstEnabled = option;
        }
      }
    });
    if (firstEnabled) firstEnabled.selected = true;

  } else if (provider === "openrouter") {
    // OpenRouter modely - FREE verze
    const openrouterModels = [
      { value: "google/gemini-2.0-flash-exp:free", label: "âš¡ Gemini 2.0 Flash :free" },
      { value: "meta-llama/llama-3.3-70b-instruct:free", label: "ğŸ¦™ Llama 3.3 70B :free" },
      { value: "mistralai/mistral-small-3.1-24b-instruct:free", label: "ğŸ”¥ Mistral Small 3.1 :free" },
      { value: "deepseek/deepseek-r1:free", label: "ğŸ§  DeepSeek R1 (reasoning) :free" },
      { value: "google/gemma-3-27b-it:free", label: "âš¡ Google Gemma 3 27B :free" }
    ];

    let firstEnabled = null;
    openrouterModels.forEach((model) => {
      // Filtruj pouze enabled modely
      if (!enabledModels || enabledModels.has(model.value)) {
        const option = document.createElement("option");
        option.value = model.value;
        option.textContent = model.label;
        modelSelect.appendChild(option);
        if (!firstEnabled) firstEnabled = option;
      }
    });
    if (firstEnabled) firstEnabled.selected = true;

  } else if (provider === "mistral") {
    // Mistral modely
    const mistralModels = [
      { value: "codestral-latest", label: "ğŸ’» Codestral (specializovanÃ½ na kÃ³d)" },
      { value: "mistral-small-latest", label: "âš¡ Mistral Small (rychlÃ½, vÅ¡estrannÃ½)" }
    ];

    let firstEnabled = null;
    mistralModels.forEach((model) => {
      // Filtruj pouze enabled modely
      if (!enabledModels || enabledModels.has(model.value)) {
        const option = document.createElement("option");
        option.value = model.value;
        option.textContent = model.label;
        modelSelect.appendChild(option);
        if (!firstEnabled) firstEnabled = option;
      }
    });
    if (firstEnabled) firstEnabled.selected = true;
  }
}; // Konec loadStaticModels

// Zobraz/skryj upload obrÃ¡zkÅ¯ podle modelu
window.updateImageUploadVisibility = function() {
  const providerSelect = document.getElementById("aiProviderSelect");
  const modelSelect = document.getElementById("aiModelSelect");
  const imageUploadContainer = document.getElementById("imageUploadContainer");

  if (!providerSelect || !modelSelect || !imageUploadContainer) return;

  const provider = providerSelect.value;
  const model = modelSelect.value;

  // Zobraz upload pouze pro Groq Vision modely
  if (provider === "groq" && window.GROQ_VISION_MODELS.includes(model)) {
    imageUploadContainer.style.display = "block";
  } else {
    imageUploadContainer.style.display = "none";
  }
};

window.REQUESTS_WINDOW_MS = 60000; // 1 minuta

// ZÃ­skej aktuÃ¡lnÃ­ limit na zÃ¡kladÄ› vybranÃ©ho modelu
window.getCurrentModelLimit = function() {
  const modelSelect = document.getElementById("aiModelSelect");
  const selectedModel = modelSelect?.value;
  if (!selectedModel) return 15; // Fallback pokud nenÃ­ vybranÃ½ Å¾Ã¡dnÃ½ model
  const limit = window.MODEL_LIMITS[selectedModel];
  return limit ? limit.rpm : 15; // Fallback na 15
};

window.getCurrentModel = function() {
  const modelSelect = document.getElementById("aiModelSelect");
  return modelSelect?.value; // VracÃ­ undefined pokud nenÃ­ vybranÃ½
};

// PÅ™idej request do queue
// ===== JEDNODUCHÃ‰ POSLÃNÃ REQUESTU BEZ QUEUE =====
// Aktualizuj UI s informacÃ­ o limitech
window.updateQueueDisplay = function() {
  const now = Date.now();
  window.requestTimestamps = window.requestTimestamps.filter(
    ts => now - ts < window.REQUESTS_WINDOW_MS
  );
  window.saveRequestTimestamps(); // UloÅ¾ aktualizovanÃ© timestamps

  const maxRequests = window.getCurrentModelLimit();
  const usedSlots = window.requestTimestamps.length;
  const availableSlots = maxRequests - usedSlots;

  const meterDiv = document.getElementById("aiLimitMeter");
  if (!meterDiv) return;

  // Jen ÄÃ­sla - integrovanÃ© do strÃ¡nky
  const text = `${usedSlots}/${maxRequests}`;
  meterDiv.textContent = text;

  // Varuj kdyÅ¾ se blÃ­Å¾Ã­Å¡ limitu
  if (availableSlots <= 2) {
    meterDiv.style.color = "#ff9800";
  } else if (usedSlots >= maxRequests) {
    meterDiv.style.color = "#f87171";
  } else {
    meterDiv.style.color = "#888";
  }

  // Zablokuj/Odblokuj tlaÄÃ­tko
  const btnGenerate = document.getElementById("btnGenerate");

  if (btnGenerate) {
    if (availableSlots <= 0) {
      btnGenerate.disabled = true;
      btnGenerate.style.opacity = "0.5";
    } else {
      btnGenerate.disabled = false;
      btnGenerate.style.opacity = "1";
    }
  }
};

// ===== AI SELECT TOGGLE =====
window.toggleAiSelect = function () {
  window.aiSelectMode = !window.aiSelectMode;

  // Aktualizuj vÅ¡echna select tlaÄÃ­tka (v AI sekci i na canvas)
  const selectBtns = document.querySelectorAll('[id*="Select"]');
  selectBtns.forEach(btn => {
    if (window.aiSelectMode) {
      btn.style.background = "#3a7bc8";
      btn.style.borderColor = "#5b8ef5";
    } else {
      btn.style.background = "#333";
      btn.style.borderColor = "#444";
    }
  });

  if (window.aiSelectMode) {
    if (window.setMode) window.setMode("select");
  } else {
    if (window.clearMode) window.clearMode();
  }
};

// ===== QUICK INPUT (Keyboard) =====
window.openQuickInput = function () {
  const modal = document.getElementById("quickInputModal");
  if (modal) {
    modal.classList.remove('d-none');
    modal.style.display = "flex";
  }
};

window.closeQuickInput = function () {
  const modal = document.getElementById("quickInputModal");
  if (modal) {
    modal.style.display = "none";
    modal.classList.add('d-none');
  }
};

window.confirmQuickInput = function () {
  const display = document.getElementById("quickInputDisplay");
  const prompt = document.getElementById("aiPrompt");
  if (display && prompt) {
    const text = display.value.trim();
    if (text) {
      prompt.value = text;
      window.closeQuickInput();
      if (window.callGemini) window.callGemini();
    }
  }
};

window.insertToken = function (token) {
  const display = document.getElementById("quickInputDisplay");
  if (display) {
    display.value += token;
    display.scrollTop = display.scrollHeight;
  }
};

window.backspaceToken = function () {
  const display = document.getElementById("quickInputDisplay");
  if (display && display.value) {
    display.value = display.value.slice(0, -1);
  }
};

// ===== QUICK INPUT HELP =====
window.showQuickInputHelp = function () {
  // PouÅ¾ijeme controller help modal kterÃ½ mÃ¡ obsah
  const modal = document.getElementById("controllerHelpModal");
  if (modal) {
    modal.classList.remove('d-none');
    modal.style.display = "flex";
  }
};

window.closeQuickInputHelp = function () {
  const modal = document.getElementById("controllerHelpModal");
  if (modal) {
    modal.style.display = "none";
    modal.classList.add('d-none');
  }
};

// ===== VOICE INPUT =====
window.toggleVoice = function () {
  const btn = document.getElementById("btnVoice");
  if (!btn) return;
  btn.classList.toggle("recording-pulse");
  setTimeout(() => {
    btn.classList.remove("recording-pulse");
  }, 2000);
  alert("ğŸ¤ HlasovÃ© zadÃ¡nÃ­: Funkce bude implementovÃ¡na v pÅ™Ã­Å¡tÃ­ verzi.");
};

// ===== AI PREFERENCES =====
window.openAIPreferences = function () {
  const modal = document.getElementById("aiPreferencesModal");
  if (modal) {
    modal.style.display = "flex";
    window.renderPreferencesList();
  }
};

window.closeAIPreferences = function () {
  const modal = document.getElementById("aiPreferencesModal");
  if (modal) modal.style.display = "none";
};

window.renderPreferencesList = function () {
  const memory = window.loadAIMemory ? window.loadAIMemory() : {};
  const list = document.getElementById("preferencesList");
  if (!list) return;

  const prefs = memory.preferences || {};
  if (Object.keys(prefs).length === 0) {
    list.innerHTML = '<div style="padding: 10px; color: #555; font-style: italic; text-align: center;">ZatÃ­m Å¾Ã¡dnÃ© preference</div>';
    return;
  }

  list.innerHTML = Object.entries(prefs)
    .map(([k, v]) => `<div style="padding: 8px; background: #222; border-radius: 4px; margin-bottom: 6px;"><strong>${k}:</strong> ${v}</div>`)
    .join("");
};

window.addAIPreference = function () {
  const keyEl = document.getElementById("newPrefKey");
  const valEl = document.getElementById("newPrefValue");
  if (!keyEl || !valEl) return;

  const key = keyEl.value.trim();
  const val = valEl.value.trim();

  if (!key || !val) {
    alert("VyplÅˆ klÃ­Ä i hodnotu");
    return;
  }

  const memory = window.loadAIMemory ? window.loadAIMemory() : {};
  if (!memory.preferences) memory.preferences = {};
  memory.preferences[key] = val;

  if (window.saveAIMemory) window.saveAIMemory(memory);

  keyEl.value = "";
  valEl.value = "";
  window.renderPreferencesList();
  alert("âœ… Preference pÅ™idÃ¡na!");
};

// ===== AI MEMORY & METRICS =====
window.showAIMemory = function () {
  try {
    const memory = JSON.parse(localStorage.getItem("soustruznik_ai_memory") || "{}");
    const patterns = memory.successfulPatterns || [];

    let msg = "ğŸ§  AI SE NAUÄŒILA:\n\n";
    if (patterns.length > 0) {
      msg += "âœ… ÃšspÄ›Å¡nÃ© vzory:\n";
      patterns.slice(-10).forEach((p) => {
        msg += `  â€¢ "${p.input}" â†’ ${p.shapeCount} tvarÅ¯\n`;
      });
    } else {
      msg += "ZatÃ­m se nic nenauÄila. PosÃ­lej jÃ­ pÅ™Ã­kazy!";
    }
    alert(msg);
  } catch (e) {
    alert("âŒ Nelze naÄÃ­st pamÄ›Å¥: " + e.message);
  }
};

window.showAIMetrics = function () {
  try {
    const memory = JSON.parse(localStorage.getItem("soustruznik_ai_memory") || "{}");
    const patterns = memory.successfulPatterns || [];

    let msg = "ğŸ“Š AI STATISTIKY:\n\n";
    msg += "ÃšspÄ›Å¡nÃ½ch pÅ™Ã­kazÅ¯: " + patterns.length + "\n";
    msg += "PoslednÃ­: " + (patterns.length > 0 ? patterns[patterns.length - 1].input : "Å¾Ã¡dnÃ½");
    alert(msg);
  } catch (e) {
    alert("âŒ Chyba: " + e.message);
  }
};

// ===== IMAGE HANDLING =====
window.handleImageSelect = function (input) {
  const file = input.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = (e) => {
    const result = e.target.result;
    window.currentImageBase64 = result.split(",")[1];
    window.currentImageMimeType = file.type;

    const previewImg = document.getElementById("aiPreviewImg");
    if (previewImg) previewImg.src = result;

    const preview = document.getElementById("aiImagePreview");
    if (preview) preview.style.display = "block";

    const fileNameEl = document.getElementById("aiFileName");
    if (fileNameEl) fileNameEl.textContent = file.name;
  };

  reader.onerror = () => {
    alert("âš ï¸ NepodaÅ™ilo se pÅ™eÄÃ­st soubor.");
  };

  reader.readAsDataURL(file);
};

window.clearImage = function () {
  window.currentImageBase64 = null;
  window.currentImageMimeType = null;

  const input = document.getElementById("aiImageInput");
  if (input) input.value = "";

  const preview = document.getElementById("aiImagePreview");
  if (preview) preview.style.display = "none";

  const fileNameEl = document.getElementById("aiFileName");
  if (fileNameEl) fileNameEl.textContent = "";
};

window.clearChat = function () {
  const container = document.getElementById("aiChatHistory");
  if (container) {
    const messages = container.querySelectorAll(".chat-msg");
    messages.forEach(msg => msg.remove());
  }
};



// ===== DIRECTION MODAL =====
window.showDirectionModal = function () {
  const modal = document.getElementById("directionModal");
  if (modal) {
    modal.style.display = "flex";
  }
};

window.closeDirectionModal = function () {
  const modal = document.getElementById("directionModal");
  if (modal) {
    modal.style.display = "none";
  }
};

window.insertDirection = function (angle) {
  const display = document.getElementById("quickInputDisplay");
  if (display) {
    display.value += "AP" + angle + " ";
    display.scrollTop = display.scrollHeight;
  }
  window.closeDirectionModal();
};

// ===== LENGTH MODAL =====
window.openLengthModal = function () {
  const modal = document.getElementById("lengthModal");
  const input = document.getElementById("lengthInput");
  if (modal) {
    modal.style.display = "flex";
    if (input) {
      input.value = "";
      setTimeout(() => input.focus(), 100);
    }
  }
};

window.closeLengthModal = function () {
  const modal = document.getElementById("lengthModal");
  if (modal) {
    modal.style.display = "none";
  }
};

window.insertLengthToken = function (type) {
  window.lengthType = type;
};

window.confirmLength = function () {
  const input = document.getElementById("lengthInput");
  const display = document.getElementById("quickInputDisplay");
  if (!input || !display) return;

  const value = input.value.trim();
  if (!value) {
    alert("Zadej prosÃ­m dÃ©lku!");
    return;
  }

  const type = window.lengthType || "L";
  display.value += type + value + " ";
  display.scrollTop = display.scrollHeight;
  window.closeLengthModal();
};

// ===== UNDO/REDO =====
window.aiUndo = function () {
  if (window.undo) window.undo();
};

window.aiRedo = function () {
  if (window.redo) window.redo();
};

window.toggleAiPanel = function (open) {
  const container = document.getElementById("toolsAi");
  if (!container) {
    return;
  }

  // Inicalizuj window.aiPanelOpen pokud neexistuje
  if (window.aiPanelOpen === undefined) {
    window.aiPanelOpen = container.style.display !== "none";
  }

  if (open !== undefined) {
    window.aiPanelOpen = open;
  } else {
    window.aiPanelOpen = !window.aiPanelOpen;
  }

  if (window.aiPanelOpen) {
    container.style.display = "flex";
    container.style.zIndex = "3000";
    // Ensure inner panel visible and draggable
    const panelEl = document.getElementById('aiPanel');
    if (panelEl) {
      panelEl.style.display = 'block';
      panelEl.style.zIndex = '3001';
      panelEl.style.pointerEvents = 'auto';
    }
    try { if (window.enableAIDragging) window.enableAIDragging(); } catch(e){}
    const chatWindow = document.getElementById("chatWindow");
    if (chatWindow) {
      chatWindow.style.display = "block";
    }
    const input = document.getElementById("aiPrompt");
    if (input) {
      setTimeout(() => input.focus(), 100);
    }
    if (!window.aiMemoryLoaded && window.loadAIMemory) {
      window.loadAIMemory();
      window.aiMemoryLoaded = true;
    }
    // Odstranit minimized indikÃ¡tor
    updateAIButtonIndicator(false);
  } else {
    container.style.display = "none";
    const chatWindow = document.getElementById("chatWindow");
    if (chatWindow) {
      chatWindow.style.display = "none";
    }
    // hide inner panel as well
    const panelEl = document.getElementById('aiPanel');
    if (panelEl) panelEl.style.display = 'none';
  }
};

// ===== MINIMALIZACE A ZAVÅ˜ENÃ AI =====
window.aiMinimized = false;

// Aktualizuje indikÃ¡tor na AI tlaÄÃ­tku
function updateAIButtonIndicator(isMinimized) {
  const btn = document.getElementById('btnCatAi');
  if (!btn) return;

  const existingIndicator = btn.querySelector('.ai-indicator');
  if (existingIndicator) {
    existingIndicator.remove();
  }

  if (isMinimized) {
    const indicator = document.createElement('div');
    indicator.className = 'ai-indicator';
    indicator.innerHTML = '<span style="font-size: 8px;">â—</span>';
    indicator.style.cssText = 'position: absolute; top: 2px; right: 2px; background: #22c55e; color: white; border-radius: 50%; width: 14px; height: 14px; display: flex; align-items: center; justify-content: center; animation: pulse 2s infinite;';
    btn.style.position = 'relative';
    btn.appendChild(indicator);
  }
}

// Minimalizuje AI panel (schovÃ¡ ho, ale AI pokraÄuje)
window.minimizeAI = function() {
  const container = document.getElementById("toolsAi");
  if (!container) return;

  container.style.display = "none";
  window.aiPanelOpen = false;
  window.aiMinimized = true;

  // Zobrazit indikÃ¡tor na tlaÄÃ­tku
  updateAIButtonIndicator(true);

  // Deaktivovat tlaÄÃ­tko AI kategorie
  const btnCatAi = document.getElementById('btnCatAi');
  if (btnCatAi) {
    btnCatAi.classList.remove('active');
  }
};

// ZavÅ™e AI panel a ukonÄÃ­ probÃ­hajÃ­cÃ­ operace
window.closeAI = function() {
  const container = document.getElementById("toolsAi");
  if (!container) return;

  // PoznÃ¡mka: AbortController pro AI nenÃ­ momentÃ¡lnÄ› implementovÃ¡n
  // Toto pouze ukonÄÃ­ UI - probÃ­hajÃ­cÃ­ dotaz mÅ¯Å¾e dobÄ›hnout
  console.log("ğŸ›‘ AI panel zavÅ™en uÅ¾ivatelem");

  container.style.display = "none";
  window.aiPanelOpen = false;
  window.aiMinimized = false;

  // Odstranit indikÃ¡tor
  updateAIButtonIndicator(false);

  // Deaktivovat tlaÄÃ­tko AI kategorie
  const btnCatAi = document.getElementById('btnCatAi');
  if (btnCatAi) {
    btnCatAi.classList.remove('active');
  }

  const chatWindow = document.getElementById("chatWindow");
  if (chatWindow) {
    chatWindow.style.display = "none";
  }

  const panelEl = document.getElementById('aiPanel');
  if (panelEl) panelEl.style.display = 'none';
};

// ===== RETRY WITH BACKOFF (Pro API chyby) =====
window.retryWithBackoff = async function (apiCall, maxRetries = 3) {
  console.log("ğŸ”„ [DEBUG] retryWithBackoff START - maxRetries:", maxRetries);
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    console.log(`ğŸ” [DEBUG] Pokus ${attempt + 1}/${maxRetries}`, new Date().toISOString());
    try {
      const result = await apiCall();
      console.log("âœ… [DEBUG] API call ÃšSPÄšCH!");
      return result;
    } catch (err) {
      const isRateLimit =
        err.message?.includes("429") ||
        err.message?.includes("quota") ||
        err.message?.includes("Quota exceeded") ||
        err.message?.includes("RESOURCE_EXHAUSTED");

      if (isRateLimit && attempt < maxRetries - 1) {
        // Zkus najÃ­t pÅ™esnÃ½ Äas z Google error message: "Please retry in 53.955s"
        const retryMatch = err.message?.match(/retry in ([\d.]+)s/i);
        let delayMs;

        if (retryMatch) {
          // Google Å™ekl pÅ™esnÄ› jak dlouho Äekat
          delayMs = Math.ceil(parseFloat(retryMatch[1]) * 1000);
          console.log(`â³ KvÃ³ta vyÄerpÃ¡na, ÄekÃ¡m ${Math.ceil(delayMs/1000)}s (dle Google API)...`);
        } else {
          // ExponenciÃ¡lnÃ­ backoff: 2s, 4s, 8s, 16s
          delayMs = Math.pow(2, attempt + 1) * 1000;
          console.log(`â³ KvÃ³ta vyÄerpÃ¡na, ÄekÃ¡m ${delayMs/1000}s pÅ™ed dalÅ¡Ã­m pokusem...`);
        }

        await new Promise((resolve) => setTimeout(resolve, delayMs));
        continue;
      }

      // Pokud to nenÃ­ rate limit nebo uÅ¾ jsme vyÄerpali pokusy, vyhoÄ error
      if (attempt === maxRetries - 1 || !isRateLimit) {
        console.error("âŒ API Error:", err.message);
        throw err;
      }

      throw err;
    }
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROCESS AI RESPONSE - Zpracuje odpovÄ›Ä z AI modulu
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Zpracuje AI odpovÄ›Ä (z AI modulu nebo pÅ¯vodnÃ­ implementace)
 * Parsuje JSON, pÅ™idÃ¡ tvary na canvas, zobrazÃ­ v chatu
 */
window.processAIResponse = async function(aiResponseText, originalPrompt) {
  const container = document.getElementById("aiChatHistory");
  const promptInput = document.getElementById("aiPrompt");
  const aiType = document.getElementById('aiTypeSelect')?.value || 'cnc';

  if (!container) return;

  try {
    window.processingAI = true;
    if (promptInput) promptInput.disabled = true;

    // Zobraz user zprÃ¡vu
    const userMsgDiv = document.createElement("div");
    userMsgDiv.className = "chat-msg user";
    userMsgDiv.style.marginBottom = "10px";
    userMsgDiv.innerHTML = `<strong>Ty:</strong> ${escapeHtml(originalPrompt)}`;
    container.appendChild(userMsgDiv);

    // UloÅ¾ raw odpovÄ›Ä pro debugging
    window.lastRawAI = aiResponseText;

    // Pro Chat mode - zobraz jako plain text
    if (aiType === 'chat') {
      const msgDiv = document.createElement('div');
      msgDiv.className = 'chat-msg model';
      msgDiv.style.marginBottom = '10px';
      msgDiv.innerHTML = `<strong>AI:</strong> ${escapeHtml(aiResponseText)}`;
      container.appendChild(msgDiv);
      container.scrollTop = container.scrollHeight;

      if (promptInput) {
        promptInput.value = '';
        promptInput.disabled = false;
      }
      window.processingAI = false;
      return;
    }

    // Pro CNC/2D mode - parsuj JSON
    const result = window.parseAIReply(aiResponseText);

    if (!result) {
      throw new Error('NepodaÅ™ilo se parsovat AI odpovÄ›Ä');
    }

    const replyText = result.response_text || "Hotovo.";
    const newShapes = result.shapes || [];

    // UloÅ¾ pro debugging
    window.lastAIResponse = {
      rawResponse: aiResponseText,
      parsedResult: result,
      replyText: replyText,
      shapes: newShapes,
      timestamp: new Date().toISOString()
    };

    // PÅ™idej tvary na canvas
    if (Array.isArray(newShapes) && newShapes.length > 0) {
      newShapes.forEach((s) => {
        try {
          if (s.type === "line" && typeof s.x1 === "number" && typeof s.y1 === "number" &&
              typeof s.x2 === "number" && typeof s.y2 === "number") {
            window.shapes.push({ type: "line", x1: s.x1, y1: s.y1, x2: s.x2, y2: s.y2 });
          } else if (s.type === "circle" && typeof s.cx === "number" && typeof s.cy === "number" &&
                     typeof s.r === "number" && s.r > 0) {
            window.shapes.push({ type: "circle", cx: s.cx, cy: s.cy, r: s.r });
          } else if (s.type === "arc" && typeof s.cx === "number" && typeof s.cy === "number" &&
                     typeof s.r === "number" && s.r > 0) {
            window.shapes.push({
              type: "arc", cx: s.cx, cy: s.cy, r: s.r,
              startAngle: s.startAngle, endAngle: s.endAngle,
              counterclockwise: s.counterclockwise || false
            });
          } else if (s.type === "point" && typeof s.x === "number" && typeof s.y === "number") {
            window.points.push({ x: s.x, y: s.y });
          }
        } catch (e) {
          console.warn('âš ï¸ Chyba pÅ™i pÅ™idÃ¡vÃ¡nÃ­ tvaru:', e);
        }
      });

      if (window.updateSnapPoints) window.updateSnapPoints();
      if (window.draw) window.draw();
      window.recordAISuccess(originalPrompt, newShapes);
    }

    // Zobraz v chatu
    const msgDiv = document.createElement("div");
    msgDiv.className = "chat-msg model";
    if (newShapes.length > 0) {
      msgDiv.innerHTML = `<span class="shape-tag">âœï¸ +${newShapes.length} tvarÅ¯</span><br>${escapeHtml(replyText)}`;
    } else {
      msgDiv.innerHTML = escapeHtml(replyText);
    }
    container.appendChild(msgDiv);
    container.scrollTop = container.scrollHeight;

    if (promptInput) {
      promptInput.value = '';
    }

    // Update stats
    if (typeof apiUsageStats !== 'undefined') {
      apiUsageStats.totalCalls = (apiUsageStats.totalCalls || 0) + 1;
      apiUsageStats.dailyCalls = (apiUsageStats.dailyCalls || 0) + 1;
      if (typeof saveApiStats === 'function') saveApiStats();
    }

  } catch (err) {
    console.error('âŒ processAIResponse error:', err);

    const errorDiv = document.createElement("div");
    errorDiv.className = "chat-msg model";
    errorDiv.style.color = "#ff6b6b";
    errorDiv.textContent = "âŒ " + err.message;
    container.appendChild(errorDiv);
    container.scrollTop = container.scrollHeight;

  } finally {
    window.processingAI = false;
    if (promptInput) promptInput.disabled = false;

    const btnCancel = document.getElementById("btnCancel");
    const btnGenerate = document.getElementById("btnGenerate");
    if (btnCancel) btnCancel.style.display = "none";
    if (btnGenerate) btnGenerate.style.display = "inline-block";
  }
};

// ===== JSON PARSING HELPER =====

/**
 * Parsuje AI odpovÄ›Ä (JSON s tvary)
 * PouÅ¾Ã­vÃ¡ se pro Groq i Gemini
 */
window.parseAIReply = function(aiResponseText) {
  try {
    // Aggressive JSON cleaning
    let cleanedJson = aiResponseText
      .replace(/```json\s*/gi, "")
      .replace(/```\s*/g, "");

    const firstBrace = cleanedJson.indexOf("{");
    const lastBrace = cleanedJson.lastIndexOf("}");
    if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
      cleanedJson = cleanedJson.substring(firstBrace, lastBrace + 1);
    }

    // Fix incomplete JSON
    const openBraces = (cleanedJson.match(/\{/g) || []).length;
    const closeBraces = (cleanedJson.match(/\}/g) || []).length;
    const openBrackets = (cleanedJson.match(/\[/g) || []).length;
    const closeBrackets = (cleanedJson.match(/\]/g) || []).length;

    if (openBrackets > closeBrackets) {
      cleanedJson += "]".repeat(openBrackets - closeBrackets);
    }
    if (openBraces > closeBraces) {
      cleanedJson += "}".repeat(openBraces - closeBraces);
    }

    // Fix missing x2
    cleanedJson = cleanedJson.replace(
      /\{"type":"line","x1":([^,]+),"y1":([^,]+),"y2":([^}]+)\}/g,
      '{"type":"line","x1":$1,"y1":$2,"x2":$1,"y2":$3}'
    );

    // Shorten long numbers
    cleanedJson = cleanedJson.replace(/(\d+\.\d{6})\d{4,}/g, "$1");
    cleanedJson = cleanedJson.replace(/,\s*([}\]])/g, "$1");

    console.log("ğŸ” [DEBUG] parseAIReply cleanedJson:", cleanedJson.substring(0, 200));
    const result = JSON.parse(cleanedJson);
    console.log("âœ… [DEBUG] parseAIReply parsed ÃºspÄ›Å¡nÄ›!");

    return result;
  } catch (e) {
    console.error("âŒ [DEBUG] parseAIReply failed:", e.message);
    return null;
  }
};

// ===== AI MEMORY: Learn from patterns =====
const AI_MEMORY_KEY = "soustruznik_ai_memory";

window.getAIMemoryContext = function () {
  try {
    const memory = JSON.parse(localStorage.getItem(AI_MEMORY_KEY) || "{}");
    const commands = memory.commands || [];
    const patterns = memory.successfulPatterns || [];

    const context = [];
    if (commands.length > 0) {
      context.push(`ğŸ“Œ Naposledy pouÅ¾Ã­vanÃ© pÅ™Ã­kazy: ${commands.slice(-3).map(c => c.text).join(", ")}`);
    }
    if (patterns.length > 0) {
      context.push(`âœ… ÃšspÄ›Å¡nÃ© vzory: ${patterns.slice(-2).map(p => p.input).join(", ")}`);
    }

    return context.join("\n");
  } catch (e) {
    return "";
  }
};

window.recordAISuccess = function (prompt, shapes) {
  try {
    const memory = JSON.parse(localStorage.getItem(AI_MEMORY_KEY) || "{}");

    if (!memory.successfulPatterns) memory.successfulPatterns = [];
    memory.successfulPatterns.push({
      input: prompt.toLowerCase().substring(0, 50),
      shapeCount: shapes.length,
      timestamp: new Date().toISOString(),
    });

    if (memory.successfulPatterns.length > 50) {
      memory.successfulPatterns = memory.successfulPatterns.slice(-50);
    }

    localStorage.setItem(AI_MEMORY_KEY, JSON.stringify(memory));
  } catch (e) {
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTEGRACE S AI MODULE v3.0
// NovÃ¡ funkce vyuÅ¾Ã­vajÃ­cÃ­ sdÃ­lenÃ½ AI modul pro lepÅ¡Ã­ sprÃ¡vu modelÅ¯ a fallback
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ZavolÃ¡ AI pomocÃ­ sdÃ­lenÃ©ho AI Module v3.0
 * Podporuje auto-fallback, smart retry a rate limit management
 * @param {string} prompt - UÅ¾ivatelskÃ½ dotaz
 * @param {object} options - VolitelnÃ© nastavenÃ­
 * @returns {Promise<string>} AI odpovÄ›Ä
 */
window.callAIWithModule = async function(prompt, options = {}) {
  // Zkontroluj zda je AI modul naÄten
  if (typeof AI === 'undefined') {
    console.warn('âš ï¸ AI modul nenÃ­ naÄten, pouÅ¾Ã­vÃ¡m pÅ¯vodnÃ­ metodu');
    return null; // VrÃ¡tÃ­ null = pouÅ¾ij pÅ¯vodnÃ­ metodu
  }

  // Zjisti aktuÃ¡lnÃ­ nastavenÃ­ z UI
  const providerSelect = document.getElementById("aiProviderSelect");
  const modelSelect = document.getElementById("aiModelSelect");
  const aiTypeSelect = document.getElementById("aiTypeSelect");

  const provider = options.provider || providerSelect?.value || 'gemini';
  const model = options.model || modelSelect?.value || AI.config?.models[provider];
  const aiType = options.aiType || aiTypeSelect?.value || 'cnc';

  // Pokud je auto-switch zapnutÃ½ a mÃ¡me Smart AI State
  if (window.smartAIState?.autoSwitch && !options.provider) {
    const best = AI.selectBestModel();
    if (best) {
      options.provider = best.provider;
      options.model = best.model;
    }
  }

  // Nastav system prompt podle typu
  let systemPrompt = options.system;
  if (!systemPrompt) {
    if (aiType === 'chat') {
      systemPrompt = 'Jsi pÅ™Ã¡telskÃ½ AI asistent. OdpovÃ­dej v ÄeÅ¡tinÄ›.';
    } else {
      // Pro CNC/2D pouÅ¾ij pÅ¯vodnÃ­ komplexnÃ­ system prompt
      systemPrompt = window.buildCADSystemPrompt ? window.buildCADSystemPrompt() : null;
    }
  }

  try {
    // PouÅ¾ij AI.ask() nebo AI.smartAsk() pro automatickÃ½ fallback
    const response = await AI.smartAsk(prompt, {
      provider: provider,
      model: model,
      system: systemPrompt,
      maxTokens: options.maxTokens || 4096,
      temperature: options.temperature || 0.7,
      ...options
    });

    console.log(`âœ… AI Module: OdpovÄ›Ä od ${provider}/${model}`);
    return response;

  } catch (err) {
    console.error('âŒ AI Module error:', err.message);
    throw err;
  }
};

/**
 * Wrapper pro callGemini kterÃ½ zkusÃ­ nejdÅ™Ã­v AI modul
 * Pokud selÅ¾e nebo nenÃ­ dostupnÃ½, pouÅ¾ije pÅ¯vodnÃ­ implementaci
 */
window.callGeminiWithFallback = async function() {
  const promptInput = document.getElementById("aiPrompt");
  const prompt = promptInput?.value?.trim();

  if (!prompt) {
    alert("Zadej prosÃ­m pÅ™Ã­kaz pro AI!");
    return;
  }

  // Zkus AI modul
  try {
    const moduleResponse = await window.callAIWithModule(prompt);
    if (moduleResponse !== null) {
      // AI modul vrÃ¡til odpovÄ›Ä, zpracuj ji
      await window.processAIResponse(moduleResponse, prompt);
      return;
    }
  } catch (err) {
    console.warn('âš ï¸ AI modul selhal, zkouÅ¡Ã­m pÅ¯vodnÃ­ metodu:', err.message);
  }

  // Fallback na pÅ¯vodnÃ­ implementaci
  window.callGeminiDirect();
};

// ===== MAIN AI CALL =====

/**
 * HlavnÃ­ vstupnÃ­ bod pro volÃ¡nÃ­ AI.
 * Zpracuje uÅ¾ivatelskÃ½ prompt a pÅ™edÃ¡ ho sprÃ¡vnÃ©mu provideru.
 * @async
 * @returns {Promise<void>}
 */
window.callGemini = async function () {
  console.log("ğŸ”µ [DEBUG] callGemini() SPUÅ TÄšNO", new Date().toISOString());
  const promptInput = document.getElementById("aiPrompt");
  if (!promptInput) return;

  const prompt = promptInput.value.trim();
  if (!prompt) {
    alert("Zadej prosÃ­m pÅ™Ã­kaz pro AI!");
    return;
  }

  // Zobraz Cancel button
  const btnCancel = document.getElementById("btnCancel");
  const btnGenerate = document.getElementById("btnGenerate");
  if (btnCancel) btnCancel.style.display = "inline-block";
  if (btnGenerate) btnGenerate.style.display = "none";

  if (window.processingAI) {
    console.warn("âš ï¸ [DEBUG] processingAI = true, ABORT!");
    alert("AI zpracovÃ¡vÃ¡ pÅ™edchozÃ­ pÅ™Ã­kaz. ÄŒekej prosÃ­m.");
    return;
  }

  console.log("ğŸŸ¢ [DEBUG] VolÃ¡m callGeminiDirect()...");
  // PoÅ¡li pÅ™Ã­mo na AI
  window.callGeminiDirect();
};

/**
 * Router pro AI volÃ¡nÃ­ - smÄ›ruje request na sprÃ¡vnÃ©ho providera.
 * Podporuje: gemini, groq, openrouter, mistral
 * @async
 * @returns {Promise<void>}
 */
window.callGeminiDirect = async function () {
  console.log("ğŸŸ¡ [DEBUG] callGeminiDirect() SPUÅ TÄšNO", new Date().toISOString());

  // Zjisti providera
  const providerSelect = document.getElementById("aiProviderSelect");
  const provider = providerSelect?.value || "gemini";

  // Podle providera zavolej sprÃ¡vnou funkci
  if (provider === "groq") {
    return window.callGroqDirect();
  } else if (provider === "openrouter") {
    return window.callOpenRouterDirect();
  } else if (provider === "mistral") {
    return window.callMistralDirect();
  } else {
    return window.callGeminiDirectOriginal();
  }
};

/**
 * VolÃ¡nÃ­ Google Gemini API.
 * Zpracuje prompt, odeÅ¡le na API a zpracuje odpovÄ›Ä.
 * @async
 * @returns {Promise<void>}
 */
window.callGeminiDirectOriginal = async function () {
  console.log("ğŸŸ¡ [DEBUG] callGeminiDirectOriginal() SPUÅ TÄšNO", new Date().toISOString());
  const promptInput = document.getElementById("aiPrompt");
  const container = document.getElementById("aiChatHistory");
  if (!promptInput || !container) return;

  const prompt = promptInput.value.trim();
  if (!prompt) return;

  console.log("ğŸ”’ [DEBUG] Nastavuji processingAI = true");
  window.processingAI = true;
  promptInput.disabled = true;

  // Zobraz user zprÃ¡vu hned
  const userMsgDiv = document.createElement("div");
  userMsgDiv.className = "chat-msg user";
  userMsgDiv.style.marginBottom = "10px";
  userMsgDiv.innerHTML = `<strong>Ty:</strong> ${escapeHtml(prompt)}`;
  container.appendChild(userMsgDiv);
  container.scrollTop = container.scrollHeight;

  // Add loading indicator
  const loadingDiv = document.createElement("div");
  loadingDiv.style.cssText = "text-align: center; color: #666; padding: 12px; font-size: 12px;";
  loadingDiv.innerHTML = '<div class="loading-dots"><div></div><div></div><div></div></div> ÄŒekÃ¡m na odpovÄ›Ä...';
  container.appendChild(loadingDiv);
  container.scrollTop = container.scrollHeight;

  try {
    const apiKey = window.getCurrentApiKey ? window.getCurrentApiKey() : null;
    if (!apiKey) {
      throw new Error("NemÃ¡te API klÃ­Ä. OtevÅ™ete âš™ï¸ NastavenÃ­.");
    }

    // Build full system prompt with all critical instructions
    const modeIndicator = window.mode ? `Current mode: ${window.mode}` : "";
    const xMeasureMode = window.xMeasureMode || "radius";

    const learningContext = window.getAIMemoryContext ? window.getAIMemoryContext() : "";

    const modeExplanation =
      xMeasureMode === "diameter"
        ? `X-AXIS MODE: DIAMETER (âŒ€)
User shows values as diameter from center axis.
Example: User says "X=100" = 50mm from center (radius=50)
You MUST respond with DIAMETER values: "X=100" even though internal radius=50
The application will automatically convert diameterâ†’radius for rendering.`
        : `X-AXIS MODE: RADIUS (R)
User shows values as radius distance from center axis.
Example: User says "X=50" = exactly 50mm from center
You MUST respond with RADIUS values: "X=50"
No conversion needed, use values exactly as specified.`;

    const systemPrompt = `CAD Assistant for CNC Lathe/Mill operations (Czech language).

COORDINATE SYSTEM:
Z-axis (horizontal/â†’) = JSON 'x' property
X-axis (vertical/â†‘) = JSON 'y' property
Origin: (0,0) center
Report coords as: "Z=[x] X=[y]"

ğŸ”§ CURRENT MODE: ${modeIndicator}
${modeExplanation}

ANGLES (Standard Unit Circle):
0Â°=RIGHT(+Z), 90Â°=UP(+X), 180Â°=LEFT(-Z), 270Â°=DOWN(-X)

INPUT FORMATS:
1. Natural language: "kruÅ¾nice Z100 X50 R30"
2. CNC/G-code style: "X80Z56R52" or "X50Z56AP0RP120"

CNC SYNTAX PARSING:
- XvalZval = position (X=diameter/radius depending on mode, Z=length)
- Rval = radius for circle
- APval = angle in polar (0Â°=right, 90Â°=up, 180Â°=left, 270Â°=down)
- RPval = polar radius/length (distance from start point)

Examples (when in DIAMETER mode):
"X80Z56R52" â†’ Circle at (Z=56,X=80âŒ€) with radius 52 (diameter=104)
            User sees center at X=80 (which is 80mm from axis, diameter)
"X50Z56AP0RP120" â†’ Line from (Z=56,X=50âŒ€) at angle 0Â° length 120mm
                 User sees start X=50 (50mm from axis, diameter)
  â†’ End point: Z=56+120*cos(0Â°)=176, X=50+120*sin(0Â°)=50
  â†’ {"type":"line","x1":56,"y1":50,"x2":176,"y2":50}

"X80Z56R52;X50Z56AP0RP120" â†’ Circle + Line:
  - Circle: center (56,80), R=52
  - Line: from (56,50) angle 0Â° length 120 â†’ to (176,50)

IMPORTANT FOR POLAR LINES:
When user says "ÃºseÄka OD STÅ˜EDU kruÅ¾nice" or "line FROM CENTER of circle":
- Start point (x1,y1) = center of that circle (cx,cy)
- End point: calculate using angle and length FROM that center
- CALCULATION:
  * x2 = x1 + length*cos(angle_degrees * Ï€/180)
  * y2 = y1 + length*sin(angle_degrees * Ï€/180)

- Example 1: Center Z=100,X=100 + line angle 0Â° length 120mm
  â†’ x2 = 100 + 120*cos(0Â°) = 100 + 120*1 = 220
  â†’ y2 = 100 + 120*sin(0Â°) = 100 + 120*0 = 100
  â†’ Line: {"type":"line","x1":100,"y1":100,"x2":220,"y2":100}

- Example 2: Center Z=96,X=78 + line angle 5Â° length 250mm
  â†’ x2 = 96 + 250*cos(5Â°) = 96 + 250*0.9962 = 345
  â†’ y2 = 78 + 250*sin(5Â°) = 78 + 250*0.0872 = 100
  â†’ Line: {"type":"line","x1":96,"y1":78,"x2":345,"y2":100}

â­• CIRCUMCIRCLE (kruÅ¾nice prochÃ¡zejÃ­cÃ­ 3 body A, B, C):
When user says "kruÅ¾nici prochÃ¡zejÃ­cÃ­ body A B C" or "circle through 3 points":
1. Use the 3 points from context (e.g., points A(x1,y1), B(x2,y2), C(x3,y3))
2. Calculate circumcircle center (cx, cy) and radius r:

CIRCUMCIRCLE FORMULA:
Let: A=(x1,y1), B=(x2,y2), C=(x3,y3)
D = 2*(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))
If D â‰ˆ 0: Points are collinear, cannot draw circle

If D â‰  0:
ux = ((x1Â²+y1Â²)*(y2-y3) + (x2Â²+y2Â²)*(y3-y1) + (x3Â²+y3Â²)*(y1-y2)) / D
uy = ((x1Â²+y1Â²)*(x3-x2) + (x2Â²+y2Â²)*(x1-x3) + (x3Â²+y3Â²)*(x2-x1)) / D
cx = ux
cy = uy
r = âˆš((x1-cx)Â² + (y1-cy)Â²)

Example: Points A(0,0), B(100,0), C(50,86.6)
- D = 2*(0*(0-86.6) + 100*(86.6-0) + 50*(0-0)) = 17320
- ux = ((0)*(0-86.6) + (10000)*(86.6-0) + (9966)*(0-0)) / 17320 = 50
- uy = ((0)*(50-100) + (10000)*(0-50) + (9966)*(100-0)) / 17320 â‰ˆ 57.7
- cx=50, cy=57.7, r=âˆš((0-50)Â²+(0-57.7)Â²) â‰ˆ 76.3

3. Return the circle as: {"type":"circle","cx":cx,"cy":cy,"r":r}

ğŸ”„ TANGENTIAL FILLET / RADIUS (zaoblenÃ­ s tangenciÃ¡lnÃ­m napojenÃ­m):
When user says "zaoblenÃ­ R[value] v bodÄ› Z[z] X[x] smÄ›rem [dolÅ¯/nahoru/vlevo/vpravo]":

âš ï¸ CRITICAL: "R" means RADIUS, not diameter! Use value directly as radius.
If user says "R5", return "r":5 (not 2.5, not 10)

ğŸ¤– G-CODE SUPPORT (CNC terminology) - MANDATORY PARSING:
User may specify arc direction using G-codes - YOU MUST PARSE THESE!
- **G2** = clockwise arc â†’ set counterclockwise: false
- **G3** = counterclockwise arc â†’ set counterclockwise: true
- **CR[value]** or **R[value]** = corner radius value (CR5 = radius 5)

âš ï¸ CRITICAL: When you see G2, G3, or CR in the prompt, you MUST create ARC shapes!
DO NOT create points or ignore G-codes!

CNC-style arc syntax (NO CENTER NEEDED - you calculate it):
"G2 Z[end_z] X[end_x] CR[radius]" or "G3 Z[end_z] X[end_x] CR[radius]"
- Start point = last point from previous shape (line endpoint)
- End point = specified Z X coordinates
- Radius = CR value
- YOU MUST calculate the arc center automatically!

REAL EXAMPLE from user prompt:
Input: "ÄÃ¡ra Z0 X60 do Z40 X60, G2 Z45 X55 CR5, G3 Z50 X50 CR5, ÄÃ¡ra do Z80 X50"

Expected output (4 shapes):
1. {"type":"line","x1":0,"y1":60,"x2":40,"y2":60}  â† horizontal line
2. {"type":"arc","cx":42.5,"cy":57.5,"r":5,"startAngle":180,"endAngle":225,"counterclockwise":false}  â† G2 clockwise
3. {"type":"arc","cx":47.5,"cy":52.5,"r":5,"startAngle":225,"endAngle":270,"counterclockwise":true}  â† G3 counterclockwise
4. {"type":"line","x1":50,"y1":50,"x2":80,"y2":50}  â† horizontal line

Common patterns YOU MUST RECOGNIZE:
- "G2 CR5" = clockwise arc with radius 5
- "G3 CR5" = counterclockwise arc with radius 5
- "G2 Z[x] X[y] CR[r]" = clockwise arc to endpoint with radius
- "ÄÃ¡ra do Z[x] X[y]" = line from last point to new point

âœ¨ PREFERRED: Generate ARC (partial circle) for tangential fillet:
{"type":"arc","cx":center_x,"cy":center_y,"r":radius,"startAngle":start_deg,"endAngle":end_deg,"counterclockwise":false}

ğŸ¯ TANGENT ANGLE CALCULATION (CRITICAL for proper connection):
- Angles are from ARC CENTER perspective (0Â°=right, 90Â°=up, 180Â°=left, 270Â°=down)
- For tangent to HORIZONTAL line: arc must touch at 90Â° (top) or 270Â° (bottom)
- For tangent to VERTICAL line: arc must touch at 0Â° (right) or 180Â° (left)
- counterclockwise: false = G2 (clockwise), true = G3 (counterclockwise)

Example: "zaoblenÃ­ R5 v bodÄ› Z40 X60 smÄ›rem dolÅ¯" (horizontal lines above/below):
- Corner point: (40, 60) where top line ends
- Center offset DOWN: cx=40, cy=60-5=55
- Top line is HORIZONTAL â†’ tangent point at TOP of circle â†’ angle=90Â°
- Bottom line is HORIZONTAL â†’ tangent point at BOTTOM of circle â†’ angle=270Â°
- Clockwise from top to bottom: counterclockwise=false (G2)
- Return: {"type":"arc","cx":40,"cy":55,"r":5,"startAngle":90,"endAngle":270,"counterclockwise":false}

Example: "zaoblenÃ­ R3 v bodÄ› Z40 X60 smÄ›rem vpravo" (vertical lines):
- Center offset RIGHT: cx=40+3=43, cy=60
- Tangent angles: 90Â° (top) to 0Â° (right) or similar
- Return: {"type":"arc","cx":43,"cy":60,"r":3,"startAngle":90,"endAngle":0,"counterclockwise":false}

ğŸ“¦ FALLBACK: If uncertain about angles, use CIRCLE:
{"type":"circle","cx":cx,"cy":cy,"r":radius}
- System will auto-detect tangent lines and render only the arc portion
- Offset center by radius in specified direction (same as above)

âš ï¸ CRITICAL RULES FOR LINES:
1. ALWAYS calculate BOTH x2 AND y2 using the angle and length
2. DO NOT provide only y2 without x2 - both must be present
3. Use the FULL formulas:
   - x2 = x1 + length*cos(angle_in_radians)
   - y2 = y1 + length*sin(angle_in_radians)
4. Even if you're unsure about x, always provide calculated x2
5. A line with x1==x2 AND y1==y2 is invisible (zero length)!

RESPONSE FORMAT (strict JSON only):
{"response_text":"Brief Czech confirmation <50 chars","shapes":[...]}

SHAPE TYPES:
Line: {"type":"line","x1":z1,"y1":x1,"x2":z2,"y2":x2}
Circle: {"type":"circle","cx":z,"cy":x,"r":radius}
Point: {"type":"point","x":z,"y":x}

${learningContext}`;

    const contextInfo = window.buildDrawingContext ? window.buildDrawingContext() : "PrÃ¡zdnÃ© kreslenÃ­";

    const fullPrompt = `${systemPrompt}

AktuÃ¡lnÃ­ kreslenÃ­:
${contextInfo}

UÅ¾ivatel: ${prompt}`;

    // Call API with retry
    const startTime = performance.now();
    const selectedModel = window.getCurrentModel();
    if (!selectedModel) {
      throw new Error("NenÃ­ vybrÃ¡n Å¾Ã¡dnÃ½ model. Vyber model v nastavenÃ­ AI.");
    }

    console.log("ğŸ“¡ [DEBUG] SpouÅ¡tÃ­m retryWithBackoff() pro model:", selectedModel);
    const response = await window.retryWithBackoff(async () => {
      console.log("ğŸŒ [DEBUG] fetch() VOLÃ API...", new Date().toISOString());
      const resp = await fetch(
        "https://generativelanguage.googleapis.com/v1beta/models/" + selectedModel + ":generateContent?key=" + apiKey,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            contents: [{ parts: [{ text: fullPrompt }] }],
            generationConfig: {
              temperature: 0.7,
              maxOutputTokens: 4096,
            },
          }),
        }
      );
      if (!resp.ok) {
        const error = await resp.json().catch(() => ({}));
        throw new Error(error.error?.message || `HTTP ${resp.status}`);
      }
      return await resp.json();
    }, 1);

    const apiTime = performance.now() - startTime;

    if (container.contains(loadingDiv)) container.removeChild(loadingDiv);

    // Parse response
    console.log("ğŸ“¦ [DEBUG] ParsovÃ¡nÃ­ AI odpovÄ›di...");
    let aiResponseText = response.candidates?.[0]?.content?.parts?.[0]?.text || "";
    if (!aiResponseText) {
      console.error("âŒ [DEBUG] AI nevrÃ¡tila text!");
      throw new Error("AI nevrÃ¡tila text");
    }

    // UloÅ¾ pro debugging - pÅ™Ã­stupnÃ© v konzoli jako window.lastRawAI
    window.lastRawAI = aiResponseText;
    console.log("ğŸ“„ [DEBUG] AI raw response (CELÃ):");
    console.log(aiResponseText);
    console.log("ğŸ“ [DEBUG] DÃ©lka odpovÄ›di:", aiResponseText.length, "znakÅ¯");

    // Determine AI type (cnc / chat)
    const aiType = document.getElementById('aiTypeSelect')?.value || 'cnc';

    // If Chat mode, treat AI response as plain text (no JSON parsing expected)
    if (aiType === 'chat') {
      const replyTextChat = aiResponseText;
      // UloÅ¾ pro debugging
      window.lastRawAI = aiResponseText;

      // Append AI chat message to container
      const msgDiv = document.createElement('div');
      msgDiv.className = 'chat-msg model';
      msgDiv.style.marginBottom = '10px';
      msgDiv.innerHTML = `<strong>AI:</strong> ${escapeHtml(replyTextChat)}`;
      container.appendChild(msgDiv);
      container.scrollTop = container.scrollHeight;

      // Restore UI state
      window.processingAI = false;
      promptInput.disabled = false;
      const btnCancel = document.getElementById('btnCancel');
      const btnGenerate = document.getElementById('btnGenerate');
      if (btnCancel) btnCancel.style.display = 'none';
      if (btnGenerate) btnGenerate.style.display = 'inline-block';

      // Update usage UI
      apiUsageStats.totalCalls = (apiUsageStats.totalCalls || 0) + 1;
      apiUsageStats.dailyCalls = (apiUsageStats.dailyCalls || 0) + 1;
      saveApiStats();

      return;
    }

    // Aggressive JSON cleaning
    let cleanedJson = aiResponseText
      .replace(/```json\s*/gi, "")
      .replace(/```\s*/g, "");

    const firstBrace = cleanedJson.indexOf("{");
    const lastBrace = cleanedJson.lastIndexOf("}");
    if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
      cleanedJson = cleanedJson.substring(firstBrace, lastBrace + 1);
    }

    // Fix incomplete JSON
    const openBraces = (cleanedJson.match(/\{/g) || []).length;
    const closeBraces = (cleanedJson.match(/\}/g) || []).length;
    const openBrackets = (cleanedJson.match(/\[/g) || []).length;
    const closeBrackets = (cleanedJson.match(/\]/g) || []).length;

    if (openBrackets > closeBrackets) {
      cleanedJson += "]".repeat(openBrackets - closeBrackets);
    }
    if (openBraces > closeBraces) {
      cleanedJson += "}".repeat(openBraces - closeBraces);
    }

    // Fix missing x2
    cleanedJson = cleanedJson.replace(
      /\{"type":"line","x1":([^,]+),"y1":([^,]+),"y2":([^}]+)\}/g,
      '{"type":"line","x1":$1,"y1":$2,"x2":$1,"y2":$3}'
    );

    // Shorten long numbers
    cleanedJson = cleanedJson.replace(/(\d+\.\d{6})\d{4,}/g, "$1");
    cleanedJson = cleanedJson.replace(/,\s*([}\]])/g, "$1");

    let result;
    let retryIncomplete = 0;
    while (true) {
      try {
        console.log("ğŸ” [DEBUG] JSON.parse() cleanedJson:", cleanedJson.substring(0, 200));
        result = JSON.parse(cleanedJson);
        console.log("âœ… [DEBUG] JSON parsed ÃºspÄ›Å¡nÄ›!");
        break;
      } catch (e) {
        if (retryIncomplete < 2) {
          retryIncomplete++;
          console.warn(`âš ï¸ [DEBUG] JSON parse error (retry #${retryIncomplete}):`, e.message);
          await new Promise(res => setTimeout(res, 1000));
          // Znovu zavolej API (pouÅ¾ij stejnÃ½ prompt)
          const retryResponse = await window.retryWithBackoff(async () => {
            console.log("ğŸŒ [DEBUG] fetch() RETRY kvÅ¯li JSON parse error...", new Date().toISOString());
            return await fetch(
              "https://generativelanguage.googleapis.com/v1beta/models/" + selectedModel + ":generateContent?key=" + apiKey,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  contents: [{ parts: [{ text: fullPrompt }] }],
                  generationConfig: {
                    temperature: 0.7,
                    maxOutputTokens: 4096,
                  },
                }),
              }
            );
          }, 1);
          const retryJson = await retryResponse.json();
          aiResponseText = retryJson.candidates?.[0]?.content?.parts?.[0]?.text || "";
          window.lastRawAI = aiResponseText;
          cleanedJson = aiResponseText
            .replace(/```json\s*/gi, "")
            .replace(/```\s*/g, "");
          continue;
        } else {
          console.error("âŒ [DEBUG] JSON parse failed:", e.message);
          throw new Error("NevalidnÃ­ JSON odpovÄ›Ä");
        }
      }
    }

    const replyText = result.response_text || "Hotovo.";
    const newShapes = result.shapes || [];

    console.log("ğŸ’¾ [DEBUG] UklÃ¡dÃ¡m do window.lastAIResponse, shapes count:", newShapes.length);
    // UloÅ¾ AI odpovÄ›Ä pro pÅ™Ã­padnÃ½ report
    if (window.lastAIResponse === undefined) {
      window.lastAIResponse = {};
    }
    window.lastAIResponse = {
      rawResponse: aiResponseText,
      cleanedJson: cleanedJson,
      parsedResult: result,
      replyText: replyText,
      shapes: newShapes,
      timestamp: new Date().toISOString()
    };

    // Add shapes to canvas
    if (Array.isArray(newShapes) && newShapes.length > 0) {
      const xMeasureMode = window.xMeasureMode || "radius";

      newShapes.forEach((s) => {
        try {
          if (
            s.type === "line" &&
            typeof s.x1 === "number" &&
            typeof s.y1 === "number" &&
            typeof s.x2 === "number" &&
            typeof s.y2 === "number"
          ) {
            window.shapes.push({
              type: "line",
              x1: s.x1,
              y1: s.y1,
              x2: s.x2,
              y2: s.y2,
            });
          } else if (
            s.type === "circle" &&
            typeof s.cx === "number" &&
            typeof s.cy === "number" &&
            typeof s.r === "number" &&
            s.r > 0
          ) {
            // âš ï¸ AI vracÃ­ radius hodnoty pÅ™Ã­mo, NEkonvertuj diameter mode!
            // KdyÅ¾ AI Å™ekne "r":5, znamenÃ¡ to radius 5, ne prÅ¯mÄ›r
            window.shapes.push({
              type: "circle",
              cx: s.cx,
              cy: s.cy,
              r: s.r, // PouÅ¾ij pÅ™Ã­mo hodnotu od AI bez konverze
            });
          } else if (
            s.type === "arc" &&
            typeof s.cx === "number" &&
            typeof s.cy === "number" &&
            typeof s.r === "number" &&
            s.r > 0 &&
            typeof s.startAngle === "number" &&
            typeof s.endAngle === "number"
          ) {
            // PÅ™idej ARC (oblouk) pro tangenciÃ¡lnÃ­ zaoblenÃ­
            window.shapes.push({
              type: "arc",
              cx: s.cx,
              cy: s.cy,
              r: s.r,
              startAngle: s.startAngle,
              endAngle: s.endAngle,
              counterclockwise: s.counterclockwise !== undefined ? s.counterclockwise : false,
            });
          } else if (
            s.type === "point" &&
            typeof s.x === "number" &&
            typeof s.y === "number"
          ) {
            window.points.push({ x: s.x, y: s.y });
          }
        } catch (e) {
        }
      });

      if (window.updateSnapPoints) window.updateSnapPoints();

      // Try to draw and catch any rendering errors
      try {
        if (window.draw) window.draw();
      } catch (drawError) {
        console.error("âŒ Chyba pÅ™i vykreslovÃ¡nÃ­:", drawError);
        // Add drawing error to validation errors
        if (testIndex !== undefined) {
          validationErrors.push(`CHYBA PÅ˜I VYKRESLOVÃNÃ: ${drawError.message}`);
          hasErrors = true;
        }
      }

      // Learn from success
      window.recordAISuccess(prompt, newShapes);
    }

    // Add to chat
    const msgDiv = document.createElement("div");
    msgDiv.className = "chat-msg model";
    if (newShapes.length > 0) {
      msgDiv.innerHTML = `<span class="shape-tag">âœï¸ +${newShapes.length} tvarÅ¯</span><br>${escapeHtml(replyText)}`;
    } else {
      msgDiv.innerHTML = escapeHtml(replyText);
    }
    container.appendChild(msgDiv);
    container.scrollTop = container.scrollHeight;

    promptInput.value = "";
    window.clearImage?.();

    // Aktualizuj API usage stats
    apiUsageStats.totalCalls = (apiUsageStats.totalCalls || 0) + 1;
    apiUsageStats.dailyCalls = (apiUsageStats.dailyCalls || 0) + 1;
    saveApiStats();
    updateApiUsageUI();

  } catch (err) {

    if (container.contains(loadingDiv)) container.removeChild(loadingDiv);

    const errorDiv = document.createElement("div");
    errorDiv.className = "chat-msg model";
    errorDiv.style.color = "#ff6b6b";
    errorDiv.style.whiteSpace = "pre-wrap";

    let errorMsg = "âŒ " + (err.message || "NeznÃ¡mÃ¡ chyba");

    // LepÅ¡Ã­ zprÃ¡va pro quota exceeded
    if (err.message.includes("quota") || err.message.includes("Quota exceeded")) {
      errorMsg = "â³ KVÃ“TA PÅ˜EKROÄŒENA\n\nğŸ’¡ Aplikace jiÅ¾ automaticky Äekala a zkusila znovu.\n\nMoÅ¾nosti:\nâ€¢ ÄŒekej 1-2 minuty a zkus znovu\nâ€¢ PÅ™idej svÅ¯j vlastnÃ­ API klÃ­Ä (âš™ï¸ NastavenÃ­)\nâ€¢ Jdi na: https://console.cloud.google.com\n\nGemini 2.5 Flash Lite mÃ¡ 15 RPM limit na bezplatnÃ©m plÃ¡nu.";
    } else if (err.message.includes("API klÃ­Ä")) {
      errorMsg += "\n\nğŸ’¡ OtevÅ™i âš™ï¸ NastavenÃ­ a vloÅ¾ API klÃ­Ä.";
    }

    errorDiv.textContent = errorMsg;
    container.appendChild(errorDiv);
    container.scrollTop = container.scrollHeight;
  } finally {
    window.processingAI = false;
    promptInput.disabled = false;

    // Skryj Cancel button, zobraz Generate button
    const btnCancel = document.getElementById("btnCancel");
    const btnGenerate = document.getElementById("btnGenerate");
    if (btnCancel) btnCancel.style.display = "none";
    if (btnGenerate) btnGenerate.style.display = "inline-block";
  }
};

// ===== GROQ API CALL =====

/**
 * VolÃ¡nÃ­ Groq API (LPU inference).
 * Podporuje LLaMA, Mixtral a dalÅ¡Ã­ modely.
 * @async
 * @returns {Promise<void>}
 */
window.callGroqDirect = async function () {
  console.log("âš¡ [DEBUG] callGroqDirect() SPUÅ TÄšNO", new Date().toISOString());
  const promptInput = document.getElementById("aiPrompt");
  const container = document.getElementById("aiChatHistory");
  if (!promptInput || !container) return;

  const prompt = promptInput.value.trim();
  if (!prompt) return;

  console.log("ğŸ”’ [DEBUG] Nastavuji processingAI = true");
  window.processingAI = true;
  promptInput.disabled = true;

  // Zobraz user zprÃ¡vu hned
  const userMsgDiv = document.createElement("div");
  userMsgDiv.className = "chat-msg user";
  userMsgDiv.style.marginBottom = "10px";
  userMsgDiv.innerHTML = `<strong>Ty:</strong> ${escapeHtml(prompt)}`;
  container.appendChild(userMsgDiv);
  container.scrollTop = container.scrollHeight;

  // Add loading indicator
  const loadingDiv = document.createElement("div");
  loadingDiv.style.cssText = "text-align: center; color: #666; padding: 12px; font-size: 12px;";
  loadingDiv.innerHTML = '<div class="loading-dots"><div></div><div></div><div></div></div> ÄŒekÃ¡m na Groq...';
  container.appendChild(loadingDiv);
  container.scrollTop = container.scrollHeight;

  try {
    const apiKey = window.getCurrentGroqApiKey ? window.getCurrentGroqApiKey() : null;
    if (!apiKey) {
      throw new Error("NemÃ¡te Groq API klÃ­Ä. OtevÅ™ete âš™ï¸ NastavenÃ­ â†’ Groq.");
    }

    // Build system prompt (stejnÃ½ jako pro Gemini)
    const modeIndicator = window.mode ? `Current mode: ${window.mode}` : "";
    const xMeasureMode = window.xMeasureMode || "radius";
    const learningContext = window.getAIMemoryContext ? window.getAIMemoryContext() : "";

    const modeExplanation =
      xMeasureMode === "diameter"
        ? `X-AXIS MODE: DIAMETER (âŒ€)
User shows values as diameter from center axis.
Example: User says "X=100" = 50mm from center (radius=50)
You MUST respond with DIAMETER values: "X=100" even though internal radius=50
The application will automatically convert diameterâ†’radius for rendering.`
        : `X-AXIS MODE: RADIUS (R)
User shows values as radius distance from center axis.
Example: User says "X=50" = exactly 50mm from center
You MUST respond with RADIUS values: "X=50"
No conversion needed, use values exactly as specified.`;

    const systemPrompt = `CAD Assistant for CNC Lathe/Mill operations (Czech language).

COORDINATE SYSTEM:
Z-axis (horizontal/â†’) = JSON 'x' property
X-axis (vertical/â†‘) = JSON 'y' property
Origin: (0,0) center
Report coords as: "Z=[x] X=[y]"

ğŸ”§ CURRENT MODE: ${modeIndicator}
${modeExplanation}

RESPONSE FORMAT (strict JSON only):
{"response_text":"Brief Czech confirmation <50 chars","shapes":[...]}

SHAPE TYPES:
Line: {"type":"line","x1":z1,"y1":x1,"x2":z2,"y2":x2}
Circle: {"type":"circle","cx":z,"cy":x,"r":radius}
Point: {"type":"point","x":z,"y":x}

${learningContext}`;

    const contextInfo = window.buildDrawingContext ? window.buildDrawingContext() : "PrÃ¡zdnÃ© kreslenÃ­";

    const fullPrompt = `${systemPrompt}

AktuÃ¡lnÃ­ kreslenÃ­:
${contextInfo}

UÅ¾ivatel: ${prompt}`;

    // Determine AI type (cnc / chat)
    const aiType = document.getElementById('aiTypeSelect')?.value || 'cnc';

    // Get selected model
    const modelSelect = document.getElementById("aiModelSelect");
    const selectedModel = modelSelect?.value;
    if (!selectedModel) {
      throw new Error("NenÃ­ vybrÃ¡n Å¾Ã¡dnÃ½ model. Vyber model v nastavenÃ­.");
    }

    // Prepare messages
    let messages = [];

    // Check if model supports vision and we have an image
    const isVisionModel = window.GROQ_VISION_MODELS && window.GROQ_VISION_MODELS.includes(selectedModel);
    const hasImage = window.currentImageBase64 && window.currentImageMimeType;

    if (isVisionModel && hasImage) {
      // Vision model with image
      messages.push({
        role: "user",
        content: [
          { type: "text", text: fullPrompt },
          {
            type: "image_url",
            image_url: {
              url: `data:${window.currentImageMimeType};base64,${window.currentImageBase64}`
            }
          }
        ]
      });
    } else {
      // Text-only
      messages.push({
        role: "user",
        content: fullPrompt
      });
    }

    // Call Groq API
    const startTime = performance.now();
    console.log("ğŸŒ [DEBUG] Groq API fetch()...", new Date().toISOString());

    const response = await fetch("https://api.groq.com/openai/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": "Bearer " + apiKey,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: selectedModel,
        messages: messages,
        temperature: 0.7,
        max_tokens: 4096
      })
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.error?.message || `HTTP ${response.status}`);
    }

    const data = await response.json();
    const apiTime = performance.now() - startTime;

    if (container.contains(loadingDiv)) container.removeChild(loadingDiv);

    // Parse response
    console.log("ğŸ“¦ [DEBUG] ParsovÃ¡nÃ­ Groq odpovÄ›di...");
    let aiResponseText = data.choices?.[0]?.message?.content || "";

    // Pro reasoning modely (GPT OSS) mÅ¯Å¾e bÃ½t odpovÄ›Ä v "reasoning" poli
    if (!aiResponseText && data.choices?.[0]?.message?.reasoning) {
      aiResponseText = data.choices?.[0]?.message?.reasoning;
      console.log("ğŸ’­ [DEBUG] Reasoning model - extrahovÃ¡n reasoning:", aiResponseText.substring(0, 100));
    }

    if (!aiResponseText) {
      console.error("âŒ [DEBUG] Groq nevrÃ¡tila text!");
      console.error("Raw data:", data);
      throw new Error("Groq nevrÃ¡tila text");
    }

    // UloÅ¾ pro debugging
    window.lastRawAI = aiResponseText;
    console.log("ğŸ“„ [DEBUG] Groq raw response (CELÃ):");
    console.log(aiResponseText);
    console.log("ğŸ“ [DEBUG] DÃ©lka odpovÄ›di:", aiResponseText.length, "znakÅ¯");

    // If Chat mode, treat response as plain text
    if (aiType === 'chat') {
      const replyTextChat = aiResponseText;

      // Append AI chat message
      const msgDiv = document.createElement('div');
      msgDiv.className = 'chat-msg model';
      msgDiv.style.marginBottom = '10px';
      msgDiv.innerHTML = `<strong>Groq:</strong> ${escapeHtml(replyTextChat)}`;
      container.appendChild(msgDiv);
      container.scrollTop = container.scrollHeight;

      // Restore UI state
      window.processingAI = false;
      promptInput.disabled = false;
      const btnCancel = document.getElementById('btnCancel');
      const btnGenerate = document.getElementById('btnGenerate');
      if (btnCancel) btnCancel.style.display = 'none';
      if (btnGenerate) btnGenerate.style.display = 'inline-block';

      // Update usage UI
      if (updateApiUsageUI) updateApiUsageUI();

      return;
    }

    // CNC/2D mode - parse JSON
    let aiReply = window.parseAIReply(aiResponseText);
    if (!aiReply) {
      throw new Error("AI nevrÃ¡tila JSON. Raw: " + aiResponseText.substring(0, 200));
    }

    const replyText = aiReply.response_text || "OK";
    const newShapes = aiReply.shapes || [];

    console.log("âœ… [DEBUG] ÃšspÄ›Å¡nÄ› naparsovÃ¡no:", newShapes.length, "tvarÅ¯");
    console.log("ğŸ’¬ [DEBUG] AI reply text:", replyText);

    // Add shapes to canvas
    if (newShapes.length > 0 && window.shapes) {
      newShapes.forEach(shape => window.shapes.push(shape));
      if (window.updateSnapPoints) window.updateSnapPoints();
      if (window.draw) window.draw();
      if (window.recordAISuccess) window.recordAISuccess(prompt, newShapes);
    }

    // Add to chat
    const msgDiv = document.createElement("div");
    msgDiv.className = "chat-msg model";
    if (newShapes.length > 0) {
      msgDiv.innerHTML = `<span class="shape-tag">âš¡ +${newShapes.length} tvarÅ¯ (Groq)</span><br>${escapeHtml(replyText)}`;
    } else {
      msgDiv.innerHTML = `<strong>Groq:</strong> ${escapeHtml(replyText)}`;
    }
    container.appendChild(msgDiv);
    container.scrollTop = container.scrollHeight;

    promptInput.value = "";
    if (window.clearImage) window.clearImage();

    // Aktualizuj API usage stats
    apiUsageStats.totalCalls = (apiUsageStats.totalCalls || 0) + 1;
    apiUsageStats.dailyCalls = (apiUsageStats.dailyCalls || 0) + 1;
    saveApiStats();
    updateApiUsageUI();

  } catch (err) {
    if (container.contains(loadingDiv)) container.removeChild(loadingDiv);

    const errorDiv = document.createElement("div");
    errorDiv.className = "chat-msg model";
    errorDiv.style.color = "#ff6b6b";
    errorDiv.style.whiteSpace = "pre-wrap";

    let errorMsg = "âŒ Groq chyba: " + (err.message || "NeznÃ¡mÃ¡ chyba");

    if (err.message.includes("API klÃ­Ä") || err.message.includes("Unauthorized")) {
      errorMsg += "\n\nğŸ’¡ OtevÅ™i âš™ï¸ NastavenÃ­ â†’ Groq a vloÅ¾ API klÃ­Ä.";
    }

    errorDiv.textContent = errorMsg;
    container.appendChild(errorDiv);
    container.scrollTop = container.scrollHeight;
  } finally {
    window.processingAI = false;
    promptInput.disabled = false;

    // Skryj Cancel button, zobraz Generate button
    const btnCancel = document.getElementById("btnCancel");
    const btnGenerate = document.getElementById("btnGenerate");
    if (btnCancel) btnCancel.style.display = "none";
    if (btnGenerate) btnGenerate.style.display = "inline-block";
  }
};

// ===== OPENROUTER API CALL =====

/**
 * VolÃ¡nÃ­ OpenRouter API.
 * UmoÅ¾Åˆuje pÅ™Ã­stup k mnoha modelÅ¯m (GPT-4, Claude, LLaMA, atd.)
 * @async
 * @returns {Promise<void>}
 */
window.callOpenRouterDirect = async function () {
  console.log("ğŸŒ [DEBUG] callOpenRouterDirect() SPUÅ TÄšNO", new Date().toISOString());
  const promptInput = document.getElementById("aiPrompt");
  const container = document.getElementById("aiChatHistory");
  if (!promptInput || !container) return;

  const prompt = promptInput.value.trim();
  if (!prompt) return;

  console.log("ğŸ”’ [DEBUG] Nastavuji processingAI = true");
  window.processingAI = true;
  promptInput.disabled = true;

  // Zobraz user zprÃ¡vu hned
  const userMsgDiv = document.createElement("div");
  userMsgDiv.className = "chat-msg user";
  userMsgDiv.style.marginBottom = "10px";
  userMsgDiv.innerHTML = `<strong>Ty:</strong> ${escapeHtml(prompt)}`;
  container.appendChild(userMsgDiv);
  container.scrollTop = container.scrollHeight;

  // Add loading indicator
  const loadingDiv = document.createElement("div");
  loadingDiv.style.cssText = "text-align: center; color: #666; padding: 12px; font-size: 12px;";
  loadingDiv.innerHTML = '<div class="loading-dots"><div></div><div></div><div></div></div> ÄŒekÃ¡m na odpovÄ›Ä...';
  container.appendChild(loadingDiv);
  container.scrollTop = container.scrollHeight;

  try {
    const apiKey = window.getCurrentOpenRouterApiKey ? window.getCurrentOpenRouterApiKey() : null;
    if (!apiKey) {
      throw new Error("Å½Ã¡dnÃ½ OpenRouter API klÃ­Ä. OtevÅ™i âš™ï¸ NastavenÃ­ â†’ OpenRouter a vloÅ¾ API klÃ­Ä.");
    }

    // Determine AI type (2d / cnc / chat)
    const aiType = document.getElementById('aiTypeSelect')?.value || '2d';

    // Prepare system prompt based on type
    let systemPrompt = "";
    if (aiType === 'cnc') {
      systemPrompt = window.getCNCSystemPrompt ? window.getCNCSystemPrompt() : "";
    } else if (aiType === '2d') {
      systemPrompt = window.get2DSystemPrompt ? window.get2DSystemPrompt() : "";
    }

    const contextInfo = window.buildDrawingContext ? window.buildDrawingContext() : "PrÃ¡zdnÃ© kreslenÃ­";

    const fullPrompt = `${systemPrompt}

AktuÃ¡lnÃ­ kreslenÃ­:
${contextInfo}

UÅ¾ivatel: ${prompt}`;

    // Get selected model
    const modelSelect = document.getElementById("aiModelSelect");
    const selectedModel = modelSelect?.value || "google/gemini-2.0-flash-exp:free";

    // Prepare messages
    const messages = [
      {
        role: "user",
        content: fullPrompt
      }
    ];

    // Call OpenRouter API
    const startTime = performance.now();
    console.log("ğŸŒ [DEBUG] OpenRouter API fetch()...", new Date().toISOString());

    const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": "Bearer " + apiKey,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: selectedModel,
        messages: messages,
        temperature: 0.7,
        max_tokens: 4096
      })
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.error?.message || `HTTP ${response.status}`);
    }

    const data = await response.json();
    const apiTime = performance.now() - startTime;

    if (container.contains(loadingDiv)) container.removeChild(loadingDiv);

    // Parse response
    console.log("ğŸ“¦ [DEBUG] ParsovÃ¡nÃ­ OpenRouter odpovÄ›di...");
    let aiResponseText = data.choices?.[0]?.message?.content || "";
    if (!aiResponseText) {
      console.error("âŒ [DEBUG] OpenRouter nevrÃ¡tila text!");
      throw new Error("OpenRouter nevrÃ¡tila text");
    }

    // UloÅ¾ pro debugging
    window.lastRawAI = aiResponseText;
    console.log("ğŸ“„ [DEBUG] OpenRouter raw response (CELÃ):");
    console.log(aiResponseText);
    console.log("ğŸ“ [DEBUG] DÃ©lka odpovÄ›di:", aiResponseText.length, "znakÅ¯");

    // If Chat mode, treat response as plain text
    if (aiType === 'chat') {
      const replyTextChat = aiResponseText;

      // Append AI chat message
      const msgDiv = document.createElement('div');
      msgDiv.className = 'chat-msg model';
      msgDiv.style.marginBottom = '10px';
      msgDiv.innerHTML = `<strong>OpenRouter:</strong> ${escapeHtml(replyTextChat)}`;
      container.appendChild(msgDiv);
      container.scrollTop = container.scrollHeight;

      // Restore UI state
      window.processingAI = false;
      promptInput.disabled = false;
      const btnCancel = document.getElementById('btnCancel');
      const btnGenerate = document.getElementById('btnGenerate');
      if (btnCancel) btnCancel.style.display = 'none';
      if (btnGenerate) btnGenerate.style.display = 'inline-block';

      // Update usage UI
      if (updateApiUsageUI) updateApiUsageUI();

      return;
    }

    // CNC/2D mode - parse JSON
    let aiReply = window.parseAIReply(aiResponseText);
    if (!aiReply) {
      throw new Error("AI nevrÃ¡tila JSON. Raw: " + aiResponseText.substring(0, 200));
    }

    const replyText = aiReply.response_text || "OK";
    const newShapes = aiReply.shapes || [];

    console.log("âœ… [DEBUG] ÃšspÄ›Å¡nÄ› naparsovÃ¡no:", newShapes.length, "tvarÅ¯");
    console.log("ğŸ’¬ [DEBUG] AI reply text:", replyText);

    // Add shapes to canvas
    if (newShapes.length > 0 && window.shapes) {
      newShapes.forEach(shape => window.shapes.push(shape));
      if (window.updateSnapPoints) window.updateSnapPoints();
      if (window.draw) window.draw();
      if (window.recordAISuccess) window.recordAISuccess(prompt, newShapes);
    }

    // Add to chat
    const msgDiv = document.createElement("div");
    msgDiv.className = "chat-msg model";
    if (newShapes.length > 0) {
      msgDiv.innerHTML = `<span class="shape-tag">ğŸŒ +${newShapes.length} tvarÅ¯ (OpenRouter)</span><br>${escapeHtml(replyText)}`;
    } else {
      msgDiv.innerHTML = `<strong>OpenRouter:</strong> ${escapeHtml(replyText)}`;
    }
    container.appendChild(msgDiv);
    container.scrollTop = container.scrollHeight;

    promptInput.value = "";

    // Aktualizuj API usage stats
    apiUsageStats.totalCalls = (apiUsageStats.totalCalls || 0) + 1;
    apiUsageStats.dailyCalls = (apiUsageStats.dailyCalls || 0) + 1;
    saveApiStats();
    updateApiUsageUI();

  } catch (err) {
    if (container.contains(loadingDiv)) container.removeChild(loadingDiv);

    const errorDiv = document.createElement("div");
    errorDiv.className = "chat-msg model";
    errorDiv.style.color = "#ff6b6b";
    errorDiv.style.whiteSpace = "pre-wrap";

    let errorMsg = "âŒ OpenRouter chyba: " + (err.message || "NeznÃ¡mÃ¡ chyba");

    if (err.message.includes("API klÃ­Ä") || err.message.includes("Unauthorized")) {
      errorMsg += "\n\nğŸ’¡ OtevÅ™i âš™ï¸ NastavenÃ­ â†’ OpenRouter a vloÅ¾ API klÃ­Ä.";
    }

    errorDiv.textContent = errorMsg;
    container.appendChild(errorDiv);
    container.scrollTop = container.scrollHeight;
  } finally {
    window.processingAI = false;
    promptInput.disabled = false;

    // Skryj Cancel button, zobraz Generate button
    const btnCancel = document.getElementById("btnCancel");
    const btnGenerate = document.getElementById("btnGenerate");
    if (btnCancel) btnCancel.style.display = "none";
    if (btnGenerate) btnGenerate.style.display = "inline-block";
  }
};

// ===== MISTRAL API CALL =====

/**
 * VolÃ¡nÃ­ Mistral AI API.
 * Podporuje Mistral modely (Small, Medium, Large).
 * @async
 * @returns {Promise<void>}
 */
window.callMistralDirect = async function () {
  console.log("ğŸ”¥ [DEBUG] callMistralDirect() SPUÅ TÄšNO", new Date().toISOString());
  const promptInput = document.getElementById("aiPrompt");
  const container = document.getElementById("aiChatHistory");
  if (!promptInput || !container) return;

  const prompt = promptInput.value.trim();
  if (!prompt) return;

  console.log("ğŸ”’ [DEBUG] Nastavuji processingAI = true");
  window.processingAI = true;
  promptInput.disabled = true;

  // Zobraz user zprÃ¡vu hned
  const userMsgDiv = document.createElement("div");
  userMsgDiv.className = "chat-msg user";
  userMsgDiv.style.marginBottom = "10px";
  userMsgDiv.innerHTML = `<strong>Ty:</strong> ${escapeHtml(prompt)}`;
  container.appendChild(userMsgDiv);
  container.scrollTop = container.scrollHeight;

  // Add loading indicator
  const loadingDiv = document.createElement("div");
  loadingDiv.style.cssText = "text-align: center; color: #666; padding: 12px; font-size: 12px;";
  loadingDiv.innerHTML = '<div class="loading-dots"><div></div><div></div><div></div></div> ÄŒekÃ¡m na odpovÄ›Ä...';
  container.appendChild(loadingDiv);
  container.scrollTop = container.scrollHeight;

  try {
    const apiKey = window.getCurrentMistralApiKey ? window.getCurrentMistralApiKey() : null;
    if (!apiKey) {
      throw new Error("Å½Ã¡dnÃ½ Mistral API klÃ­Ä. OtevÅ™i âš™ï¸ NastavenÃ­ â†’ Mistral a vloÅ¾ API klÃ­Ä.");
    }

    // Determine AI type (2d / cnc / chat)
    const aiType = document.getElementById('aiTypeSelect')?.value || '2d';

    // Prepare system prompt based on type
    let systemPrompt = "";
    if (aiType === 'cnc') {
      systemPrompt = window.getCNCSystemPrompt ? window.getCNCSystemPrompt() : "";
    } else if (aiType === '2d') {
      systemPrompt = window.get2DSystemPrompt ? window.get2DSystemPrompt() : "";
    }

    const contextInfo = window.buildDrawingContext ? window.buildDrawingContext() : "PrÃ¡zdnÃ© kreslenÃ­";

    const fullPrompt = `${systemPrompt}

AktuÃ¡lnÃ­ kreslenÃ­:
${contextInfo}

UÅ¾ivatel: ${prompt}`;

    // Get selected model
    const modelSelect = document.getElementById("aiModelSelect");
    const selectedModel = modelSelect?.value || "codestral-latest";

    // Prepare messages
    const messages = [
      {
        role: "user",
        content: fullPrompt
      }
    ];

    // Call Mistral API
    const startTime = performance.now();
    console.log("ğŸŒ [DEBUG] Mistral API fetch()...", new Date().toISOString());

    const response = await fetch("https://api.mistral.ai/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": "Bearer " + apiKey,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: selectedModel,
        messages: messages,
        temperature: 0.7,
        max_tokens: 4096
      })
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.error?.message || `HTTP ${response.status}`);
    }

    const data = await response.json();
    const apiTime = performance.now() - startTime;

    if (container.contains(loadingDiv)) container.removeChild(loadingDiv);

    // Parse response
    console.log("ğŸ“¦ [DEBUG] ParsovÃ¡nÃ­ Mistral odpovÄ›di...");
    let aiResponseText = data.choices?.[0]?.message?.content || "";
    if (!aiResponseText) {
      console.error("âŒ [DEBUG] Mistral nevrÃ¡tila text!");
      throw new Error("Mistral nevrÃ¡tila text");
    }

    // UloÅ¾ pro debugging
    window.lastRawAI = aiResponseText;
    console.log("ğŸ“„ [DEBUG] Mistral raw response (CELÃ):");
    console.log(aiResponseText);
    console.log("ğŸ“ [DEBUG] DÃ©lka odpovÄ›di:", aiResponseText.length, "znakÅ¯");

    // If Chat mode, treat response as plain text
    if (aiType === 'chat') {
      const replyTextChat = aiResponseText;

      // Append AI chat message
      const msgDiv = document.createElement('div');
      msgDiv.className = 'chat-msg model';
      msgDiv.style.marginBottom = '10px';
      msgDiv.innerHTML = `<strong>Mistral:</strong> ${escapeHtml(replyTextChat)}`;
      container.appendChild(msgDiv);
      container.scrollTop = container.scrollHeight;

      // Restore UI state
      window.processingAI = false;
      promptInput.disabled = false;
      const btnCancel = document.getElementById('btnCancel');
      const btnGenerate = document.getElementById('btnGenerate');
      if (btnCancel) btnCancel.style.display = 'none';
      if (btnGenerate) btnGenerate.style.display = 'inline-block';

      // Update usage UI
      if (updateApiUsageUI) updateApiUsageUI();

      return;
    }

    // CNC/2D mode - parse JSON
    let aiReply = window.parseAIReply(aiResponseText);
    if (!aiReply) {
      throw new Error("AI nevrÃ¡tila JSON. Raw: " + aiResponseText.substring(0, 200));
    }

    const replyText = aiReply.response_text || "OK";
    const newShapes = aiReply.shapes || [];

    console.log("âœ… [DEBUG] ÃšspÄ›Å¡nÄ› naparsovÃ¡no:", newShapes.length, "tvarÅ¯");
    console.log("ğŸ’¬ [DEBUG] AI reply text:", replyText);

    // Add shapes to canvas
    if (newShapes.length > 0 && window.shapes) {
      newShapes.forEach(shape => window.shapes.push(shape));
      if (window.updateSnapPoints) window.updateSnapPoints();
      if (window.draw) window.draw();
      if (window.recordAISuccess) window.recordAISuccess(prompt, newShapes);
    }

    // Add to chat
    const msgDiv = document.createElement("div");
    msgDiv.className = "chat-msg model";
    if (newShapes.length > 0) {
      msgDiv.innerHTML = `<span class="shape-tag">ğŸ”¥ +${newShapes.length} tvarÅ¯ (Mistral)</span><br>${escapeHtml(replyText)}`;
    } else {
      msgDiv.innerHTML = `<strong>Mistral:</strong> ${escapeHtml(replyText)}`;
    }
    container.appendChild(msgDiv);
    container.scrollTop = container.scrollHeight;

    promptInput.value = "";

    // Aktualizuj API usage stats
    apiUsageStats.totalCalls = (apiUsageStats.totalCalls || 0) + 1;
    apiUsageStats.dailyCalls = (apiUsageStats.dailyCalls || 0) + 1;
    saveApiStats();
    updateApiUsageUI();

  } catch (err) {
    if (container.contains(loadingDiv)) container.removeChild(loadingDiv);

    const errorDiv = document.createElement("div");
    errorDiv.className = "chat-msg model";
    errorDiv.style.color = "#ff6b6b";
    errorDiv.style.whiteSpace = "pre-wrap";

    let errorMsg = "âŒ Mistral chyba: " + (err.message || "NeznÃ¡mÃ¡ chyba");

    if (err.message.includes("API klÃ­Ä") || err.message.includes("Unauthorized")) {
      errorMsg += "\n\nğŸ’¡ OtevÅ™i âš™ï¸ NastavenÃ­ â†’ Mistral a vloÅ¾ API klÃ­Ä.";
    }

    errorDiv.textContent = errorMsg;
    container.appendChild(errorDiv);
    container.scrollTop = container.scrollHeight;
  } finally {
    window.processingAI = false;
    promptInput.disabled = false;

    // Skryj Cancel button, zobraz Generate button
    const btnCancel = document.getElementById("btnCancel");
    const btnGenerate = document.getElementById("btnGenerate");
    if (btnCancel) btnCancel.style.display = "none";
    if (btnGenerate) btnGenerate.style.display = "inline-block";
  }
};

window.buildDrawingContext = function () {
  const shapes = window.shapes || [];
  const points = window.points || [];
  let context = "";

  if (points.length > 0) {
    context += `ğŸ”¹ BODY (${points.length}):\n`;
    points.forEach((p, i) => {
      context += `  ${i + 1}. [${p.x.toFixed(1)}, ${p.y.toFixed(1)}]\n`;
    });
  }

  if (shapes.length > 0) {
    context += `\nğŸ“ OBJEKTY (${shapes.length}):\n`;
    shapes.forEach((s, i) => {
      if (s.type === "line") {
        const len = Math.sqrt((s.x2 - s.x1) ** 2 + (s.y2 - s.y1) ** 2).toFixed(1);
        context += `  ${i + 1}. ÄŒÃ¡ra: [${s.x1.toFixed(1)},${s.y1.toFixed(1)}] â†’ [${s.x2.toFixed(1)},${s.y2.toFixed(1)}] (dÃ©lka: ${len})\n`;
      } else if (s.type === "circle") {
        context += `  ${i + 1}. KruÅ¾nice: stÅ™ed [${s.cx.toFixed(1)},${s.cy.toFixed(1)}], r=${s.r.toFixed(1)}\n`;
      } else if (s.type === "arc") {
        context += `  ${i + 1}. Oblouk: [${s.x1.toFixed(1)},${s.y1.toFixed(1)}] â†’ [${s.x2.toFixed(1)},${s.y2.toFixed(1)}], Ãºhel=${(s.angle || 0).toFixed(1)}Â°\n`;
      }
    });
  }

  if (context === "") {
    context = "PrÃ¡zdnÃ© kreslenÃ­ - zatÃ­m nic";
  }

  return context;
};

window.clearChat = function () {
  const chatWindow = document.getElementById("chatWindow");
  if (chatWindow) {
    chatWindow.innerHTML = "";
  }
  chatHistory = [];
};

window.loadAIMemory = function () {
  const chatWindow = document.getElementById("chatWindow");
  if (!chatWindow) return;

  // NaÄti historii z localStorage
  try {
    const stored = localStorage.getItem("ai_chat_history");
    if (stored) {
      window.chatHistory = JSON.parse(stored);
      chatWindow.innerHTML = "";

      window.chatHistory.forEach((entry) => {
        const userMsg = document.createElement("div");
        userMsg.className = "message user-message";
        userMsg.innerHTML = `<strong>Ty:</strong> ${escapeHtml(entry.user)}`;
        chatWindow.appendChild(userMsg);

        const aiMsg = document.createElement("div");
        aiMsg.className = "message ai-message";
        aiMsg.innerHTML = `<strong>Gemini:</strong> ${escapeHtml(entry.ai)}`;
        chatWindow.appendChild(aiMsg);
      });

      chatWindow.scrollTop = chatWindow.scrollHeight;
    }
  } catch (e) {
  }
};

// Funkce pro uloÅ¾enÃ­ chat historie do localStorage
window.saveChatHistory = function () {
  try {
    localStorage.setItem("ai_chat_history", JSON.stringify(window.chatHistory || []));
  } catch (e) {
  }
};

window.showAiStats = function () {
  const modal = document.getElementById("aiStatsModal") || createStatsModal();
  if (modal) {
    modal.style.display = "flex";
    if (window.updateAiStats) window.updateAiStats();
  }
};

function createStatsModal() {
  const modal = document.createElement("div");
  modal.id = "aiStatsModal";
  modal.className = "modal";
  modal.style.display = "none";
  modal.innerHTML = `
    <div class="modal-content">
      <h3>ğŸ“Š Statistika AI</h3>
      <div id="statsContent" style="margin-top: 15px; font-size: 14px; line-height: 1.8;">
        <p>Inicialisuje se...</p>
      </div>
      <button onclick="document.getElementById('aiStatsModal').style.display='none'" style="margin-top: 15px;">ZavÅ™Ã­t</button>
    </div>
  `;
  document.body.appendChild(modal);

  modal.addEventListener("click", (e) => {
    if (e.target === modal) modal.style.display = "none";
  });

  return modal;
}

window.updateAiStats = function () {
  const statsContent = document.getElementById("statsContent");
  if (!statsContent) return;

  const memory = window.getAIMemoryContext ? window.getAIMemoryContext() : {};
  const commandCount = memory.commands ? memory.commands.length : 0;
  const correctionCount = memory.corrections ? memory.corrections.length : 0;
  const totalInteractions = chatHistory.length;

  const stats = `
    <strong>ğŸ“ Interakce:</strong> ${totalInteractions}<br>
    <strong>ğŸ“Œ PÅ™Ã­kazÅ¯:</strong> ${commandCount}<br>
    <strong>âœï¸ Oprav:</strong> ${correctionCount}<br>
    <strong>ğŸ’¾ ChyÅ¥Å¯:</strong> ${new Date().toLocaleString()}<br>
  `;

  statsContent.innerHTML = stats;
};

function escapeHtml(text) {
  const map = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#039;",
  };
  return text.replace(/[&<>"']/g, (m) => map[m]);
}

window.updateSelectionUI = function () {
  const selectedCount = window.selectedItems ? window.selectedItems.length : 0;
  const infoEl = document.getElementById("selectionInfo");

  if (infoEl) {
    if (selectedCount > 0) {
      let infoText = `ğŸ“Œ VybrÃ¡no: ${selectedCount} objektÅ¯`;

      // PÅ™idej vzdÃ¡lenost pokud jsou vybranÃ© 2 body
      if (selectedCount === 2) {
        const item1 = window.selectedItems[0];
        const item2 = window.selectedItems[1];

        if (item1.category === "point" && item2.category === "point") {
          const dist = Math.sqrt((item1.x - item2.x) ** 2 + (item1.y - item2.y) ** 2);
          infoText += ` | ğŸ“ VzdÃ¡lenost AB: ${dist.toFixed(2)} mm`;
        }
      }

      // PÅ™idej informaci o stÅ™Ã­davÃ½ch typech
      if (selectedCount >= 2) {
        const hasPoints = window.selectedItems.some(i => i.category === "point");
        const hasShapes = window.selectedItems.some(i => i.category === "shape");

        if (hasPoints && hasShapes) {
          infoText += " | âš™ï¸ (bod+tvar)";
        }
      }

      infoEl.textContent = infoText;
      infoEl.style.display = "block";
    } else {
      infoEl.style.display = "none";
    }
  }
};

// ===== EVENT LISTENERS =====

document.addEventListener("DOMContentLoaded", function () {
  // âœ… Keyboard handler pro aiPrompt nynÃ­ spravuje unified keyboard.js
  // Enter v aiPrompt nynÃ­ volÃ¡ window.callGemini pÅ™es keyboard.js

  const btnSendAi = document.getElementById("btnSendAi");
  if (btnSendAi) {
    btnSendAi.addEventListener("click", function () {
      if (window.callGemini) window.callGemini();
    });
  }

  const btnClearChat = document.getElementById("btnClearChat");
  if (btnClearChat) {
    btnClearChat.addEventListener("click", function () {
      if (confirm("Smazat chat historii?")) {
        window.clearChat();
      }
    });
  }

  // Event listener removed - using inline onclick="window.showToolCategory('ai')" instead
  // (Was causing double-invocation: onclick + event listener)
});

// ===== HELPER: Build drawing context =====
window.buildDrawingContext = function () {
  const shapes = window.shapes || [];
  const points = window.points || [];
  const selectedItems = window.selectedItems || [];
  let context = "";

  // Zobraz vybranÃ© objekty
  if (selectedItems.length > 0) {
    context += `â­ VYBRANÃ‰ OBJEKTY (${selectedItems.length}):\n`;
    selectedItems.forEach((item) => {
      if (item.category === "point") {
        context += `  âœ“ Bod [${item.x?.toFixed(1) || "?"}, ${item.y?.toFixed(1) || "?"}] (Label: ${item.label || "?"})\n`;
      } else if (item.category === "shape" && item.type) {
        if (item.type === "circle") {
          context += `  âœ“ KruÅ¾nice: stÅ™ed [${item.cx?.toFixed(1) || "?"}, ${item.cy?.toFixed(1) || "?"}], r=${item.r?.toFixed(1) || "?"} (Label: ${item.label || "?"})\n`;
        } else if (item.type === "line") {
          context += `  âœ“ ÄŒÃ¡ra: [${item.x1?.toFixed(1) || "?"}, ${item.y1?.toFixed(1) || "?"}] â†’ [${item.x2?.toFixed(1) || "?"}, ${item.y2?.toFixed(1) || "?"}] (Label: ${item.label || "?"})\n`;
        } else {
          context += `  âœ“ ${item.type}: (Label: ${item.label || "?"})\n`;
        }
      }
    });
    context += "\n";
  }

  if (points.length > 0) {
    context += `ğŸ”¹ BODY (${points.length}):\n`;
    points.forEach((p, i) => {
      context += `  ${i + 1}. [${p.x.toFixed(1)}, ${p.y.toFixed(1)}]\n`;
    });
  }

  if (shapes.length > 0) {
    context += `\nğŸ“ OBJEKTY (${shapes.length}):\n`;
    shapes.forEach((s, i) => {
      if (s.type === "line") {
        const len = Math.sqrt(((s.x2 || 0) - (s.x1 || 0)) ** 2 + ((s.y2 || 0) - (s.y1 || 0)) ** 2).toFixed(1);
        context += `  ${i + 1}. ÄŒÃ¡ra: [${(s.x1 || 0).toFixed(1)},${(s.y1 || 0).toFixed(1)}] â†’ [${(s.x2 || 0).toFixed(1)},${(s.y2 || 0).toFixed(1)}] (dÃ©lka: ${len})\n`;
      } else if (s.type === "circle") {
        context += `  ${i + 1}. KruÅ¾nice: stÅ™ed [${(s.cx || 0).toFixed(1)},${(s.cy || 0).toFixed(1)}], r=${(s.r || 0).toFixed(1)}\n`;
      } else if (s.type === "arc") {
        context += `  ${i + 1}. Oblouk: [${(s.x1 || 0).toFixed(1)},${(s.y1 || 0).toFixed(1)}] â†’ [${(s.x2 || 0).toFixed(1)},${(s.y2 || 0).toFixed(1)}], Ãºhel=${((s.angle || 0)).toFixed(1)}Â°\n`;
      }
    });
  }

  return context || "PrÃ¡zdnÃ© kreslenÃ­ - zatÃ­m nic";
};

// ===== AI TEST SUITE =====
window.AI_TEST_PROMPTS = [
  // ===== KOMPLEXNÃ TEST (VÅ E V JEDNOM) =====
  {
    level: "KOMPLEXNÃ",
    name: "ğŸ¯ KOMPLETNÃ TEST - VÅ¡echny hlavnÃ­ funkce",
    prompt: "bod Z50 X50, kruÅ¾nice Z100 X100 R40, X200Z100R30, ÄÃ¡ra Z50 X50 do Z100 X100, kruÅ¾nice Z150 X150 R50 pak ÄÃ¡ra od stÅ™edu Ãºhel 0Â° dÃ©lka 100, ÄÃ¡ra Z300 X50 do Z400 X150",
    expectedShapes: 7,
    expectedType: ["point", "circle", "circle", "line", "circle", "line", "line"],
    complexity: 10,
    description: "Testuje: bod, kruÅ¾nice (normÃ¡lnÃ­ syntax), CNC syntax, jednoduchou ÄÃ¡ru, polÃ¡rnÃ­ ÄÃ¡ru z centra kruÅ¾nice, bÄ›Å¾nou ÄÃ¡ru"
  },
  // ===== PRAKTICKÃ‰ PÅ˜ÃKLADY =====
  {
    level: "PRAKTICKÃ",
    name: "ğŸ”§ HÅ™Ã­del s kuÅ¾elem (zjednoduÅ¡enÃ¡)",
    prompt: "Nakresli hÅ™Ã­del: ÄÃ¡ra Z0 X0 do Z0 X60, ÄÃ¡ra Z0 X60 do Z40 X60, ÄÃ¡ra Z40 X60 do Z40 X50, ÄÃ¡ra Z40 X50 do Z80 X50, ÄÃ¡ra Z80 X50 do Z80 X40, ÄÃ¡ra Z80 X40 do Z120 X20, ÄÃ¡ra Z120 X20 do Z150 X20, ÄÃ¡ra Z150 X20 do Z150 X0, ÄÃ¡ra Z150 X0 do Z0 X0",
    expectedShapes: 9,
    expectedType: "line",
    complexity: 8,
    description: "RealistickÃ¡ hÅ™Ã­del s kuÅ¾elem: dva prÅ¯mÄ›ry (âŒ€60 a âŒ€50) a kuÅ¾el pÅ™echod z âŒ€40 na âŒ€20"
  },
  {
    level: "PRAKTICKÃ",
    name: "ğŸ”§ Test tangenciÃ¡lnÃ­ho radiusu",
    prompt: "ÄÃ¡ra Z0 X60 do Z40 X60, G2 Z45 X55 CR5, G3 Z50 X50 CR5, ÄÃ¡ra do Z80 X50",
    expectedShapes: 4,
    expectedType: ["line", "arc", "arc", "line"],
    complexity: 5,
    description: "Test zaoblenÃ­ CR5 mezi dvÄ›ma ÄÃ¡rami s G2/G3 - CNC syntax"
  },
  // ===== KATEGORIZOVANÃ‰ RYCHLÃ‰ TESTY =====
  {
    level: "KATEGORIE",
    name: "ğŸ“ Test bodÅ¯",
    prompt: "bod Z50 X50, bod Z100 X100, bod Z150 X150",
    expectedShapes: 3,
    expectedType: "point",
    complexity: 2,
    description: "Test vytvÃ¡Å™enÃ­ bodÅ¯"
  },
  {
    level: "KATEGORIE",
    name: "â­• Test kruÅ¾nic",
    prompt: "kruÅ¾nice Z100 X100 R30, kruÅ¾nice Z200 X100 R40, X300Z100R50",
    expectedShapes: 3,
    expectedType: "circle",
    complexity: 3,
    description: "Test normÃ¡lnÃ­ i CNC syntaxe kruÅ¾nic"
  },
  {
    level: "KATEGORIE",
    name: "ğŸ“ Test Äar",
    prompt: "ÄÃ¡ra Z0 X0 do Z100 X100, ÄÃ¡ra Z100 X100 do Z200 X200, ÄÃ¡ra Z200 X200 do Z300 X300",
    expectedShapes: 3,
    expectedType: "line",
    complexity: 2,
    description: "Test jednoduchÃ½ch Äar"
  },
  {
    level: "KATEGORIE",
    name: "ğŸ¯ Test polÃ¡rnÃ­ch Äar",
    prompt: "kruÅ¾nice Z100 X100 R50, pak ÄÃ¡ra od stÅ™edu Ãºhel 0Â° dÃ©lka 100, ÄÃ¡ra od stÅ™edu Ãºhel 90Â° dÃ©lka 100",
    expectedShapes: 3,
    expectedType: ["circle", "line", "line"],
    complexity: 5,
    description: "Test Äar z centra kruÅ¾nice s Ãºhlem"
  },
  // ===== LEVEL 1: VELMI JEDNODUCHÃ‰ =====
  {
    level: "VELMI JEDNODUCHÃ‰",
    name: "L1-1: Bod",
    prompt: "bod Z100 X100",
    expectedShapes: 1,
    expectedType: "point",
    complexity: 1
  },
  {
    level: "VELMI JEDNODUCHÃ‰",
    name: "L1-2: JednoduchÃ¡ ÄÃ¡ra",
    prompt: "ÄÃ¡ra Z0 X0 do Z100 X100",
    expectedShapes: 1,
    expectedType: "line",
    complexity: 1
  },
  {
    level: "VELMI JEDNODUCHÃ‰",
    name: "L1-3: JednoduchÃ¡ kruÅ¾nice",
    prompt: "kruÅ¾nice Z100 X100 R50",
    expectedShapes: 1,
    expectedType: "circle",
    complexity: 1
  },

  // ===== LEVEL 2: JEDNODUCHÃ‰ =====
  {
    level: "JEDNODUCHÃ‰",
    name: "L2-1: CNC syntax kruÅ¾nice",
    prompt: "X80Z56R52",
    expectedShapes: 1,
    expectedType: "circle",
    complexity: 2
  },
  {
    level: "JEDNODUCHÃ‰",
    name: "L2-2: DvÄ› ÄÃ¡ry",
    prompt: "ÄÃ¡ra Z0 X0 do Z100 X0, ÄÃ¡ra Z100 X0 do Z100 X100",
    expectedShapes: 2,
    expectedType: "line",
    complexity: 2
  },
  {
    level: "JEDNODUCHÃ‰",
    name: "L2-3: DvÄ› kruÅ¾nice",
    prompt: "kruÅ¾nice Z100 X100 R30, kruÅ¾nice Z200 X100 R40",
    expectedShapes: 2,
    expectedType: "circle",
    complexity: 2
  },
  {
    level: "JEDNODUCHÃ‰",
    name: "L2-4: Mix - ÄÃ¡ra a kruÅ¾nice",
    prompt: "ÄÃ¡ra Z0 X0 do Z100 X100, kruÅ¾nice Z200 X200 R50",
    expectedShapes: 2,
    expectedType: ["line", "circle"],
    complexity: 2
  },

  // ===== LEVEL 3: STÅ˜EDNÃ =====
  {
    level: "STÅ˜EDNÃ",
    name: "L3-1: ÄŒÃ¡ra z centra kruÅ¾nice",
    prompt: "kruÅ¾nice Z100 X100 R50, pak ÄÃ¡ra od stÅ™edu Ãºhel 0Â° dÃ©lka 100",
    expectedShapes: 2,
    expectedType: ["circle", "line"],
    complexity: 3
  },
  {
    level: "STÅ˜EDNÃ",
    name: "L3-2: CNC - pozice + radius",
    prompt: "X50Z56R52, X100Z56R40",
    expectedShapes: 2,
    expectedType: "circle",
    complexity: 3
  },
  {
    level: "STÅ˜EDNÃ",
    name: "L3-3: ObdÃ©lnÃ­k (4 ÄÃ¡ry)",
    prompt: "ÄÃ¡ra Z0 X0 do Z100 X0, ÄÃ¡ra Z100 X0 do Z100 X100, ÄÃ¡ra Z100 X100 do Z0 X100, ÄÃ¡ra Z0 X100 do Z0 X0",
    expectedShapes: 4,
    expectedType: "line",
    complexity: 3
  },
  {
    level: "STÅ˜EDNÃ",
    name: "L3-4: TÅ™i kruÅ¾nice rÅ¯znÃ½ch velikostÃ­",
    prompt: "kruÅ¾nice Z50 X50 R20, kruÅ¾nice Z150 X150 R35, kruÅ¾nice Z250 X100 R45",
    expectedShapes: 3,
    expectedType: "circle",
    complexity: 3
  },

  // ===== LEVEL 4: POKROÄŒILÃ‰ =====
  {
    level: "POKROÄŒILÃ‰",
    name: "L4-1: ÄŒÃ¡ra se stÅ™edem - Ãºhel 45Â°",
    prompt: "kruÅ¾nice Z100 X100 R60, pak ÄÃ¡ra od stÅ™edu Ãºhel 45Â° dÃ©lka 120",
    expectedShapes: 2,
    expectedType: ["circle", "line"],
    complexity: 4
  },
  {
    level: "POKROÄŒILÃ‰",
    name: "L4-2: VÃ­ce Äar v jednom",
    prompt: "ÄÃ¡ra Z0 X0 do Z50 X50, ÄÃ¡ra Z50 X50 do Z100 X0, ÄÃ¡ra Z100 X0 do Z150 X50",
    expectedShapes: 3,
    expectedType: "line",
    complexity: 4
  },
  {
    level: "POKROÄŒILÃ‰",
    name: "L4-3: PrÅ¯mÄ›r mÃ­sto polomÄ›ru",
    prompt: "kruÅ¾nice Z100 X100 âŒ€100",
    expectedShapes: 1,
    expectedType: "circle",
    complexity: 4
  },
  {
    level: "POKROÄŒILÃ‰",
    name: "L4-4: Mix - kruÅ¾nice, ÄÃ¡ra, body",
    prompt: "bod Z50 X50, kruÅ¾nice Z100 X100 R40, ÄÃ¡ra Z150 X150 do Z200 X200",
    expectedShapes: 3,
    expectedType: ["point", "circle", "line"],
    complexity: 4
  },

  // ===== LEVEL 5: VELMI POKROÄŒILÃ‰ =====
  {
    level: "VELMI POKROÄŒILÃ‰",
    name: "L5-1: ÄŒÃ¡ra od kruÅ¾nice s Ãºhlem a dÃ©lkou",
    prompt: "kruÅ¾nice Z100 X100 R50, pak ÄÃ¡ra od stÅ™edu Ãºhel 30Â° dÃ©lka 150",
    expectedShapes: 2,
    expectedType: ["circle", "line"],
    complexity: 5
  },
  {
    level: "VELMI POKROÄŒILÃ‰",
    name: "L5-2: SloÅ¾itÃ½ CNC syntax",
    prompt: "X80Z56R52;X50Z56AP0RP120",
    expectedShapes: 2,
    expectedType: ["circle", "line"],
    complexity: 5
  },
  {
    level: "VELMI POKROÄŒILÃ‰",
    name: "L5-3: Kreis s ÄÃ¡rou z centra - vÃ­ce ÃºhlÅ¯",
    prompt: "kruÅ¾nice Z100 X100 R50, ÄÃ¡ra od stÅ™edu 0Â° 80, ÄÃ¡ra od stÅ™edu 90Â° 80",
    expectedShapes: 3,
    expectedType: ["circle", "line", "line"],
    complexity: 5
  },
  {
    level: "VELMI POKROÄŒILÃ‰",
    name: "L5-4: KomplexnÃ­ mix",
    prompt: "bod Z0 X0, ÄÃ¡ra Z0 X0 do Z100 X100, kruÅ¾nice Z100 X100 R40, ÄÃ¡ra od stÅ™edu 45Â° 100",
    expectedShapes: 4,
    expectedType: ["point", "line", "circle", "line"],
    complexity: 5
  },

  // ===== LEVEL 6: EXPERT =====
  {
    level: "EXPERT",
    name: "L6-1: DvÄ› kruÅ¾nice + ÄÃ¡ry mezi nimi",
    prompt: "kruÅ¾nice Z50 X50 R30, kruÅ¾nice Z150 X150 R40, ÄÃ¡ra Z50 X50 do Z150 X150",
    expectedShapes: 3,
    expectedType: ["circle", "circle", "line"],
    complexity: 6
  },
  {
    level: "EXPERT",
    name: "L6-2: Polygon - Å¡estiÃºhelnÃ­k",
    prompt: "ÄÃ¡ra Z100 X0 do Z150 X50, ÄÃ¡ra Z150 X50 do Z150 X150, ÄÃ¡ra Z150 X150 do Z100 X200, ÄÃ¡ra Z100 X200 do Z50 X150, ÄÃ¡ra Z50 X150 do Z50 X50, ÄÃ¡ra Z50 X50 do Z100 X0",
    expectedShapes: 6,
    expectedType: "line",
    complexity: 6
  },
  {
    level: "EXPERT",
    name: "L6-3: TÅ™i kruÅ¾nice v Å™adÄ› + ÄÃ¡ry",
    prompt: "kruÅ¾nice Z50 X100 R30, kruÅ¾nice Z150 X100 R35, kruÅ¾nice Z250 X100 R40, ÄÃ¡ra Z50 X100 do Z150 X100, ÄÃ¡ra Z150 X100 do Z250 X100",
    expectedShapes: 5,
    expectedType: ["circle", "circle", "circle", "line", "line"],
    complexity: 6
  },
  {
    level: "EXPERT",
    name: "L6-4: ZÃ¡vitovÃ½ profil (teoreticky)",
    prompt: "kruÅ¾nice Z100 X50 R20, kruÅ¾nice Z150 X50 R20, kruÅ¾nice Z200 X50 R20, ÄÃ¡ra Z100 X50 do Z200 X50",
    expectedShapes: 4,
    expectedType: ["circle", "circle", "circle", "line"],
    complexity: 6
  }
];

window.runAITest = async function(testIndex = 0) {
  const container = document.getElementById("aiChatHistory");

  if (testIndex >= window.AI_TEST_PROMPTS.length) {
    // MÃ­sto alertu zobraz souhrn v chatu
    if (window.showTestSummary) {
      window.showTestSummary();
    }
    return;
  }

  const test = window.AI_TEST_PROMPTS[testIndex];
  const promptInput = document.getElementById("aiPrompt");

  if (!promptInput || !container) {
    console.error("âŒ AI panel nenalezen!");
    return;
  }

  // Zobraz test zprÃ¡vu
  const testDiv = document.createElement("div");
  testDiv.className = "chat-msg model";
  testDiv.style.color = "#60a5fa";
  testDiv.style.fontWeight = "bold";
  testDiv.textContent = `ğŸ§ª TEST ${testIndex + 1}/${window.AI_TEST_PROMPTS.length}: ${test.name}`;
  container.appendChild(testDiv);
  container.scrollTop = container.scrollHeight;

  // Nastav prompt a chvÃ­li Äekej
  promptInput.value = test.prompt;
  await new Promise(resolve => setTimeout(resolve, 500));

  // Zapamatuj si poÄet tvarÅ¯ pÅ™ed testem
  const shapesBefore = (window.shapes || []).length;
  const pointsBefore = (window.points || []).length;

  // SpusÅ¥ AI a Äekej na dokonÄenÃ­ (BEZ timeoutu - poÄkÃ¡ i na retry)
  const success = window.callGemini ? await window.callGemini().then(() => {
    return true;
  }).catch(err => {
    console.warn("âš ï¸ AI request failed:", err.message);
    return false;
  }) : true;

  // Zastav processing flag
  window.processingAI = false;

  // VyÄisti loading indikÃ¡tor (pokud tam jeÅ¡tÄ› je)
  const loadingDivs = container.querySelectorAll('.loading-dots');
  loadingDivs.forEach(div => {
    const parent = div.closest('div[style*="text-align: center"]');
    if (parent && container.contains(parent)) {
      container.removeChild(parent);
    }
  });

  // OvÄ›Å™ vÃ½sledky
  const shapesAfter = (window.shapes || []).length;
  const pointsAfter = (window.points || []).length;
  const newShapesCount = (shapesAfter - shapesBefore) + (pointsAfter - pointsBefore);

  let testResult = `\nğŸ“Š VÃ½sledek: ${newShapesCount} tvarÅ¯`;
  let validationErrors = [];
  let hasErrors = false;

  // Kontrola poÄtu tvarÅ¯
  if (newShapesCount >= test.expectedShapes) {
    testResult += ` âœ…`;
  } else {
    testResult += ` âŒ (oÄekÃ¡vÃ¡no ${test.expectedShapes})`;
    validationErrors.push(`OÄekÃ¡vanÃ½ poÄet: ${test.expectedShapes}, zÃ­skÃ¡no: ${newShapesCount}`);
    hasErrors = true;
  }

  // DetailnÃ­ validace novÄ› pÅ™idanÃ½ch tvarÅ¯
  const newShapes = window.shapes.slice(shapesBefore);
  const newPoints = window.points.slice(pointsBefore);

  // Analyzuj prompt pro identifikaci polÃ¡rnÃ­ch Äar
  const polarLinePattern = /pak\s+ÄÃ¡ra\s+od\s+stÅ™edu\s+Ãºhel\s+(\d+)Â°?\s+dÃ©lka\s+(\d+)/gi;
  const polarLines = [];
  let match;
  while ((match = polarLinePattern.exec(test.prompt)) !== null) {
    polarLines.push({
      angle: parseInt(match[1]),
      length: parseInt(match[2])
    });
  }

  // VytÃ¡hni vÅ¡echny polomÄ›ry z promptu
  const radiusPattern = /[Rrï¼²ï½’]\s*(\d+)/g;
  const expectedRadii = [];
  while ((match = radiusPattern.exec(test.prompt)) !== null) {
    expectedRadii.push(parseInt(match[1]));
  }

  // Najdi poslednÃ­ kruÅ¾nici pÅ™ed polÃ¡rnÃ­ ÄÃ¡rou (pro urÄenÃ­ stÅ™edu)
  let lastCircleBeforePolar = null;
  let circleIndex = 0;

  newShapes.forEach((shape, idx) => {
    if (shape.type === "line") {
      // Kontrola ÄÃ¡ry - musÃ­ mÃ­t rÅ¯znÃ© body
      if (shape.x1 === shape.x2 && shape.y1 === shape.y2) {
        validationErrors.push(`ÄŒÃ¡ra ${idx+1}: nulovÃ¡ dÃ©lka (x1=${shape.x1}, y1=${shape.y1}, x2=${shape.x2}, y2=${shape.y2})`);
        hasErrors = true;
      }
      // Kontrola, Å¾e vÅ¡echny souÅ™adnice jsou ÄÃ­sla
      if (typeof shape.x1 !== 'number' || typeof shape.y1 !== 'number' ||
          typeof shape.x2 !== 'number' || typeof shape.y2 !== 'number') {
        validationErrors.push(`ÄŒÃ¡ra ${idx+1}: chybÄ›jÃ­cÃ­ nebo neplatnÃ© souÅ™adnice (x1=${shape.x1}, y1=${shape.y1}, x2=${shape.x2}, y2=${shape.y2})`);
        hasErrors = true;
      }

      // Kontrola polÃ¡rnÃ­ch Äar - pouze pokud startujÃ­ ze stÅ™edu nÄ›jakÃ© kruÅ¾nice
      if (polarLines.length > 0 && lastCircleBeforePolar) {
        const isPolarLine = Math.abs(shape.x1 - lastCircleBeforePolar.cx) < 1 &&
                           Math.abs(shape.y1 - lastCircleBeforePolar.cy) < 1;

        if (isPolarLine && polarLines.length > 0) {
          const polarInfo = polarLines.shift(); // Vezmi prvnÃ­ polÃ¡rnÃ­ definici
          const angle = polarInfo.angle;
          const length = polarInfo.length;

          // Validuj podle Ãºhlu
          if (angle === 0) {
            if (Math.abs(shape.y2 - shape.y1) > 1) {
              validationErrors.push(`ÄŒÃ¡ra ${idx+1} [POLÃRNÃ 0Â°]: y2 by mÄ›lo bÃ½t â‰ˆ y1 (y1=${shape.y1.toFixed(1)}, y2=${shape.y2.toFixed(1)})`);
              hasErrors = true;
            }
            const expectedX2 = shape.x1 + length;
            if (Math.abs(shape.x2 - expectedX2) > 2) {
              validationErrors.push(`ÄŒÃ¡ra ${idx+1} [POLÃRNÃ 0Â°]: pÅ™i dÃ©lce ${length} oÄekÃ¡vÃ¡m x2â‰ˆ${expectedX2.toFixed(1)}, ale je ${shape.x2.toFixed(1)}`);
              hasErrors = true;
            }
          } else if (angle === 90) {
            if (Math.abs(shape.x2 - shape.x1) > 1) {
              validationErrors.push(`ÄŒÃ¡ra ${idx+1} [POLÃRNÃ 90Â°]: x2 by mÄ›lo bÃ½t â‰ˆ x1 (x1=${shape.x1.toFixed(1)}, x2=${shape.x2.toFixed(1)})`);
              hasErrors = true;
            }
            const expectedY2 = shape.y1 + length;
            if (Math.abs(shape.y2 - expectedY2) > 2) {
              validationErrors.push(`ÄŒÃ¡ra ${idx+1} [POLÃRNÃ 90Â°]: pÅ™i dÃ©lce ${length} oÄekÃ¡vÃ¡m y2â‰ˆ${expectedY2.toFixed(1)}, ale je ${shape.y2.toFixed(1)}`);
              hasErrors = true;
            }
          } else {
            const angleRad = angle * Math.PI / 180;
            const expectedX2 = shape.x1 + length * Math.cos(angleRad);
            const expectedY2 = shape.y1 + length * Math.sin(angleRad);
            const tolerance = 3;
            if (Math.abs(shape.x2 - expectedX2) > tolerance || Math.abs(shape.y2 - expectedY2) > tolerance) {
              validationErrors.push(`ÄŒÃ¡ra ${idx+1} [POLÃRNÃ ${angle}Â°]: pÅ™i dÃ©lce ${length} oÄekÃ¡vÃ¡m x2â‰ˆ${expectedX2.toFixed(1)}, y2â‰ˆ${expectedY2.toFixed(1)}, ale je x2=${shape.x2.toFixed(1)}, y2=${shape.y2.toFixed(1)}`);
              hasErrors = true;
            }
          }
        }
      }
    } else if (shape.type === "circle") {
      lastCircleBeforePolar = shape; // Zapamatuj si poslednÃ­ kruÅ¾nici

      // Kontrola kruÅ¾nice - radius musÃ­ bÃ½t > 0
      if (shape.r <= 0 || typeof shape.r !== 'number') {
        validationErrors.push(`KruÅ¾nice ${idx+1}: neplatnÃ½ polomÄ›r r=${shape.r}`);
        hasErrors = true;
      }
      // Kontrola stÅ™edu
      if (typeof shape.cx !== 'number' || typeof shape.cy !== 'number') {
        validationErrors.push(`KruÅ¾nice ${idx+1}: neplatnÃ© souÅ™adnice stÅ™edu (cx=${shape.cx}, cy=${shape.cy})`);
        hasErrors = true;
      }

      // Validace polomÄ›ru - pouÅ¾ij odpovÃ­dajÃ­cÃ­ polomÄ›r z pole
      if (expectedRadii.length > circleIndex) {
        const expectedRadiusFromPrompt = expectedRadii[circleIndex];
        const tolerance = 2;

        // âš ï¸ AI vracÃ­ radius pÅ™Ã­mo, bez konverze diameter mode
        // KdyÅ¾ test oÄekÃ¡vÃ¡ R5, AI vrÃ¡tÃ­ r:5, tak to i validujeme
        const expectedInternalRadius = expectedRadiusFromPrompt;

        if (Math.abs(shape.r - expectedInternalRadius) > tolerance) {
          validationErrors.push(`KruÅ¾nice ${idx+1}: oÄekÃ¡vanÃ½ radius ${expectedInternalRadius.toFixed(1)}, ale je ${shape.r.toFixed(1)}`);
          hasErrors = true;
        }
      }

      circleIndex++;
    } else if (shape.type === "arc") {
      // Validace ARC (oblouku) - podobnÄ› jako kruÅ¾nice, ale s Ãºhly
      if (shape.r <= 0 || typeof shape.r !== 'number') {
        validationErrors.push(`Oblouk ${idx+1}: neplatnÃ½ polomÄ›r r=${shape.r}`);
        hasErrors = true;
      }
      if (typeof shape.cx !== 'number' || typeof shape.cy !== 'number') {
        validationErrors.push(`Oblouk ${idx+1}: neplatnÃ© souÅ™adnice stÅ™edu (cx=${shape.cx}, cy=${shape.cy})`);
        hasErrors = true;
      }
      if (typeof shape.startAngle !== 'number' || typeof shape.endAngle !== 'number') {
        validationErrors.push(`Oblouk ${idx+1}: chybÃ­ Ãºhly (startAngle=${shape.startAngle}, endAngle=${shape.endAngle})`);
        hasErrors = true;
      }

      // ARC poÄÃ­tÃ¡me jako kruÅ¾nici pro validaci poÄtu
      if (expectedRadii.length > circleIndex) {
        const expectedRadiusFromPrompt = expectedRadii[circleIndex];
        const tolerance = 2;
        const expectedInternalRadius = expectedRadiusFromPrompt;

        if (Math.abs(shape.r - expectedInternalRadius) > tolerance) {
          validationErrors.push(`Oblouk ${idx+1}: oÄekÃ¡vanÃ½ radius ${expectedInternalRadius.toFixed(1)}, ale je ${shape.r.toFixed(1)}`);
          hasErrors = true;
        }
      }

      circleIndex++; // ARC = kruÅ¾nice pro poÄÃ­tÃ¡nÃ­
    }
  });

  newPoints.forEach((point, idx) => {
    if (typeof point.x !== 'number' || typeof point.y !== 'number') {
      validationErrors.push(`Bod ${idx+1}: neplatnÃ© souÅ™adnice`);
      hasErrors = true;
    }
  });

  // Zobraz vÃ½sledek
  const resultDiv = document.createElement("div");
  resultDiv.className = "chat-msg model";
  resultDiv.style.color = !hasErrors ? "#10b981" : "#ef4444";
  resultDiv.style.fontSize = "12px";
  resultDiv.style.whiteSpace = "pre-wrap";

  if (hasErrors && validationErrors.length > 0) {
    testResult += "\n\nâš ï¸ CHYBY DETEKOVANÃ‰:\n" + validationErrors.map(e => "  â€¢ " + e).join("\n");
  }

  resultDiv.textContent = testResult;
  container.appendChild(resultDiv);
  container.scrollTop = container.scrollHeight;

  // UloÅ¾ vÃ½sledky testu
  if (!window.aiTestResults) {
    window.aiTestResults = [];
  }

  // PÅ™iprav detailnÃ­ informace o tvarech
  const shapesDetails = newShapes.map((shape, idx) => {
    if (shape.type === "line") {
      return {
        type: "line",
        index: idx + 1,
        data: { x1: shape.x1, y1: shape.y1, x2: shape.x2, y2: shape.y2 },
        length: Math.sqrt(Math.pow(shape.x2 - shape.x1, 2) + Math.pow(shape.y2 - shape.y1, 2)).toFixed(2)
      };
    } else if (shape.type === "circle") {
      return {
        type: "circle",
        index: idx + 1,
        data: { cx: shape.cx, cy: shape.cy, r: shape.r }
      };
    } else if (shape.type === "arc") {
      return {
        type: "arc",
        index: idx + 1,
        data: {
          cx: shape.cx,
          cy: shape.cy,
          r: shape.r,
          startAngle: shape.startAngle,
          endAngle: shape.endAngle
        }
      };
    }
    return { type: shape.type, index: idx + 1, data: shape };
  });

  const pointsDetails = newPoints.map((point, idx) => ({
    type: "point",
    index: idx + 1,
    data: { x: point.x, y: point.y }
  }));

  window.aiTestResults.push({
    testIndex: testIndex,
    testName: test.name,
    prompt: test.prompt,
    expectedShapes: test.expectedShapes,
    actualShapes: newShapesCount,
    hasErrors: hasErrors,
    errors: validationErrors,
    shapesDetails: shapesDetails,
    pointsDetails: pointsDetails,
    aiResponse: window.lastAIResponse ? {
      replyText: window.lastAIResponse.replyText,
      rawShapes: window.lastAIResponse.shapes
    } : null,
    timestamp: new Date().toISOString()
  });

  // PokraÄuj dalÅ¡Ã­ test pouze pokud je nastavena flag pro batch run
  if (window.aiTestBatchMode) {
    await new Promise(resolve => setTimeout(resolve, 3000));

    // Pokud je to poslednÃ­ test, zobraz souhrn
    if (testIndex + 1 >= window.AI_TEST_PROMPTS.length) {
      window.aiTestBatchMode = false;
      window.processingAI = false; // âœ… Zastav processing
      window.showTestSummary();
    } else {
      window.runAITest(testIndex + 1);
    }
  } else {
    // JednorÃ¡zovÃ½ test - ZASTAV processing okamÅ¾itÄ›
    window.processingAI = false;

    const summaryDiv = document.createElement("div");
    summaryDiv.className = "chat-msg model";
    summaryDiv.style.color = !hasErrors ? "#10b981" : "#6ab0ff";
    summaryDiv.style.fontSize = "11px";
    summaryDiv.style.background = "#1a1a1a";
    summaryDiv.style.border = "1px solid " + (!hasErrors ? "#10b981" : "#444");
    summaryDiv.style.padding = "10px";
    summaryDiv.style.marginTop = "10px";

    let summary = `âœ… Test dokonÄen!\n`;
    if (!hasErrors) {
      summary += `\nğŸ‰ VÅ¡echny kontroly proÅ¡ly bez chyb!`;
    } else {
      summary += `\nâš ï¸ Test proÅ¡el s ${validationErrors.length} chyb(ou/ami).`;
    }

    summaryDiv.textContent = summary;
    container.appendChild(summaryDiv);
    container.scrollTop = container.scrollHeight;

    // Zobraz tlaÄÃ­tko pro report
    const reportBtn = document.createElement("button");
    reportBtn.textContent = "ğŸ“‹ ZOBRAZIT DETAILNÃ REPORT";
    reportBtn.style.cssText = "width: 100%; padding: 10px; margin-top: 10px; background: #2563eb; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;";
    reportBtn.onclick = () => window.showTestReport();
    container.appendChild(reportBtn);
    container.scrollTop = container.scrollHeight;
  }
};

// ZobrazÃ­ detailnÃ­ report testu s moÅ¾nostÃ­ kopÃ­rovÃ¡nÃ­
window.showTestReport = function() {
  if (!window.aiTestResults || window.aiTestResults.length === 0) {
    alert("Å½Ã¡dnÃ© vÃ½sledky testÅ¯ k dispozici.");
    return;
  }

  const container = document.getElementById("aiChatHistory");
  if (!container) return;

  const lastResult = window.aiTestResults[window.aiTestResults.length - 1];

  let report = "";
  report += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
  report += "         ğŸ”¬ DETAILNÃ AI TEST REPORT\n";
  report += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";

  report += `ğŸ“Œ TEST: ${lastResult.testName}\n`;
  report += `ğŸ• ÄŒas: ${new Date(lastResult.timestamp).toLocaleString('cs-CZ')}\n`;
  report += `\n`;

  report += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n";
  report += "ğŸ“ VSTUPNÃ PROMPT:\n";
  report += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n";
  report += `"${lastResult.prompt}"\n\n`;

  report += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n";
  report += "ğŸ¤– AI ODPOVÄšÄ:\n";
  report += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n";

  if (lastResult.aiResponse) {
    report += `TextovÃ¡ odpovÄ›Ä: "${lastResult.aiResponse.replyText}"\n\n`;

    if (lastResult.aiResponse.rawShapes && lastResult.aiResponse.rawShapes.length > 0) {
      report += "ğŸ” RAW JSON TVARY (co AI vrÃ¡tila):\n";
      lastResult.aiResponse.rawShapes.forEach((shape, idx) => {
        report += `\n${idx + 1}. ${shape.type.toUpperCase()}:\n`;
        report += `   ${JSON.stringify(shape, null, 2).split('\n').join('\n   ')}\n`;
      });
      report += "\n";
    } else {
      report += "âš ï¸ AI nevrÃ¡tila Å¾Ã¡dnÃ© tvary (shapes: [])\n\n";
    }
  } else {
    report += "âŒ AI response nebyla zachycena (timeout nebo chyba)\n\n";
  }

  report += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n";
  report += "ğŸ“Š VÃSLEDEK TESTU:\n";
  report += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n";
  report += `OÄekÃ¡vÃ¡no tvarÅ¯: ${lastResult.expectedShapes}\n`;
  report += `ZÃ­skÃ¡no tvarÅ¯:   ${lastResult.actualShapes}\n`;
  report += `Status:          ${lastResult.hasErrors ? 'âŒ CHYBY DETEKOVÃNY' : 'âœ… ÃšSPÄšCH'}\n\n`;

  if (lastResult.shapesDetails && lastResult.shapesDetails.length > 0) {
    report += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n";
    report += "ğŸ“ VYTVOÅ˜ENÃ‰ TVARY (detail):\n";
    report += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n";
    lastResult.shapesDetails.forEach(shape => {
      report += `\n${shape.index}. ${shape.type.toUpperCase()}:\n`;
      if (shape.type === "line") {
        report += `   Start: Z=${shape.data.x1}, X=${shape.data.y1}\n`;
        report += `   Konec: Z=${shape.data.x2}, X=${shape.data.y2}\n`;
        report += `   DÃ©lka: ${shape.length}\n`;
      } else if (shape.type === "circle") {
        report += `   StÅ™ed: Z=${shape.data.cx}, X=${shape.data.cy}\n`;
        report += `   PolomÄ›r: ${shape.data.r}\n`;
      } else if (shape.type === "arc") {
        report += `   StÅ™ed: Z=${shape.data.cx}, X=${shape.data.cy}\n`;
        report += `   PolomÄ›r: ${shape.data.r}\n`;
        if (shape.data.startAngle !== undefined && shape.data.endAngle !== undefined) {
          report += `   Ãšhly: ${shape.data.startAngle}Â° aÅ¾ ${shape.data.endAngle}Â°\n`;
        }
      }
    });
    report += "\n";
  }

  if (lastResult.pointsDetails && lastResult.pointsDetails.length > 0) {
    report += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n";
    report += "ğŸ“ VYTVOÅ˜ENÃ‰ BODY:\n";
    report += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n";
    lastResult.pointsDetails.forEach(point => {
      report += `${point.index}. BOD: Z=${point.data.x}, X=${point.data.y}\n`;
    });
    report += "\n";
  }

  if (lastResult.errors && lastResult.errors.length > 0) {
    report += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n";
    report += "âš ï¸  DETEKOVANÃ‰ CHYBY:\n";
    report += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n";
    lastResult.errors.forEach((error, idx) => {
      report += `${idx + 1}. ${error}\n`;
    });
    report += "\n";
  }

  report += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
  report += "               KONEC REPORTU\n";
  report += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";

  // Zobraz report v modÃ¡lnÃ­m oknÄ›
  const reportDiv = document.createElement("div");
  reportDiv.className = "chat-msg model";
  reportDiv.style.cssText = "background: #0a0a0a; border: 2px solid #2563eb; padding: 15px; margin-top: 15px; font-family: 'Courier New', monospace; font-size: 11px; white-space: pre-wrap; max-height: 1000px; overflow-y: auto;";
  reportDiv.textContent = report;

  const copyBtn = document.createElement("button");
  copyBtn.textContent = "ğŸ“‹ ZKOPÃROVAT REPORT";
  copyBtn.style.cssText = "width: 100%; padding: 10px; margin-top: 10px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;";
  copyBtn.onclick = () => {
    navigator.clipboard.writeText(report).then(() => {
      copyBtn.textContent = "âœ… ZKOPÃROVÃNO!";
      setTimeout(() => {
        copyBtn.textContent = "ğŸ“‹ ZKOPÃROVAT REPORT";
      }, 2000);
    }).catch(err => {
      alert("Chyba pÅ™i kopÃ­rovÃ¡nÃ­: " + err);
    });
  };

  container.appendChild(reportDiv);
  container.appendChild(copyBtn);
  container.scrollTop = container.scrollHeight;
};

window.closeAITestModal = function() {
  const modal = document.getElementById("aiTestModal");
  if (modal) {
    modal.style.display = "none";
  }
};

// Zobraz souhrn testÅ¯
window.showTestSummary = function() {
  if (!window.aiTestResults || window.aiTestResults.length === 0) {
    alert("Å½Ã¡dnÃ© vÃ½sledky testÅ¯ k dispozici.");
    return;
  }

  const container = document.getElementById("aiChatHistory");
  if (!container) return;

  const total = window.aiTestResults.length;
  const passed = window.aiTestResults.filter(r => !r.hasErrors).length;
  const failed = total - passed;
  const successRate = ((passed / total) * 100).toFixed(1);

  // Souhrn chyb
  const errorsByType = {};
  window.aiTestResults.forEach(result => {
    if (result.hasErrors) {
      result.errors.forEach(error => {
        const errorType = error.split(':')[0].trim();
        errorsByType[errorType] = (errorsByType[errorType] || 0) + 1;
      });
    }
  });

  let summaryText = `\n\nğŸ“Š SOUHRN TESTÅ®\n`;
  summaryText += `${'='.repeat(50)}\n`;
  summaryText += `Celkem testÅ¯: ${total}\n`;
  summaryText += `âœ… ÃšspÄ›Å¡nÃ©: ${passed} (${successRate}%)\n`;
  summaryText += `âŒ NeÃºspÄ›Å¡nÃ©: ${failed} (${(100 - successRate).toFixed(1)}%)\n`;

  if (Object.keys(errorsByType).length > 0) {
    summaryText += `\nğŸ” NEJÄŒASTÄšJÅ Ã CHYBY:\n`;
    Object.entries(errorsByType)
      .sort((a, b) => b[1] - a[1])
      .forEach(([type, count]) => {
        summaryText += `  â€¢ ${type}: ${count}x\n`;
      });
  }

  // Seznam neÃºspÄ›Å¡nÃ½ch testÅ¯
  const failedTests = window.aiTestResults.filter(r => r.hasErrors);
  if (failedTests.length > 0) {
    summaryText += `\nâŒ NEÃšSPÄšÅ NÃ‰ TESTY:\n`;
    failedTests.forEach(result => {
      summaryText += `  ${result.testIndex + 1}. ${result.testName}\n`;
      summaryText += `     Prompt: "${result.prompt}"\n`;
      result.errors.forEach(err => {
        summaryText += `     - ${err}\n`;
      });
    });
  }

  const summaryDiv = document.createElement("div");
  summaryDiv.className = "chat-msg model";
  summaryDiv.style.color = passed === total ? "#10b981" : "#ef4444";
  summaryDiv.style.fontSize = "12px";
  summaryDiv.style.whiteSpace = "pre-wrap";
  summaryDiv.style.background = "#1a1a1a";
  summaryDiv.style.border = "2px solid " + (passed === total ? "#10b981" : "#ef4444");
  summaryDiv.style.padding = "15px";
  summaryDiv.style.marginTop = "20px";
  summaryDiv.textContent = summaryText;

  container.appendChild(summaryDiv);
  container.scrollTop = container.scrollHeight;

  alert(`âœ… Testy dokonÄeny!\n\nÃšspÄ›Å¡nost: ${successRate}%\n(${passed}/${total} testÅ¯ proÅ¡lo)`);
};

// Reset testovacÃ­ch vÃ½sledkÅ¯
window.resetTestResults = function() {
  window.aiTestResults = [];
  console.log("ğŸ”„ VÃ½sledky testÅ¯ resetovÃ¡ny");
};

// Exportuj vÃ½sledky testÅ¯ do JSON souboru
window.exportTestResults = function() {
  if (!window.aiTestResults || window.aiTestResults.length === 0) {
    alert("Å½Ã¡dnÃ© vÃ½sledky testÅ¯ k exportu.");
    return;
  }

  const data = {
    timestamp: new Date().toISOString(),
    totalTests: window.aiTestResults.length,
    passedTests: window.aiTestResults.filter(r => !r.hasErrors).length,
    failedTests: window.aiTestResults.filter(r => r.hasErrors).length,
    results: window.aiTestResults
  };

  const json = JSON.stringify(data, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `ai-test-results-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);

  alert(`âœ… VÃ½sledky testÅ¯ exportovÃ¡ny do ${a.download}`);
};

// FormÃ¡tuj CNC pÅ™Ã­kazy pÅ™idÃ¡nÃ­m mezer (napÅ™. X80Z56R52 â†’ X80 Z56 R52)
window.formatCNCCommand = function(text) {
  if (!text) return text;
  // PÅ™idej mezery pÅ™ed G, X, Z, R, D, L, A, AP, RP, CR atd.
  return text.replace(/([GXZRDALC])/g, ' $1').replace(/^\s+/, '').replace(/\s+/g, ' ');
};

// Validuj CNC pÅ™Ã­kaz - vrÃ¡tÃ­ chybovou zprÃ¡vu nebo null pokud je OK
window.validateCNCCommand = function(text) {
  if (!text || text.trim() === '') return 'PrÃ¡zdnÃ½ pÅ™Ã­kaz';

  // OdstraÅˆ mezery pro analÃ½zu
  const clean = text.replace(/\s+/g, '').toUpperCase();

  // Kontrola G-kÃ³dÅ¯
  if (clean.match(/^G[0-3]/)) {
    // G0, G1, G2, G3 - vyÅ¾adujÃ­ parametry
    if (!/[XZ]/.test(clean)) {
      return 'âŒ ChybÃ­ souÅ™adnice: PÅ™idej X nebo Z (napÅ™. G0X50Z100)';
    }
  }

  // Kontrola samostatnÃ©ho R (radius) - mÄ›l by bÃ½t souÄÃ¡st G-kÃ³du nebo kruh
  if (clean.match(/^R\d/) && !clean.match(/^[GX]/)) {
    return 'âŒ R (radius) se musÃ­ psÃ¡t s G-kÃ³dem (napÅ™. G0R50) nebo X/Z souÅ™adnicemi';
  }

  // Kontrola R/CR v kruhu - mÄ›ly by bÃ½t s X a Z
  if (clean.match(/R\d/) && !clean.match(/[XZ]/)) {
    return 'âŒ Radius R se musÃ­ kombinovat se souÅ™adnicemi X nebo Z';
  }

  // Kontrola polÃ¡rnÃ­ch souÅ™adnic
  if (clean.match(/(RP|AP)/) && !clean.match(/[LXZ]/)) {
    return 'âŒ PolÃ¡rnÃ­ souÅ™adnice (RP, AP) se musÃ­ kombinovat s L (dÃ©lka) nebo X/Z';
  }

  return null; // Bez chyby
};

// Auto-formatuj a validuj po zmÃ¡ÄknutÃ­ ";"
window.handleSemicolonInInput = function(inputElement) {
  if (!inputElement) return;

  const fullText = inputElement.value;
  const parts = fullText.split(';');

  // Zpracuj poslednÃ­ ÄÃ¡st (tu, kterou jsme prÃ¡vÄ› zadali)
  const lastPart = parts[parts.length - 2] || ''; // Text pÅ™ed poslednÃ­m ;

  if (lastPart.trim()) {
    // Validuj poslednÃ­ pÅ™Ã­kaz
    const error = window.validateCNCCommand(lastPart);

    if (error) {
      // Zobraz chybu v odpovÃ­dajÃ­cÃ­m error elementu
      let errorElement = null;
      if (inputElement.id === 'quickInputDisplay') {
        errorElement = document.getElementById('quickInputError');
      } else if (inputElement.id === 'aiPrompt') {
        errorElement = document.getElementById('cncInputError');
      }

      if (errorElement) {
        errorElement.textContent = error;
        errorElement.style.display = 'block';
        setTimeout(() => {
          errorElement.style.display = 'none';
        }, 4000);
      } else {
        alert(error);
      }
    }

    // NahraÄ poslednÃ­ ÄÃ¡st formÃ¡tovanou verzÃ­
    const formattedPart = window.formatCNCCommand(lastPart);
    const newText = parts.slice(0, -2).join(';') +
                   (parts.slice(0, -2).length > 0 ? '; ' : '') +
                   formattedPart + '; ';

    inputElement.value = newText;
    inputElement.scrollLeft = inputElement.scrollWidth;
  }
};

// PÅ™idej event listener pro oba input fieldy
window.setupCNCInputListeners = function() {
  // Pro quickInputDisplay (AI klÃ¡vesnice)
  const quickDisplay = document.getElementById('quickInputDisplay');
  if (quickDisplay) {
    quickDisplay.addEventListener('keypress', function(e) {
      if (e.key === ';') {
        e.preventDefault();
        this.value += '; ';
        window.handleSemicolonInInput(this);
      }
    });

    // AlternativnÄ› pÅ™i zmÄ›nÄ› textu
    quickDisplay.addEventListener('input', function() {
      if (this.value.includes(';')) {
        window.handleSemicolonInInput(this);
      }
    });
  }

  // Pro aiPrompt (hlavnÃ­ input v AI panelu)
  const aiPrompt = document.getElementById('aiPrompt');
  if (aiPrompt) {
    aiPrompt.addEventListener('keypress', function(e) {
      if (e.key === ';') {
        e.preventDefault();
        this.value += '; ';
        window.handleSemicolonInInput(this);
      }
    });
  }
};

// Inicializuj pÅ™i naÄtenÃ­
document.addEventListener('DOMContentLoaded', function() {
  setTimeout(() => {
    window.setupCNCInputListeners();
    window.updateQueueDisplay(); // Inicializuj UI queue display

    // PÅ™idej listener na zmÄ›nu modelu
    const modelSelect = document.getElementById("aiModelSelect");
    if (modelSelect) {
      modelSelect.addEventListener("change", function() {
        // Reset timestamps aby se aplikoval novÃ½ limit hned
        window.requestTimestamps = [];
        window.updateQueueDisplay();

        // Zobraz zprÃ¡vu o zmÄ›nÄ› limitu
        const modelName = window.MODEL_LIMITS[this.value]?.name || "Model";
        const limit = window.MODEL_LIMITS[this.value]?.rpm || 15;
        const container = document.getElementById("aiChatHistory");
        if (container) {
          const infoDiv = document.createElement("div");
          infoDiv.className = "chat-msg model";
          infoDiv.style.color = "#90cdf4";
          infoDiv.textContent = `âœ… VybrÃ¡n: ${modelName} (${limit} requestÅ¯/min)`;
          container.appendChild(infoDiv);
          container.scrollTop = container.scrollHeight;
        }
      });
    }
  }, 500);
});

window.showTestOptions = function(testIndex) {
  const test = window.AI_TEST_PROMPTS[testIndex];
  const modal = document.getElementById("aiTestModal");
  const content = document.getElementById("aiTestContent");

  if (!modal || !content) return;

  content.innerHTML = `
    <div style="background: #1a1a1a; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #444">
      <div style="margin-bottom: 12px">
        <h3 style="color: #90cdf4; margin: 0 0 8px 0; font-size: 14px">ğŸ“‹ Test ${testIndex + 1}: ${test.name}</h3>
        <p style="color: #aaa; margin: 0 0 8px 0; font-size: 12px">
          <strong>ÃšroveÅˆ:</strong> ${test.level} |
          <strong>SloÅ¾itost:</strong> ${test.complexity} |
          <strong>OÄekÃ¡vanÃ© tvary:</strong> ${test.expectedShapes}
        </p>
      </div>
      <div style="background: #111; padding: 10px; border-radius: 4px; border: 1px solid #333; font-family: monospace; font-size: 12px; color: #90ee90; word-wrap: break-word; max-height: 100px; overflow-y: auto">
        ${window.formatCNCCommand(test.prompt)}
      </div>
    </div>

    <div style="background: #0a3a2a; padding: 12px; border-radius: 8px; margin-bottom: 15px; border-left: 3px solid #22c55e">
      <p style="color: #90cdf4; margin: 0 0 10px 0; font-size: 13px; font-weight: bold">Vyberte co chcete dÄ›lat:</p>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px">
        <button onclick="window.runSelectedTest(${testIndex})" style="padding: 12px; background: #22c55e; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 13px; text-align: center">
          <div style="font-size: 18px; margin-bottom: 4px">ğŸ¨</div>
          VYKRESLI NA PLÃTNO
        </button>
        <button onclick="window.showTestResponse(${testIndex})" style="padding: 12px; background: #3a7bc8; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 13px; text-align: center">
          <div style="font-size: 18px; margin-bottom: 4px">ğŸ“</div>
          ZOBRAZ ODPOVÄšÄ
        </button>
      </div>
    </div>
  `;
};

window.runSelectedTest = function(testIndex) {
  const test = window.AI_TEST_PROMPTS[testIndex];
  const promptInput = document.getElementById("aiPrompt");
  if (promptInput) {
    promptInput.value = test.prompt;
    window.closeAITestModal();
    if (window.callGemini) window.callGemini();
  }
};

// ===== Spustit vÅ¡echny testy v queue =====
// SpustÃ­ komplexnÃ­ test (prvnÃ­ v poli - index 0)
window.runComplexTest = function() {
  const modal = document.getElementById("aiTestModal");
  if (modal) {
    modal.style.display = "none";
  }

  // Reset vÃ½sledkÅ¯ pÅ™ed spuÅ¡tÄ›nÃ­m
  window.resetTestResults();

  // Nastav batch mode na false - jde o jedinÃ½ test
  window.aiTestBatchMode = false;

  // Ujisti se, Å¾e AI panel je otevÅ™enÃ½
  if (window.toggleAiPanel) {
    window.toggleAiPanel(true);
  }

  // VymaÅ¾ chat historii
  const chatContainer = document.getElementById("aiChatHistory");
  if (chatContainer) {
    chatContainer.innerHTML = "";
  }

  // SpusÅ¥ komplexnÃ­ test (index 0)
  setTimeout(() => {
    if (window.runAITest) {
      window.runAITest(0);
    }
  }, 300);
};

// SpustÃ­ jednotlivÃ½ test
window.runSingleTest = function(testIndex) {
  const modal = document.getElementById("aiTestModal");
  if (modal) {
    modal.style.display = "none";
  }

  // Reset vÃ½sledkÅ¯ pÅ™ed spuÅ¡tÄ›nÃ­m
  window.resetTestResults();

  // Nastav batch mode na false - jde o jedinÃ½ test
  window.aiTestBatchMode = false;

  // Ujisti se, Å¾e AI panel je otevÅ™enÃ½
  if (window.toggleAiPanel) {
    window.toggleAiPanel(true);
  }

  // VymaÅ¾ chat historii
  const chatContainer = document.getElementById("aiChatHistory");
  if (chatContainer) {
    chatContainer.innerHTML = "";
  }

  // SpusÅ¥ vybranÃ½ test
  setTimeout(() => {
    if (window.runAITest) {
      window.runAITest(testIndex);
    }
  }, 300);
};

// PÅ¯vodnÃ­ funkce pro spuÅ¡tÄ›nÃ­ vÅ¡ech testÅ¯ (zachovÃ¡no pro zpÄ›tnou kompatibilitu)
window.runAllTests = function() {
  if (!confirm("âš ï¸ SpuÅ¡tÄ›nÃ­ vÅ¡ech testÅ¯ znamenÃ¡ 20+ API requestÅ¯!\n\nDoporuÄujeme pouÅ¾Ã­t 'KOMPLEXNÃ TEST' mÃ­sto toho (jen 1 request).\n\nOpravdu chcete pokraÄovat?")) {
    return;
  }

  const modal = document.getElementById("aiTestModal");
  if (modal) {
    modal.style.display = "none";
  }

  // Reset vÃ½sledkÅ¯ pÅ™ed spuÅ¡tÄ›nÃ­m
  window.resetTestResults();

  // Nastav batch mode na true - spouÅ¡tÃ­me vÅ¡echny testy
  window.aiTestBatchMode = true;

  // Ujisti se, Å¾e AI panel je otevÅ™enÃ½
  if (window.toggleAiPanel) {
    window.toggleAiPanel(true);
  }

  // VymaÅ¾ chat historii
  const chatContainer = document.getElementById("aiChatHistory");
  if (chatContainer) {
    chatContainer.innerHTML = "";
  }

  // SpusÅ¥ vÅ¡echny testy postupnÄ› od indexu 0
  setTimeout(() => {
    if (window.runAITest) {
      window.runAITest(0);
    }
  }, 300);
};

window.showTestResponse = function(testIndex) {
  const test = window.AI_TEST_PROMPTS[testIndex];
  const modal = document.getElementById("aiTestModal");
  const content = document.getElementById("aiTestContent");

  if (!modal || !content) return;

  content.innerHTML = `
    <div style="background: #0a1a3a; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #3a7bc8">
      <h3 style="color: #90cdf4; margin: 0 0 10px 0; font-size: 14px">âœ¨ SpouÅ¡tÃ­m AI...</h3>
      <p style="color: #aaa; font-size: 12px; margin: 0">Test: ${test.name} (${test.level})</p>
    </div>
  `;

  // SpusÅ¥ AI a pak zobraz vÃ½sledek
  const promptInput = document.getElementById("aiPrompt");
  if (promptInput) {
    promptInput.value = test.prompt;

    // Zavolej Gemini a pak zobraz v vÃ½sledku
    if (window.callGemini) {
      window.callGemini().then(() => {
        // ChvÃ­li poÄkej na zpracovÃ¡nÃ­
        setTimeout(() => {
          const chatHistory = document.getElementById("aiChatHistory");
          let response = "âŒ OdpovÄ›Ä nebyla obdrÅ¾ena";

          if (chatHistory) {
            // Najdi poslednÃ­ zprÃ¡vu od AI (chat-msg model)
            const messages = chatHistory.querySelectorAll(".chat-msg.model");
            if (messages.length > 0) {
              const lastMessage = messages[messages.length - 1];
              response = lastMessage.innerText || lastMessage.textContent;
            }
          }

          content.innerHTML = `
            <div style="background: #0a2a1a; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 2px solid #22c55e">
              <h3 style="color: #22c55e; margin: 0 0 10px 0; font-size: 14px">âœ… OdpovÄ›Ä z AI:</h3>
              <div style="background: #111; padding: 12px; border-radius: 4px; border: 1px solid #333; font-family: monospace; font-size: 11px; color: #90ee90; word-wrap: break-word; max-height: 300px; overflow-y: auto; white-space: pre-wrap">
                ${response}
              </div>
            </div>

            <div style="background: #1a1a1a; padding: 15px; border-radius: 8px; margin-bottom: 15px">
              <h3 style="color: #90cdf4; margin: 0 0 10px 0; font-size: 14px">ğŸ“Š Detaily testu:</h3>
              <div style="font-size: 12px; color: #aaa; line-height: 1.6">
                <div><strong>Prompt:</strong> <code style="color: #90ee90">${window.formatCNCCommand(test.prompt)}</code></div>
                <div style="margin-top: 8px"><strong>OÄekÃ¡vanÃ© tvary:</strong> ${test.expectedShapes}</div>
                <div><strong>Typ:</strong> ${Array.isArray(test.expectedType) ? test.expectedType.join(', ') : test.expectedType}</div>
                <div><strong>SloÅ¾itost:</strong> ${test.complexity}</div>
              </div>
            </div>
          `;
        }, 500);
      }).catch(() => {
        content.innerHTML = `
          <div style="background: #3a1a1a; padding: 15px; border-radius: 8px; border: 2px solid #ff6b6b; color: #ff6b6b">
            âŒ Chyba pÅ™i volÃ¡nÃ­ AI. Zkontroluj API klÃ­Ä a pÅ™ipojenÃ­.
          </div>
        `;
      });
    }
  }
};

window.showAITestPanel = function() {
  const modal = document.getElementById("aiTestModal");
  if (!modal) return;

  // Seskupi testy podle levelu
  const grouped = {};
  window.AI_TEST_PROMPTS.forEach((t, i) => {
    if (!grouped[t.level]) grouped[t.level] = [];
    grouped[t.level].push({ ...t, index: i + 1, actualIndex: i });
  });

  let html = `
    <div style="margin-bottom: 15px; padding: 12px; background: #0a2a1a; border-radius: 6px; border-left: 3px solid #22c55e">
      <div style="display: flex; gap: 10px; align-items: center; justify-content: space-between; margin-bottom: 10px;">
        <p style="color: #90cdf4; margin: 0; font-size: 12px">
          Celkem: <strong>${window.AI_TEST_PROMPTS.length}</strong> testÅ¯
        </p>
        <div style="display: flex; gap: 8px;">
          <button onclick="window.runComplexTest()" style="
            padding: 8px 16px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3)
          " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'" title="KomplexnÃ­ test vÅ¡ech funkcÃ­ v jednom promptu">
            ğŸ¯ KOMPLEXNÃ TEST
          </button>
          <button onclick="window.exportTestResults()" style="
            padding: 6px 12px;
            background: #2563eb;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            font-size: 11px;
            transition: all 0.2s
          " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'" title="Exportovat vÃ½sledky testÅ¯ do JSON">
            ğŸ“Š EXPORT
          </button>
          <button onclick="window.resetTestResults(); alert('âœ… VÃ½sledky testÅ¯ resetovÃ¡ny');" style="
            padding: 6px 12px;
            background: #dc2626;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            font-size: 11px;
            transition: all 0.2s
          " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'" title="Resetovat vÃ½sledky testÅ¯">
            ğŸ”„ RESET
          </button>
        </div>
      </div>
      <p style="color: #888; margin: 0; font-size: 11px">
        ğŸ¯ <strong>KomplexnÃ­ test</strong> = 1 request, testuje vÅ¡echny hlavnÃ­ funkce | Nebo klikni na jednotlivÃ© testy nÃ­Å¾e
      </p>
      <div style="margin-top: 18px; padding: 10px; background: #1a1a1a; border-radius: 6px; border: 1px solid #333;">
        <div style="font-size: 12px; color: #6ab0ff; margin-bottom: 6px;">VlastnÃ­ test podle zadÃ¡nÃ­:</div>
        <textarea id="customTestPrompt" rows="2" style="width: 100%; background: #111; color: #fff; border: 1px solid #444; border-radius: 4px; padding: 6px; font-size: 13px; resize: vertical; margin-bottom: 6px;"></textarea>
        <button onclick="window.runCustomTest()" style="padding: 7px 16px; background: #8b5cf6; color: white; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 12px;">â–¶ï¸ Spustit vlastnÃ­ test</button>
      </div>
    </div>
  `;
// SpuÅ¡tÄ›nÃ­ vlastnÃ­ho testu podle uÅ¾ivatelskÃ©ho zadÃ¡nÃ­
window.runCustomTest = function() {
  const prompt = document.getElementById("customTestPrompt").value.trim();
  if (!prompt) {
    alert("Zadejte prompt pro vlastnÃ­ test.");
    return;
  }
  // VytvoÅ™ doÄasnÃ½ test objekt
  const customTest = {
    name: "ğŸ“ VlastnÃ­ test uÅ¾ivatele",
    prompt: prompt,
    expectedShapes: 0,
    expectedType: [],
    complexity: 1,
    description: "UÅ¾ivatelskÃ½ test zadÃ¡nÃ­"
  };
  // PÅ™idej doÄasnÄ› na konec pole a spusÅ¥
  window.AI_TEST_PROMPTS.push(customTest);
  window.runAITest(window.AI_TEST_PROMPTS.length - 1);
  // Po dokonÄenÃ­ testu odeber z pole, aby se neuklÃ¡dal do historie
  setTimeout(() => {
    window.AI_TEST_PROMPTS.pop();
  }, 2000);
  // ZavÅ™i modal
  document.getElementById("aiTestModal").style.display = "none";
};

  // Zobraz testy seÅ™azenÃ© podle levelu
  Object.keys(grouped).forEach(level => {
    html += `<h3 style="color: #6ab0ff; margin: 12px 0 8px 0; font-size: 13px; border-bottom: 1px solid #444; padding-bottom: 6px">â” ${level} â”</h3>`;
    html += `<div style="display: grid; grid-template-columns: 1fr; gap: 6px; margin-bottom: 12px">`;

    grouped[level].forEach(t => {
      html += `
        <button onclick="window.runSingleTest(${t.actualIndex})" style="
          padding: 10px 12px;
          background: #1a1a1a;
          border: 1px solid #333;
          border-radius: 6px;
          color: #e0e0e0;
          cursor: pointer;
          text-align: left;
          transition: all 0.2s;
          font-size: 12px
        " onmouseover="this.style.borderColor='#6ab0ff'; this.style.background='#222'" onmouseout="this.style.borderColor='#333'; this.style.background='#1a1a1a'" title="Klikni pro spuÅ¡tÄ›nÃ­ tohoto testu">
          <div style="font-weight: bold; color: #6ab0ff">${t.index}. ${t.name}</div>
          <div style="font-size: 11px; color: #888; margin-top: 4px">
            Prompt: "${window.formatCNCCommand(t.prompt).substring(0, 40)}${window.formatCNCCommand(t.prompt).length > 40 ? '...' : ''}" | Tvary: ${t.expectedShapes}
          </div>
        </button>
      `;
    });

    html += `</div>`;
  });

  document.getElementById("aiTestContent").innerHTML = html;
  modal.style.display = "flex";
};

// ===== TEST ALL AI MODELS =====
window.testAllAIModels = async function() {
  console.log("ğŸ§ª Starting AI models test...");

  // ZavÅ™i settings modal
  const settingsModal = document.getElementById("settingsModal");
  if (settingsModal) settingsModal.style.display = "none";

  // OtevÅ™i results modal
  const resultsModal = document.getElementById("aiTestResultsModal");
  const resultsContent = document.getElementById("aiTestResultsContent");
  if (!resultsModal || !resultsContent) return;

  resultsModal.style.display = "flex";
  resultsContent.innerHTML = `
    <div style="text-align: center; padding: 40px; color: #888;">
      <div class="loading-dots" style="display: inline-block;"><div></div><div></div><div></div></div>
      <div style="margin-top: 20px; font-size: 14px;">Testuji vÅ¡echny AI modely...</div>
      <div style="margin-top: 10px; font-size: 12px; color: #666;">To mÅ¯Å¾e trvat nÄ›kolik minut</div>
    </div>
  `;

  const testPrompt = "Test: odpovÄ›z jen ÄÃ­slem 42";
  const results = {
    gemini: [],
    groq: [],
    openrouter: [],
    mistral: []
  };

  // Definice modelÅ¯ pro testovÃ¡nÃ­
  const modelsToTest = {
    gemini: [
      { value: "gemini-2.5-flash-lite", name: "Gemini 2.5 Flash-Lite" },
      { value: "gemini-2.5-flash", name: "Gemini 2.5 Flash" },
      { value: "gemini-3-pro-preview", name: "Gemini 3 Pro" },
      { value: "gemini-2.0-flash-exp", name: "Gemini 2.0 Flash" }
    ],
    groq: [
      { value: "openai/gpt-oss-120b", name: "GPT OSS 120B" },
      { value: "llama-3.3-70b-versatile", name: "Llama 3.3 70B" },
      { value: "openai/gpt-oss-20b", name: "GPT OSS 20B" },
      { value: "llama-3.1-8b-instant", name: "Llama 3.1 8B" }
    ],
    openrouter: [
      { value: "google/gemini-2.0-flash-exp:free", name: "Gemini 2.0 Flash" },
      { value: "meta-llama/llama-3.3-70b-instruct:free", name: "Llama 3.3 70B" },
      { value: "mistralai/mistral-small-3.1-24b-instruct:free", name: "Mistral Small" }
    ],
    mistral: [
      { value: "codestral-latest", name: "Codestral" },
      { value: "mistral-small-latest", name: "Mistral Small" }
    ]
  };

  // Test funkce pro jednotlivÃ½ model
  async function testModel(provider, modelValue, modelName) {
    const startTime = Date.now();
    try {
      let apiKey;
      let endpoint;
      let requestBody;

      // ZÃ­skej API klÃ­Ä podle providera
      if (provider === "gemini") {
        apiKey = window.getCurrentApiKey ? window.getCurrentApiKey() : null;
        if (!apiKey) throw new Error("ChybÃ­ API klÃ­Ä");

        endpoint = `https://generativelanguage.googleapis.com/v1beta/models/${modelValue}:generateContent?key=${apiKey}`;
        requestBody = {
          contents: [{ parts: [{ text: testPrompt }] }],
          generationConfig: {
            temperature: 0.7,
            maxOutputTokens: 50,
          }
        };

        const resp = await fetch(endpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(requestBody)
        });

        if (!resp.ok) {
          const error = await resp.json().catch(() => ({}));
          throw new Error(error.error?.message || `HTTP ${resp.status}`);
        }

        const data = await resp.json();
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text || "No response";
        const latency = Date.now() - startTime;
        return { success: true, latency, response: text.substring(0, 50) };

      } else if (provider === "groq") {
        apiKey = window.getCurrentGroqApiKey ? window.getCurrentGroqApiKey() : null;
        if (!apiKey) throw new Error("ChybÃ­ API klÃ­Ä");

        endpoint = "https://api.groq.com/openai/v1/chat/completions";

        // Reasoning modely (GPT OSS) potÅ™ebujÃ­ vÃ­ce tokenÅ¯
        const isReasoningModel = modelValue.includes("gpt-oss");

        requestBody = {
          model: modelValue,
          messages: [{ role: "user", content: testPrompt }],
          max_tokens: isReasoningModel ? 200 : 50
        };

      } else if (provider === "openrouter") {
        apiKey = window.getCurrentOpenRouterApiKey ? window.getCurrentOpenRouterApiKey() : null;
        if (!apiKey) throw new Error("ChybÃ­ API klÃ­Ä");

        endpoint = "https://openrouter.ai/api/v1/chat/completions";
        requestBody = {
          model: modelValue,
          messages: [{ role: "user", content: testPrompt }],
          max_tokens: 50
        };

      } else if (provider === "mistral") {
        apiKey = window.getCurrentMistralApiKey ? window.getCurrentMistralApiKey() : null;
        if (!apiKey) throw new Error("ChybÃ­ API klÃ­Ä");

        endpoint = "https://api.mistral.ai/v1/chat/completions";
        requestBody = {
          model: modelValue,
          messages: [{ role: "user", content: testPrompt }],
          max_tokens: 50
        };
      }

      // Pro non-Gemini providery
      if (provider !== "gemini") {
        const response = await fetch(endpoint, {
          method: "POST",
          headers: {
            "Authorization": "Bearer " + apiKey,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
          const error = await response.json().catch(() => ({}));
          throw new Error(error.error?.message || `HTTP ${response.status}`);
        }

        const data = await response.json();
        const latency = Date.now() - startTime;

        // Extrahuj text z odpovÄ›di (supporting reasoning models)
        let text = data.choices?.[0]?.message?.content || "";

        // Pro reasoning modely (GPT OSS, o1-like) mÅ¯Å¾e bÃ½t odpovÄ›Ä v "reasoning" poli
        if (!text && data.choices?.[0]?.message?.reasoning) {
          text = data.choices?.[0]?.message?.reasoning;
          console.log(`ğŸ’­ Reasoning model ${modelValue} - extrahovÃ¡n reasoning:`, text.substring(0, 100));
        }

        // Fallback
        if (!text) {
          text = data.choices?.[0]?.text || "No response";
        }

        return { success: true, latency, response: text.substring(0, 50) };
      }

    } catch (error) {
      const latency = Date.now() - startTime;

      // PÅ™eloÅ¾ chybovÃ© zprÃ¡vy do ÄeÅ¡tiny
      let czechError = error.message;

      // 429 - Too Many Requests
      if (czechError.includes("429") || czechError.includes("Too Many Requests") || czechError.includes("rate limit")) {
        czechError = "â±ï¸ PÅ™ekroÄen minutovÃ½ limit poÅ¾adavkÅ¯. Zkus to za chvÃ­li.";
      }
      // Quota exceeded
      else if (czechError.includes("quota") || czechError.includes("Quota exceeded")) {
        czechError = "ğŸ“Š PÅ™ekroÄena kvÃ³ta API. Model nenÃ­ dostupnÃ½ v bezplatnÃ© verzi nebo je vyÄerpÃ¡n dennÃ­ limit.";
      }
      // 401/403 - Auth errors
      else if (czechError.includes("401") || czechError.includes("403") || czechError.includes("Unauthorized") || czechError.includes("Invalid API")) {
        czechError = "ğŸ”‘ ChybnÃ½ nebo chybÄ›jÃ­cÃ­ API klÃ­Ä. Zkontroluj nastavenÃ­.";
      }
      // 404 - Not found
      else if (czechError.includes("404") || czechError.includes("not found")) {
        czechError = "â“ Model nebyl nalezen. MoÅ¾nÃ¡ byl odstranÄ›n nebo pÅ™ejmenovÃ¡n.";
      }
      // 500 - Server error
      else if (czechError.includes("500") || czechError.includes("Internal Server Error")) {
        czechError = "âš ï¸ Chyba serveru API. Zkus to znovu pozdÄ›ji.";
      }
      // Timeout
      else if (czechError.includes("timeout") || czechError.includes("timed out")) {
        czechError = "â° ÄŒasovÃ½ limit vyprÅ¡el. Server neodpovÄ›dÄ›l vÄas.";
      }
      // Network error
      else if (czechError.includes("network") || czechError.includes("fetch")) {
        czechError = "ğŸŒ Chyba sÃ­tÄ›. Zkontroluj pÅ™ipojenÃ­ k internetu.";
      }

      return { success: false, latency, error: czechError };
    }
  }

  // Testuj vÅ¡echny providery
  for (const [provider, models] of Object.entries(modelsToTest)) {
    for (const model of models) {
      console.log(`Testing ${provider}/${model.name}...`);
      const result = await testModel(provider, model.value, model.name);
      results[provider].push({
        name: model.name,
        value: model.value,
        ...result
      });

      // Aktualizuj progress
      const totalTests = Object.values(modelsToTest).reduce((sum, m) => sum + m.length, 0);
      const completedTests = Object.values(results).reduce((sum, r) => sum + r.length, 0);
      resultsContent.innerHTML = `
        <div style="text-align: center; padding: 40px; color: #888;">
          <div class="loading-dots" style="display: inline-block;"><div></div><div></div><div></div></div>
          <div style="margin-top: 20px; font-size: 14px;">Testuji vÅ¡echny AI modely...</div>
          <div style="margin-top: 10px; font-size: 12px; color: #666;">
            Hotovo: ${completedTests} / ${totalTests}
          </div>
        </div>
      `;
    }
  }

  // Vygeneruj vÃ½sledky
  displayTestResults(results);
};

function displayTestResults(results) {
  // UloÅ¾ vÃ½sledky pro moÅ¾nost kopÃ­rovÃ¡nÃ­
  window.lastTestResults = results;

  const resultsContent = document.getElementById("aiTestResultsContent");
  if (!resultsContent) return;

  const providerIcons = {
    gemini: "ğŸ¤–",
    groq: "âš¡",
    openrouter: "ğŸŒ",
    mistral: "ğŸ”¥"
  };

  const providerNames = {
    gemini: "Gemini",
    groq: "Groq",
    openrouter: "OpenRouter",
    mistral: "Mistral"
  };

  let html = `
    <div style="margin-bottom: 20px; padding: 15px; background: #1a2332; border: 1px solid #2563eb; border-radius: 8px;">
      <h3 style="color: #60a5fa; font-size: 14px; margin: 0 0 10px 0;">ğŸ“Š Souhrn</h3>
  `;

  // SpoÄÃ­tej celkovÃ© statistiky
  let totalSuccess = 0;
  let totalFailed = 0;
  let totalLatency = 0;
  let testCount = 0;

  Object.values(results).forEach(providerResults => {
    providerResults.forEach(result => {
      if (result.success) {
        totalSuccess++;
        totalLatency += result.latency;
      } else {
        totalFailed++;
      }
      testCount++;
    });
  });

  const avgLatency = totalSuccess > 0 ? Math.round(totalLatency / totalSuccess) : 0;

  html += `
    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; font-size: 12px;">
      <div style="text-align: center; padding: 10px; background: #0f1419; border-radius: 6px;">
        <div style="color: #4ade80; font-size: 18px; font-weight: bold;">${totalSuccess}</div>
        <div style="color: #888; font-size: 11px;">âœ… Funguje</div>
      </div>
      <div style="text-align: center; padding: 10px; background: #0f1419; border-radius: 6px;">
        <div style="color: #f87171; font-size: 18px; font-weight: bold;">${totalFailed}</div>
        <div style="color: #888; font-size: 11px;">âŒ Chyba</div>
      </div>
      <div style="text-align: center; padding: 10px; background: #0f1419; border-radius: 6px;">
        <div style="color: #60a5fa; font-size: 18px; font-weight: bold;">${avgLatency}ms</div>
        <div style="color: #888; font-size: 11px;">âš¡ PrÅ¯mÄ›rnÃ¡ odezva</div>
      </div>
    </div>
  </div>
  `;

  // VÃ½sledky pro kaÅ¾dÃ½ provider
  Object.entries(results).forEach(([provider, providerResults]) => {
    if (providerResults.length === 0) return;

    const successCount = providerResults.filter(r => r.success).length;
    const failedCount = providerResults.filter(r => !r.success).length;

    html += `
      <div style="margin-bottom: 15px; padding: 15px; background: #1a1a1a; border: 1px solid #333; border-radius: 8px;">
        <h3 style="color: #6ab0ff; font-size: 14px; margin: 0 0 10px 0; display: flex; align-items: center; gap: 8px;">
          <span style="font-size: 20px;">${providerIcons[provider]}</span>
          ${providerNames[provider]}
          <span style="margin-left: auto; font-size: 12px; color: #888;">
            âœ… ${successCount} / âŒ ${failedCount}
          </span>
        </h3>
        <div style="display: flex; flex-direction: column; gap: 8px;">
    `;

    providerResults.forEach(result => {
      const statusColor = result.success ? "#4ade80" : "#f87171";
      const statusIcon = result.success ? "âœ…" : "âŒ";
      const statusText = result.success ? "Funguje" : "Chyba";

      html += `
        <div style="
          padding: 10px;
          background: #0f1419;
          border-left: 3px solid ${statusColor};
          border-radius: 4px;
          font-size: 12px;
        ">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
            <span style="color: #e0e0e0; font-weight: bold;">${result.name}</span>
            <span style="color: ${statusColor}; font-size: 11px;">${statusIcon} ${statusText}</span>
          </div>
          <div style="color: #666; font-size: 10px; font-family: monospace; margin-bottom: 4px;">
            ${result.value}
          </div>
      `;

      if (result.success) {
        html += `
          <div style="display: flex; gap: 15px; font-size: 11px; color: #888;">
            <span>âš¡ ${result.latency}ms</span>
            <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
              ğŸ’¬ "${result.response}"
            </span>
          </div>
        `;
      } else {
        html += `
          <div style="color: #f87171; font-size: 11px; margin-top: 4px;">
            âš ï¸ ${result.error}
          </div>
        `;
      }

      html += `</div>`;
    });

    html += `
        </div>
      </div>
    `;
  });

  resultsContent.innerHTML = html;
}

window.closeAITestResults = function() {
  const modal = document.getElementById("aiTestResultsModal");
  if (modal) modal.style.display = "none";
};

window.copyAITestReport = function() {
  if (!window.lastTestResults) {
    alert("âŒ Nejsou k dispozici Å¾Ã¡dnÃ© vÃ½sledky testÅ¯.");
    return;
  }

  const results = window.lastTestResults;
  const providerNames = {
    gemini: "Gemini",
    groq: "Groq",
    openrouter: "OpenRouter",
    mistral: "Mistral"
  };

  // VytvoÅ™ textovÃ½ report
  let report = "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
  report += "ğŸ§ª VÃSLEDKY TESTOVÃNÃ AI MODELÅ®\n";
  report += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";

  // Souhrn
  let totalSuccess = 0;
  let totalFailed = 0;
  let totalLatency = 0;
  let testCount = 0;

  Object.values(results).forEach(providerResults => {
    providerResults.forEach(result => {
      if (result.success) {
        totalSuccess++;
        totalLatency += result.latency;
      } else {
        totalFailed++;
      }
      testCount++;
    });
  });

  const avgLatency = totalSuccess > 0 ? Math.round(totalLatency / totalSuccess) : 0;

  report += "ğŸ“Š SOUHRN:\n";
  report += `  âœ… Funguje: ${totalSuccess}\n`;
  report += `  âŒ Chyby: ${totalFailed}\n`;
  report += `  âš¡ PrÅ¯mÄ›rnÃ¡ odezva: ${avgLatency}ms\n`;
  report += `  ğŸ“ Celkem testÅ¯: ${testCount}\n\n`;

  // Detaily pro kaÅ¾dÃ½ provider
  Object.entries(results).forEach(([provider, providerResults]) => {
    if (providerResults.length === 0) return;

    const successCount = providerResults.filter(r => r.success).length;
    const failedCount = providerResults.filter(r => !r.success).length;

    report += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n";
    report += `${providerNames[provider].toUpperCase()} (âœ… ${successCount} / âŒ ${failedCount})\n`;
    report += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n";

    providerResults.forEach(result => {
      const statusIcon = result.success ? "âœ…" : "âŒ";
      const statusText = result.success ? "Funguje" : "Chyba";

      report += `\n${statusIcon} ${result.name}\n`;
      report += `   Model: ${result.value}\n`;

      if (result.success) {
        report += `   Odezva: ${result.latency}ms\n`;
        report += `   OdpovÄ›Ä: "${result.response}"\n`;
      } else {
        report += `   âš ï¸ Chyba: ${result.error}\n`;
      }
    });

    report += "\n";
  });

  report += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
  report += `Datum testu: ${new Date().toLocaleString('cs-CZ')}\n`;
  report += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•";

  // ZkopÃ­ruj do schrÃ¡nky
  navigator.clipboard.writeText(report).then(() => {
    alert("âœ… Report zkopÃ­rovÃ¡n do schrÃ¡nky!");
  }).catch(err => {
    console.error("âŒ Chyba pÅ™i kopÃ­rovÃ¡nÃ­:", err);
    // Fallback: zobraz report v alert dialogu
    alert("âŒ AutomatickÃ© kopÃ­rovÃ¡nÃ­ selhalo. Report:\n\n" + report);
  });
};

// ===== HIDE FAILED MODELS =====
window.hideFailedModels = function(shouldHide) {
  if (!window.lastTestResults) {
    alert("âŒ Nejsou k dispozici Å¾Ã¡dnÃ© vÃ½sledky testÅ¯. SpusÅ¥ nejdÅ™Ã­v test modelÅ¯.");
    document.getElementById("hideFailedModelsCheckbox").checked = false;
    return;
  }

  const results = window.lastTestResults;
  const modelSelect = document.getElementById("aiModelSelect");
  if (!modelSelect) return;

  // ZÃ­skej seznam nefunkÄnÃ­ch modelÅ¯
  const failedModels = new Set();
  Object.values(results).forEach(providerResults => {
    providerResults.forEach(result => {
      if (!result.success) {
        failedModels.add(result.value);
      }
    });
  });

  // UloÅ¾ stav do localStorage
  if (shouldHide) {
    localStorage.setItem("hideFailedModels", "true");
    localStorage.setItem("failedModelsList", JSON.stringify([...failedModels]));
  } else {
    localStorage.removeItem("hideFailedModels");
    localStorage.removeItem("failedModelsList");
  }

  // Aplikuj zmÄ›ny na select
  Array.from(modelSelect.options).forEach(option => {
    if (failedModels.has(option.value)) {
      if (shouldHide) {
        option.style.display = "none";
        option.disabled = true;

        // Pokud je vybranÃ½ nefunkÄnÃ­ model, vyber prvnÃ­ funkÄnÃ­
        if (option.selected) {
          const firstWorking = Array.from(modelSelect.options).find(opt => !failedModels.has(opt.value));
          if (firstWorking) {
            firstWorking.selected = true;
          }
        }
      } else {
        option.style.display = "";
        option.disabled = false;
      }
    }
  });

  const count = failedModels.size;
  if (shouldHide && count > 0) {
    alert(`âœ… Skryto ${count} nefunkÄnÃ­ch modelÅ¯.\n\nModely:\n${[...failedModels].join('\n')}`);
  } else if (!shouldHide) {
    alert(`âœ… VÅ¡echny modely jsou znovu zobrazeny.`);
  }
};

// PÅ™i naÄtenÃ­ strÃ¡nky zkontroluj, jestli jsou nÄ›jakÃ© modely skrytÃ©
document.addEventListener('DOMContentLoaded', () => {
  const shouldHide = localStorage.getItem("hideFailedModels") === "true";
  const failedModelsStr = localStorage.getItem("failedModelsList");

  if (shouldHide && failedModelsStr) {
    try {
      const failedModels = new Set(JSON.parse(failedModelsStr));
      const modelSelect = document.getElementById("aiModelSelect");

      if (modelSelect) {
        Array.from(modelSelect.options).forEach(option => {
          if (failedModels.has(option.value)) {
            option.style.display = "none";
            option.disabled = true;
          }
        });
      }
    } catch (e) {
      console.warn("NepodaÅ™ilo se naÄÃ­st seznam skrytÃ½ch modelÅ¯:", e);
    }
  }
});

// ===== MODEL MANAGER =====
const ALL_MODELS = {
  gemini: [
    { value: "gemini-2.5-flash-lite", name: "âš¡ Gemini 2.5 Flash-Lite (VyÅ¡Å¡Ã­ limit)" },
    { value: "gemini-2.5-flash", name: "âš¡ Gemini 2.5 Flash (RychlÃ½)" },
    { value: "gemini-3-pro-preview", name: "ğŸ§ª Gemini 3 Pro (NejchytÅ™ejÅ¡Ã­)" },
    { value: "gemini-2.0-flash-exp", name: "âš¡ Gemini 2.0 Flash (Exp)" }
  ],
  groq: [
    { value: "openai/gpt-oss-120b", name: "ğŸ§  GPT OSS 120B (~500 tok/s)" },
    { value: "llama-3.3-70b-versatile", name: "ğŸ’¬ Llama 3.3 70B (nejlepÅ¡Ã­ pro chat)" },
    { value: "openai/gpt-oss-20b", name: "âš¡ GPT OSS 20B (~1000 tok/s)" },
    { value: "llama-3.1-8b-instant", name: "âš¡ Llama 3.1 8B (nejrychlejÅ¡Ã­)" }
  ],
  openrouter: [
    { value: "google/gemini-2.0-flash-exp:free", name: "ğŸ¤– Gemini 2.0 Flash :free" },
    { value: "meta-llama/llama-3.3-70b-instruct:free", name: "ğŸ¦™ Llama 3.3 70B :free" },
    { value: "mistralai/mistral-small-3.1-24b-instruct:free", name: "ğŸ”¥ Mistral Small :free" }
  ],
  mistral: [
    { value: "codestral-latest", name: "ğŸ’» Codestral (kÃ³dovÃ¡nÃ­)" },
    { value: "mistral-small-latest", name: "âš¡ Mistral Small (rychlÃ½)" }
  ]
};

// Load enabled models from localStorage
window.loadEnabledModels = function() {
  try {
    const stored = localStorage.getItem("enabledAIModels");
    if (stored) {
      return new Set(JSON.parse(stored));
    }
  } catch (e) {
    console.warn("NepodaÅ™ilo se naÄÃ­st enabled models:", e);
  }
  // Default - vÅ¡echny modely povolenÃ©
  const allModelValues = Object.values(ALL_MODELS).flat().map(m => m.value);
  return new Set(allModelValues);
}

// Save enabled models to localStorage
function saveEnabledModels(enabledSet) {
  try {
    localStorage.setItem("enabledAIModels", JSON.stringify([...enabledSet]));
  } catch (e) {
    console.error("NepodaÅ™ilo se uloÅ¾it enabled models:", e);
  }
}

// Open model manager modal
window.openModelManager = function() {
  const modal = document.getElementById("modelManagerModal");
  const content = document.getElementById("modelManagerContent");
  if (!modal || !content) return;

  const enabledModels = window.loadEnabledModels();

  const providerIcons = {
    gemini: "ğŸ¤–",
    groq: "âš¡",
    openrouter: "ğŸŒ",
    mistral: "ğŸ”¥"
  };

  const providerNames = {
    gemini: "Gemini",
    groq: "Groq",
    openrouter: "OpenRouter",
    mistral: "Mistral"
  };

  let html = "";

  Object.entries(ALL_MODELS).forEach(([provider, models]) => {
    html += `
      <div style="margin-bottom: 15px; padding: 12px; background: #1a1a1a; border: 1px solid #333; border-radius: 8px;">
        <h3 style="color: #6ab0ff; font-size: 14px; margin: 0 0 10px 0; display: flex; align-items: center; gap: 8px;">
          <span style="font-size: 20px;">${providerIcons[provider]}</span>
          ${providerNames[provider]}
        </h3>
        <div style="display: flex; flex-direction: column; gap: 6px;">
    `;

    models.forEach(model => {
      const isEnabled = enabledModels.has(model.value);
      html += `
        <label style="
          display: flex;
          align-items: center;
          gap: 10px;
          padding: 8px;
          background: #0f1419;
          border-radius: 4px;
          cursor: pointer;
          transition: background 0.2s;
          user-select: none;
        "
        onmouseover="this.style.background='#1a2332'"
        onmouseout="this.style.background='#0f1419'"
        >
          <input
            type="checkbox"
            value="${model.value}"
            ${isEnabled ? 'checked' : ''}
            onchange="window.toggleModel('${model.value}', this.checked)"
            style="width: 18px; height: 18px; accent-color: #2563eb; cursor: pointer;"
          />
          <span style="color: #e0e0e0; font-size: 12px; flex: 1;">${model.name}</span>
          <span style="color: #666; font-size: 10px; font-family: monospace;">${model.value}</span>
        </label>
      `;
    });

    html += `
        </div>
      </div>
    `;
  });

  content.innerHTML = html;
  modal.style.display = "flex";
};

// Close model manager modal
window.closeModelManager = function() {
  const modal = document.getElementById("modelManagerModal");
  if (modal) modal.style.display = "none";

  // Reload models in select
  updateModelsForProvider();
};

// Toggle single model
window.toggleModel = function(modelValue, enabled) {
  const enabledModels = window.loadEnabledModels();

  if (enabled) {
    enabledModels.add(modelValue);
  } else {
    enabledModels.delete(modelValue);
  }

  saveEnabledModels(enabledModels);
};

// Select/deselect all models
window.selectAllModels = function(selectAll) {
  const content = document.getElementById("modelManagerContent");
  if (!content) return;

  const checkboxes = content.querySelectorAll('input[type="checkbox"]');
  const enabledModels = window.loadEnabledModels();

  checkboxes.forEach(checkbox => {
    checkbox.checked = selectAll;
    if (selectAll) {
      enabledModels.add(checkbox.value);
    } else {
      enabledModels.delete(checkbox.value);
    }
  });

  saveEnabledModels(enabledModels);
};

// PÅ™i naÄtenÃ­ strÃ¡nky aplikuj enabled modely
document.addEventListener('DOMContentLoaded', () => {
  // Po malÃ©m timeoutu, aby se naÄetly vÅ¡echny selecty
  setTimeout(() => {
    if (window.updateModelsForProvider) {
      window.updateModelsForProvider();
    }
  }, 100);
});

// ===== EXPORT =====
if (typeof module !== "undefined" && module.exports) {
  module.exports = {
    callGemini,
    toggleAiPanel,
    clearChat,
  };
}

