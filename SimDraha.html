<<<<<<< HEAD

<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gener√°tor CAM pro Sinumerik 840D (Auto-Trim) - Full AI Control</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- jsPDF pro generov√°n√≠ PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- Gemini SDK Import Map -->
    <script type="importmap">
    {
      "imports": {
        "@google/genai": "https://esm.run/@google/genai"
      }
    }
    </script>

    <style>
        body { overscroll-behavior: none; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #9ca3af; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .canvas-container { cursor: crosshair; touch-action: none; background-image: radial-gradient(#ccc 1px, transparent 1px); background-size: 20px 20px; }
        .dark .canvas-container { background-image: radial-gradient(#333 1px, transparent 1px); }
        .safe-pb { padding-bottom: env(safe-area-inset-bottom); }
        /* Styl pro aktivn√≠ ≈ô√°dek k√≥du */
        .code-line.active { background-color: rgba(59, 130, 246, 0.2); font-weight: bold; border-left: 3px solid #3b82f6; }
        .dark .code-line.active { background-color: rgba(59, 130, 246, 0.3); border-left: 3px solid #60a5fa; }
        
        /* Animace pro mikrofon */
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        .mic-active { animation: pulse-red 1.5s infinite; background-color: #ef4444 !important; border-color: #ef4444 !important; color: white !important; }
    </style>
</head>
<body class="h-[100dvh] w-screen overflow-hidden flex flex-col font-sans transition-colors duration-300">

    <div id="root" class="h-full w-full"></div>

    <script type="text/babel" data-type="module">
        import { GoogleGenAI } from "@google/genai";

        // --- POLYFILL PRO PROCESS.ENV & API KEY MANAGEMENT ---
        const CUSTOM_KEY_STORAGE = 'sinumerik_custom_api_key';
        const KEY_HISTORY_STORAGE = 'sinumerik_api_key_history';
        
        // P≈òEDVYPLNƒöN√ù KL√çƒå (Bezpeƒçnostn√≠ riziko na ve≈ôejn√©m GitHubu!)
        // U≈æivatel si p≈ô√°l tento kl√≠ƒç p≈ôedvyplnit.
        const HARDCODED_SUFFIX = "SyCLBHN-IxCTKc0tXDsdp7T0TTj81FlnKlI";
        const DEFAULT_FULL_KEY = "AIza" + HARDCODED_SUFFIX;
        
        // Inicializace: Zkus√≠me naƒç√≠st vlastn√≠ kl√≠ƒç z localStorage, jinak pou≈æijeme hardcoded default
        const initialKey = localStorage.getItem(CUSTOM_KEY_STORAGE) || DEFAULT_FULL_KEY;

        if (typeof process === "undefined") {
            window.process = { env: { API_KEY: initialKey } };
        } else if (!process.env.API_KEY) {
             process.env.API_KEY = initialKey;
        }
        
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // --- ICONS ---
        const IconTrash = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;
        const IconPlus = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>;
        const IconSun = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>;
        const IconMoon = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>;
        const IconEdit = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path></svg>;
        const IconBox = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>;
        const IconMagic = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><path d="m12 2 2.5 5.5L20 9l-4 3.5L17.5 18 12 15l-5.5 3L8 12.5 4 9l5.5-1.5L12 2z"></path></svg>;
        const IconClipboard = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>;
        const IconInsert = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>;
        const IconTarget = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line></svg>;
        const IconEye = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>;
        const IconPlay = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M5 3l14 9-14 9V3z"/></svg>;
        const IconPause = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>;
        const IconStop = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="6" width="12" height="12" /></svg>;
        const IconDownload = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>;
        const IconUpload = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>;
        const IconArrowRight = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>;
        const IconArrowDown = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></svg>;
        const IconWarning = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ef4444" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>;
        const IconRefresh = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>;
        const IconUndo = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 7v6h6"></path><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"></path></svg>;
        const IconRedo = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 7v6h-6"></path><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13"></path></svg>;
        const IconFileText = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>;
        const IconPlusCircle = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>;
        const IconSpark = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z"/><path d="M20 3v4"/><path d="M22 5h-4"/><path d="M4 17v2"/><path d="M5 18H3"/></svg>;
        const IconVoiceChat = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/><line x1="9" y1="10" x2="15" y2="10"/><line x1="12" y1="7" x2="12" y2="13"/></svg>;
        const IconKey = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path></svg>;
        const IconMicrophone = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>;
        const IconClock = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>;
        const IconDatabase = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path></svg>;

        // NEW ICONS FOR FEATURES
        const IconDocumentScanner = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 7V5a2 2 0 0 1 2-2h2"/><path d="M17 3h2a2 2 0 0 1 2-2v2"/><path d="M21 17v2a2 2 0 0 1-2 2h-2"/><path d="M7 21H5a2 2 0 0 1-2-2v-2"/><rect x="7" y="7" width="10" height="10" rx="1"/></svg>;
        const IconBolt = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M11 21l-1-11H4l11-10 1 11h6L11 21z"/></svg>;
        const IconNetworkIntelligence = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line></svg>;
        const IconX = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;
        const IconSave = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>;
        const IconBookmark = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>;
        const IconTerminal = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line></svg>;

        // Shape Icons for Buttons
        const IconShapeCircle = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none"><circle cx="12" cy="12" r="10"/></svg>;
        const IconShapePolygon = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M3 3h18v18H3z"/></svg>;

        // --- CONSTANTS ---
        const MATERIALS = {
            'Ocel 11 373 (S235)': { speed: 200, feed: 0.25, depth: 2.5, name: "Ocel (Mƒõkk√°)" },
            'Ocel 14 220 (Cement)': { speed: 160, feed: 0.2, depth: 1.5, name: "Ocel (Tvrd≈°√≠)" },
            'Nerez 17 240 (304)': { speed: 120, feed: 0.15, depth: 1.0, name: "Nerez" },
            'Hlin√≠k (AlSi)': { speed: 400, feed: 0.35, depth: 4.0, name: "Hlin√≠k" },
            'Mosaz': { speed: 300, feed: 0.2, depth: 2.5, name: "Mosaz" },
            'Plast (POM)': { speed: 500, feed: 0.4, depth: 5.0, name: "Plast" }
        };

        // --- COMPONENTS ---
        
        const SmartInput = ({ value, onValueChange, className, placeholder, type = "text", step }) => {
            const [localVal, setLocalVal] = useState(value);
            const [isDirty, setIsDirty] = useState(false);

            useEffect(() => { setLocalVal(value); }, [value]);

            useEffect(() => {
                if (!isDirty) return;
                const handler = setTimeout(() => { onValueChange(localVal); setIsDirty(false); }, 600); 
                return () => clearTimeout(handler);
            }, [localVal, isDirty, onValueChange]);

            const handleChange = (e) => { setLocalVal(e.target.value); setIsDirty(true); };
            const handleBlur = () => { if (isDirty) { onValueChange(localVal); setIsDirty(false); } };
            const handleKeyDown = (e) => { if (e.key === 'Enter') { if (isDirty) { onValueChange(localVal); setIsDirty(false); } e.target.blur(); } };

            return (
                <input type={type} className={className} placeholder={placeholder} value={localVal} onChange={handleChange} onBlur={handleBlur} onKeyDown={handleKeyDown} step={step} />
            );
        };
        
        const AiAssistant = ({ contourPoints, stockPoints, params, onUpdateContour, onUpdateStock, onUpdateParams, onUpdateGCode, theme }) => {
            // --- AI HISTORY LOGIC ---
            const CHAT_STORAGE_KEY = 'sinumerik_chat_history_v1';
            
            const [messages, setMessages] = useState(() => {
                const saved = localStorage.getItem(CHAT_STORAGE_KEY);
                if (saved) {
                    try { return JSON.parse(saved); } catch(e) {}
                }
                return [{ role: 'model', text: 'Dobr√Ω den, jsem v√°≈° AI asistent pro CNC programov√°n√≠. S ƒç√≠m v√°m mohu pomoci?' }];
            });

            // Save history on change
            useEffect(() => {
                localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(messages));
            }, [messages]);

            const clearHistory = () => {
                if(confirm("Opravdu chcete vymazat celou historii chatu?")) {
                    const resetState = [{ role: 'model', text: 'Historie byla vymaz√°na. Jak mohu pomoci d√°le?' }];
                    setMessages(resetState);
                    localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(resetState));
                }
            };
            
            const [input, setInput] = useState('');
            const [loading, setLoading] = useState(false);
            const [mode, setMode] = useState('normal'); 
            const [image, setImage] = useState(null); 
            const [savedPrompts, setSavedPrompts] = useState([]);
            const [showPrompts, setShowPrompts] = useState(false);
            const [isListening, setIsListening] = useState(false);
            
            // API Key Management State
            const [showApiKeyInput, setShowApiKeyInput] = useState(false);
            
            // LOGIKA PRO ROZDƒöLEN√ù KL√çƒå (Split Key Logic)
            const [apiKeySuffix, setApiKeySuffix] = useState(() => {
                // Naƒçteme cel√Ω kl√≠ƒç z √∫lo≈æi≈°tƒõ
                const fullKey = localStorage.getItem('sinumerik_custom_api_key') || '';
                // Pokud zaƒç√≠n√° na AIza, vezmeme zbytek.
                if (fullKey.startsWith('AIza')) {
                    return fullKey.substring(4); // Od≈ô√≠zneme prvn√≠ 4 znaky
                }
                // P≈òEDVYPLNƒöN√ù KL√çƒå NA ≈Ω√ÅDOST
                return HARDCODED_SUFFIX;
            });

            // API KEY HISTORY
            const [keyHistory, setKeyHistory] = useState([]);

            useEffect(() => {
                try {
                    const hist = JSON.parse(localStorage.getItem(KEY_HISTORY_STORAGE) || '[]');
                    setKeyHistory(hist);
                } catch(e) {}
            }, []);

            const updateKeyHistory = (newSuffix) => {
                const cleanSuffix = newSuffix.trim();
                const newHist = [cleanSuffix, ...keyHistory.filter(k => k !== cleanSuffix)].slice(0, 5); 
                setKeyHistory(newHist);
                localStorage.setItem(KEY_HISTORY_STORAGE, JSON.stringify(newHist));
            };

            const deleteFromHistory = (val) => {
                const newHist = keyHistory.filter(k => k !== val);
                setKeyHistory(newHist);
                localStorage.setItem(KEY_HISTORY_STORAGE, JSON.stringify(newHist));
            };

            const scrollRef = useRef(null);
            const fileInputRef = useRef(null);
            const importPromptsInputRef = useRef(null);
            const PROMPTS_KEY = 'sinumerik_cam_ai_prompts';
            
            // Recognition ref
            const recognitionRef = useRef(null);

            useEffect(() => {
                if(scrollRef.current) scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
            }, [messages]);

            useEffect(() => {
                const saved = localStorage.getItem(PROMPTS_KEY);
                if (saved) {
                    try { setSavedPrompts(JSON.parse(saved)); } catch(e) {}
                }
            }, []);

            const toggleListening = () => {
                if (isListening) {
                    if (recognitionRef.current) recognitionRef.current.stop();
                    setIsListening(false);
                } else {
                    if (!window.webkitSpeechRecognition && !window.SpeechRecognition) {
                        alert("V√°≈° prohl√≠≈æeƒç nepodporuje rozpozn√°v√°n√≠ hlasu.");
                        return;
                    }
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    const recognition = new SpeechRecognition();
                    recognition.lang = 'cs-CZ';
                    recognition.interimResults = false;
                    recognition.maxAlternatives = 1;

                    recognition.onstart = () => setIsListening(true);
                    recognition.onend = () => setIsListening(false);
                    recognition.onerror = (event) => { 
                        console.error(event.error); 
                        setIsListening(false); 
                        if (event.error === 'not-allowed') {
                             alert("P≈ô√≠stup k mikrofonu byl zam√≠tnut. Povolte pros√≠m mikrofon v nastaven√≠ prohl√≠≈æeƒçe.");
                        }
                    };
                    
                    recognition.onresult = (event) => {
                        const transcript = event.results[0][0].transcript;
                        setInput(prev => prev + (prev ? ' ' : '') + transcript);
                    };

                    recognitionRef.current = recognition;
                    recognition.start();
                }
            };

            const handleSaveApiKey = (overrideSuffix = null) => {
                const suffix = (typeof overrideSuffix === 'string' ? overrideSuffix : apiKeySuffix).trim();
                
                // P≈ô√≠pad 1: Maz√°n√≠ kl√≠ƒçe (pokud je pole pr√°zdn√©)
                if (!suffix) {
                    if(confirm("Opravdu chcete smazat ulo≈æen√Ω API kl√≠ƒç?")) {
                        localStorage.removeItem('sinumerik_custom_api_key');
                        if(window.process && window.process.env) window.process.env.API_KEY = "";
                        alert("üóëÔ∏è Kl√≠ƒç byl odstranƒõn.");
                        setShowApiKeyInput(false);
                    }
                    return;
                }

                // P≈ô√≠pad 2: Ukl√°d√°n√≠ kl√≠ƒçe s validac√≠
                if (suffix.length < 20) { 
                    alert("‚ùå ODM√çTNUTO: Zadan√Ω kl√≠ƒç se zd√° b√Ωt neplatn√Ω nebo p≈ô√≠li≈° kr√°tk√Ω.");
                    return;
                }

                try {
                    // Spoj√≠me fixn√≠ prefix a u≈æivatelsk√Ω suffix
                    const fullKey = "AIza" + suffix;
                    localStorage.setItem('sinumerik_custom_api_key', fullKey);
                    
                    // Nastav√≠me do prost≈ôed√≠ pro okam≈æit√© pou≈æit√≠
                    if(window.process && window.process.env) window.process.env.API_KEY = fullKey;
                    
                    // Ulo≈æit do historie
                    updateKeyHistory(suffix);
                    
                    // POTVRZOVAC√ç OKNO - P≈òIJET√ç
                    alert("‚úÖ P≈òIJATO: API kl√≠ƒç byl √∫spƒõ≈°nƒõ ulo≈æen a aktivov√°n.\n\nNyn√≠ m≈Ø≈æete vyu≈æ√≠vat AI asistenta.");
                    setShowApiKeyInput(false);
                } catch(e) {
                     alert("‚ùå Chyba p≈ôi ukl√°d√°n√≠ kl√≠ƒçe: " + e.message);
                }
            };

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setImage(reader.result);
                    };
                    reader.readAsDataURL(file);
                }
            };

            const removeImage = () => {
                setImage(null);
                if (fileInputRef.current) fileInputRef.current.value = '';
            };

            const handleSavePrompt = () => {
                if (!input.trim()) return;
                const newPrompt = { id: Date.now(), text: input.trim() };
                const updated = [newPrompt, ...savedPrompts];
                setSavedPrompts(updated);
                localStorage.setItem(PROMPTS_KEY, JSON.stringify(updated));
            };

            const handleDeletePrompt = (id) => {
                const updated = savedPrompts.filter(p => p.id !== id);
                setSavedPrompts(updated);
                localStorage.setItem(PROMPTS_KEY, JSON.stringify(updated));
            };
            
            const handleExportPrompts = () => {
                const data = JSON.stringify(savedPrompts, null, 2);
                const blob = new Blob([data], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'prompty_zaloha.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            const handleImportPrompts = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const imported = JSON.parse(ev.target.result);
                        if (Array.isArray(imported)) {
                            const newPrompts = imported.map(p => ({
                                id: Date.now() + Math.random(),
                                text: p.text || p 
                            }));
                            const updated = [...savedPrompts, ...newPrompts];
                            setSavedPrompts(updated);
                            localStorage.setItem(PROMPTS_KEY, JSON.stringify(updated));
                            alert("Prompty √∫spƒõ≈°nƒõ importov√°ny.");
                        } else {
                            alert("Neplatn√Ω form√°t souboru.");
                        }
                    } catch (err) {
                        alert("Chyba p≈ôi ƒçten√≠ souboru: " + err.message);
                    }
                };
                reader.readAsText(file);
                e.target.value = ''; 
            };

            const handleLoadPrompt = (text) => {
                setInput(text);
                setShowPrompts(false);
            };
            
            const handleQuickAction = (actionText) => {
                setInput(actionText);
                setTimeout(() => handleSend(actionText), 100);
            };

            const handleSend = async (overrideInput = null) => {
                const textToSend = overrideInput || input;
                if (!textToSend.trim() && !image) return;
                
                // Kontrola existence kl√≠ƒçe p≈ôed odesl√°n√≠m
                if (!process.env.API_KEY || process.env.API_KEY.trim() === "") {
                    setShowApiKeyInput(true);
                    setMessages(prev => [...prev, { role: 'model', text: "‚ö†Ô∏è Pro komunikaci s AI je nutn√© zadat API kl√≠ƒç. Otev≈ôel jsem pro v√°s nastaven√≠ naho≈ôe. Zadejte pros√≠m zbytek va≈°eho Google Gemini API kl√≠ƒçe." }]);
                    return;
                }
                
                const userMsg = { role: 'user', text: textToSend, image: image };
                setMessages(prev => [...prev, userMsg]);
                setInput('');
                setImage(null);
                if (fileInputRef.current) fileInputRef.current.value = '';
                setLoading(true);

                try {
                    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
                    
                    const systemContext = `
                        Current CNC Configuration:
                        - Machine: ${params.machineType} (${params.machineStructure})
                        - Control: ${params.controlSystem}
                        - Params: ${JSON.stringify(params, null, 2)}
                        - Contour Points: ${JSON.stringify(contourPoints)}
                        - Stock Points: ${JSON.stringify(stockPoints)}
                    `;

                    const systemInstruction = `Jsi expertn√≠ AI asistent pro aplikaci 'Sinumerik CAM Generator'.
                    
                    TAH√ÅK PARAMETR≈Æ (CO M≈Æ≈ΩE≈† MƒöNIT V "params"):
                    - toolRadius (ƒç√≠slo): R√°dius ≈°piƒçky n√°stroje (nap≈ô. 0.4, 0.8). KRITICK√â PRO KOREKCE!
                    - toolName (≈ôetƒõzec): N√°zev n√°stroje (nap≈ô. "N≈Æ≈Ω").
                    - speed (ƒç√≠slo): ≈òezn√° rychlost (m/min).
                    - feed (ƒç√≠slo): Posuv (mm/ot).
                    - depthOfCut (ƒç√≠slo): Hloubka t≈ô√≠sky (ap).
                    - roughingStrategy (≈ôetƒõzec): 'longitudinal' (pod√©lnƒõ) / 'face' (ƒçelnƒõ).
                    - doFinishing (bool): Zda generovat dokonƒçovac√≠ t≈ô√≠sku.
                    - allowanceX, allowanceZ (ƒç√≠sla): P≈ô√≠davky na dokonƒçen√≠.
                    - machineType (≈ôetƒõzec): Nap≈ô. 'LIMS=2000'.
                    - controlSystem (≈ôetƒõzec): 'sinumerik' / 'fanuc' / 'heidenhain'.
                    - stockMode, stockDiameter, stockLength... (parametry polotovaru).

                    PRAVIDLO PRO KOREKCI R√ÅDIUSU (TOOL RADIUS COMPENSATION):
                    V parametrech je nastaven 'toolRadius' (aktu√°lnƒõ: ${params.toolRadius}).
                    Pokud generuje≈° G-k√≥d pro obroben√≠ kontury na ƒçisto:
                    1. MUS√ç≈† pou≈æ√≠t G41 (vlevo) nebo G42 (vpravo) podle smƒõru obr√°bƒõn√≠.
                    2. NEBO pokud generuje≈° body ruƒçnƒõ, mus√≠≈° sou≈ôadnice posunout o r√°dius a vektorovƒõ p≈ôipoƒç√≠tat korekci (ekvidistanta).
                    3. NIKDY nejeƒè st≈ôedem n√°stroje p≈ô√≠mo po sou≈ôadnic√≠ch kontury, pokud to nen√≠ z√°mƒõr (nap≈ô. hrubov√°n√≠ s p≈ô√≠davkem vƒõt≈°√≠m ne≈æ r√°dius).

                    HLAVN√ç OMEZEN√ç APLIKACE A SIMUL√ÅTORU:
                    1. TOTO NEN√ç PLNOHODNOTN√ù CAD/CAM. Je to lehk√Ω webov√Ω n√°stroj pro generov√°n√≠ G-k√≥du soustru≈æen√≠.
                    2. SIMUL√ÅTOR: Vykresluje pouze explicitn√≠ sou≈ôadnice (G0/G1/G2/G3). NEUM√ç simulovat/vykreslit vysok√© cykly (jako CYCLE95, G71, G72). Pokud vygeneruje≈° k√≥d s cykly, simul√°tor uk√°≈æe pouze ƒç√°ru od startu do konce, nikoliv odeb√≠r√°n√≠ materi√°lu.
                    3. GENER√ÅTOR: Pokud chce u≈æivatel zmƒõnit parametry, VRA≈§ JSON:
                       - Zmƒõna kontury: {"type": "contour", "points": [{"type": "G1", "x": 20, "z": -10, "r": 0, "mode": "ABS"}, ...]}
                       - Zmƒõna polotovaru: {"type": "stock", "points": [...]}
                       - Zmƒõna parametr≈Ø: {"type": "params", "data": {"feed": 0.2, "speed": 150, "toolName": "N≈Æ≈Ω", "roughingStrategy": "face"}}
                       Dostupn√© parametry: machineType, toolName, speed, feed, depthOfCut, roughingStrategy ('longitudinal'/'face'), stockMode ('cylinder'/'casting').

                    JAZYK: Odpov√≠dej ƒçesky, struƒçnƒõ a technicky p≈ôesnƒõ. Buƒè n√°pomocn√Ω oper√°torovi CNC.
                    `;

                    let modelName = "gemini-2.5-flash"; 
                    let requestConfig = {
                        systemInstruction: { parts: [{ text: systemInstruction }] }
                    };

                    if (mode === 'fast' && !userMsg.image) {
                        modelName = "gemini-2.5-flash-lite-latest";
                    } else if (mode === 'thinking') {
                        modelName = "gemini-3-pro-preview"; 
                        requestConfig.thinkingConfig = { thinkingBudget: 32768 };
                    }
                    if (userMsg.image) {
                        modelName = "gemini-2.5-flash"; 
                    }

                    const history = messages.map(m => {
                        const parts = [];
                        if (m.image) {
                             parts.push({ text: "[User uploaded an image]" });
                        }
                        if (m.text) parts.push({ text: m.text });
                        return { role: m.role, parts };
                    });

                    const currentParts = [];
                    if (userMsg.image) {
                        const base64Data = userMsg.image.split(',')[1];
                        const mimeType = userMsg.image.split(';')[0].split(':')[1];
                        currentParts.push({ inlineData: { mimeType, data: base64Data } });
                    }
                    currentParts.push({ text: systemContext + "\n\nUser Request: " + userMsg.text });

                    const contents = [
                        ...history,
                        { role: 'user', parts: currentParts }
                    ];

                    let text = "";
                    
                    try {
                        const result = await ai.models.generateContent({
                            model: modelName,
                            contents: contents,
                            config: requestConfig
                        });
                        text = result.text;
                    } catch (retryError) {
                        // Fallback pro chyby p≈ôet√≠≈æen√≠ nebo kv√≥ty
                        if (retryError.message.includes("429") || retryError.message.includes("503") || retryError.status === 429 || retryError.status === 503) {
                             console.warn("Model error, switching to Flash:", retryError);
                             setMessages(prev => [...prev, { role: 'model', text: "‚ö†Ô∏è Model 'Pro' je moment√°lnƒõ p≈ôet√≠≈æen nebo do≈°lo k vyƒçerp√°n√≠ kv√≥ty. P≈ôep√≠n√°m na 'Flash' model a zkou≈°√≠m to znovu..." }]);
                             
                             // Odstranit thinking config pro fallback
                             const fallbackConfig = { ...requestConfig };
                             delete fallbackConfig.thinkingConfig;
                             
                             const fallbackResult = await ai.models.generateContent({
                                model: "gemini-2.5-flash",
                                contents: contents,
                                config: fallbackConfig
                            });
                            text = fallbackResult.text;
                        } else {
                            throw retryError;
                        }
                    }
                    
                    let suggestedPoints = null;
                    let suggestedStock = null;
                    let suggestedParams = null;
                    let suggestedCode = null;

                    try {
                        const jsonMatch = text.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.type === 'contour') suggestedPoints = parsed.points;
                            else if (parsed.type === 'stock') suggestedStock = parsed.points;
                            else if (parsed.type === 'params') suggestedParams = parsed.data;
                            else if (Array.isArray(parsed) && parsed[0].type) suggestedPoints = parsed; 
                        }
                    } catch (e) {}

                    const codeLines = text.split('\n').filter(l => /^[N]?\d*\s*[GM]\d+/.test(l.trim()));
                    if (codeLines.length > 3) {
                         const codeBlockMatch = text.match(/```(?:gcode|nc)?([\s\S]*?)```/i);
                         if (codeBlockMatch) {
                             suggestedCode = codeBlockMatch[1].trim();
                         } else {
                             suggestedCode = codeLines.join('\n');
                         }
                    }

                    setMessages(prev => [...prev, { role: 'model', text: text, suggestedPoints, suggestedStock, suggestedParams, suggestedCode }]);

                } catch (error) {
                    console.error("AI Error:", error);
                    let errMsg = "Chyba p≈ôi komunikaci s AI: " + error.message;
                    
                    // Detekce probl√©m≈Ø s kl√≠ƒçem (403 Permission Denied / Referer blocked)
                    if (error.message.includes("403") || error.message.includes("referer") || error.message.includes("blocked") || error.message.includes("API_KEY")) {
                         errMsg = "‚ö†Ô∏è P≈ô√≠stup k AI byl zam√≠tnut (Error 403). V√Ωchoz√≠ API kl√≠ƒç nefunguje ve va≈°em prost≈ôed√≠ (pravdƒõpodobnƒõ kv≈Øli omezen√≠ dom√©ny). Pros√≠m zadejte sv≈Øj vlastn√≠ Google Gemini API kl√≠ƒç v panelu naho≈ôe.";
                         setShowApiKeyInput(true);
                    }
                    
                    setMessages(prev => [...prev, { role: 'model', text: errMsg }]);
                }
                setLoading(false);
            };

            const quickActions = [
                "Srazit v≈°echny hrany 1mm",
                "Zaoblit rohy R2",
                "Zmƒõnit na hlin√≠k (vysok√© ot√°ƒçky)",
                "Optimalizovat hrubov√°n√≠",
                "P≈ôidat dokonƒçovac√≠ p≈ô√≠davek 0.2mm"
            ];

            return (
                <div className="flex flex-col h-full relative">
                    
                    {/* API Key Panel - SPLIT INPUT */}
                    {showApiKeyInput && (
                        <div className={`p-4 border-b ${theme === 'dark' ? 'bg-gray-800 border-gray-700' : 'bg-gray-100 border-gray-200'}`}>
                            <label className="block text-xs font-bold mb-1 opacity-70">V√°≈° Google API Kl√≠ƒç</label>
                            <div className="flex gap-2 items-center">
                                {/* Prefix (Read-only) */}
                                <div className="flex flex-1 gap-0">
                                    <div className={`px-3 py-1 text-sm border border-r-0 rounded-l flex items-center select-none font-mono ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-gray-400' : 'bg-gray-200 border-gray-300 text-gray-600'}`}>
                                        AIza
                                    </div>
                                    <input 
                                        type="password" 
                                        value={apiKeySuffix} 
                                        onChange={(e) => setApiKeySuffix(e.target.value)} 
                                        placeholder="SyCLBHN-IxCT..." 
                                        className={`flex-1 border rounded-r px-2 py-1 text-sm focus:outline-none focus:ring-1 focus:ring-blue-500 font-mono ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300'}`}
                                    />
                                </div>
                                <button onClick={() => handleSaveApiKey()} className="bg-green-600 hover:bg-green-500 text-white px-3 py-1 rounded text-xs font-bold">Ulo≈æit</button>
                            </div>
                            <p className="text-[10px] mt-1 opacity-60">Zadejte pouze chybƒõj√≠c√≠ ƒç√°st kl√≠ƒçe (za "AIza"). Ulo≈æeno bezpeƒçnƒõ ve va≈°em prohl√≠≈æeƒçi.</p>
                            
                            {/* API KEY HISTORY LIST */}
                            {keyHistory.length > 0 && (
                                <div className="mt-3 border-t pt-2 dark:border-gray-700">
                                    <div className="text-[10px] uppercase font-bold opacity-50 mb-1">Historie kl√≠ƒç≈Ø (posledn√≠ch 5)</div>
                                    <div className="space-y-1">
                                        {keyHistory.map((k, i) => (
                                            <div key={i} className={`flex items-center justify-between p-1.5 rounded border text-xs ${theme === 'dark' ? 'bg-gray-700/50 border-gray-600' : 'bg-gray-50 border-gray-300'}`}>
                                                <span className="font-mono truncate max-w-[200px] opacity-70">...{k.slice(-10)}</span>
                                                <div className="flex gap-1">
                                                    <button 
                                                        onClick={() => { setApiKeySuffix(k); handleSaveApiKey(k); }} 
                                                        className={`px-2 py-0.5 rounded text-[10px] font-bold ${theme === 'dark' ? 'bg-blue-700 text-white hover:bg-blue-600' : 'bg-blue-100 text-blue-700 hover:bg-blue-200'}`}
                                                    >
                                                        Naƒç√≠st
                                                    </button>
                                                    <button 
                                                        onClick={() => deleteFromHistory(k)} 
                                                        className="px-2 py-0.5 rounded text-[10px] bg-red-100 text-red-600 hover:bg-red-200 dark:bg-red-900/30 dark:text-red-400"
                                                    >
                                                        Smazat
                                                    </button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    <div ref={scrollRef} className={`flex-1 overflow-y-auto p-4 space-y-4 ${theme === 'dark' ? 'bg-gray-800' : 'bg-gray-50'}`}>
                        {messages.map((msg, idx) => (
                            <div key={idx} className={`flex flex-col ${msg.role === 'user' ? 'items-end' : 'items-start'}`}>
                                <div className={`max-w-[85%] rounded-lg p-3 text-sm whitespace-pre-wrap ${
                                    msg.role === 'user' 
                                        ? (theme === 'dark' ? 'bg-blue-700 text-white' : 'bg-blue-600 text-white')
                                        : (theme === 'dark' ? 'bg-gray-700 text-gray-200' : 'bg-white border text-gray-800 shadow-sm')
                                }`}>
                                    {msg.image && (
                                        <div className="mb-2">
                                            <img src={msg.image} alt="Upload" className="max-w-full h-auto rounded border" style={{maxHeight: '150px'}} />
                                        </div>
                                    )}
                                    {msg.text}
                                </div>
                                {msg.suggestedPoints && (
                                    <button onClick={() => onUpdateContour(msg.suggestedPoints)} className="mt-2 text-xs bg-green-600 hover:bg-green-500 text-white py-1.5 px-3 rounded flex items-center gap-1 shadow-sm"><IconPlusCircle /> Aplikovat body kontury</button>
                                )}
                                {msg.suggestedStock && (
                                    <button onClick={() => onUpdateStock(msg.suggestedStock)} className="mt-2 text-xs bg-green-600 hover:bg-green-500 text-white py-1.5 px-3 rounded flex items-center gap-1 shadow-sm"><IconBox /> Aplikovat polotovar</button>
                                )}
                                {msg.suggestedParams && (
                                    <button onClick={() => onUpdateParams(msg.suggestedParams)} className="mt-2 text-xs bg-orange-600 hover:bg-orange-500 text-white py-1.5 px-3 rounded flex items-center gap-1 shadow-sm"><IconEdit /> Aktualizovat parametry</button>
                                )}
                                {msg.suggestedCode && (
                                    <button onClick={() => onUpdateGCode(msg.suggestedCode)} className="mt-2 text-xs bg-purple-600 hover:bg-purple-500 text-white py-1.5 px-3 rounded flex items-center gap-1 shadow-sm"><IconTerminal /> Pou≈æ√≠t tento G-K√≥d</button>
                                )}
                            </div>
                        ))}
                        {loading && (
                            <div className="flex items-start">
                                <div className={`max-w-[85%] rounded-lg p-3 text-sm ${theme === 'dark' ? 'bg-gray-700' : 'bg-white border shadow-sm'}`}>
                                    <div className="flex gap-1">
                                        <span className="animate-bounce">‚óè</span>
                                        <span className="animate-bounce delay-100">‚óè</span>
                                        <span className="animate-bounce delay-200">‚óè</span>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                    
                    {/* Saved Prompts Panel (LIBRARY) */}
                    {showPrompts && (
                        <div className={`absolute bottom-[80px] left-2 right-2 rounded-lg shadow-xl border z-20 max-h-80 overflow-y-auto ${theme === 'dark' ? 'bg-gray-800 border-gray-600' : 'bg-white border-gray-300'}`}>
                            <div className={`p-2 border-b flex justify-between items-center ${theme === 'dark' ? 'border-gray-700 bg-gray-900' : 'border-gray-200 bg-gray-100'}`}>
                                <span className="text-xs font-bold px-2">Knihovna prompt≈Ø</span>
                                <div className="flex gap-2">
                                     <button onClick={handleExportPrompts} title="Exportovat do .txt" className="p-1 hover:bg-gray-200 dark:hover:bg-gray-700 rounded text-blue-600"><IconDownload /></button>
                                     <button onClick={() => importPromptsInputRef.current?.click()} title="Importovat z .txt" className="p-1 hover:bg-gray-200 dark:hover:bg-gray-700 rounded text-green-600"><IconUpload /></button>
                                     <button onClick={() => setShowPrompts(false)} className="p-1 hover:bg-gray-200 dark:hover:bg-gray-700 rounded"><IconX /></button>
                                </div>
                                <input type="file" ref={importPromptsInputRef} onChange={handleImportPrompts} className="hidden" accept=".txt,.json" />
                            </div>
                            
                            {/* Pre-set Quick Actions */}
                            <div className={`p-2 border-b ${theme === 'dark' ? 'border-gray-700' : 'border-gray-100'}`}>
                                <div className="text-[10px] font-bold opacity-50 mb-2 uppercase px-1">P≈ôednastaven√© akce</div>
                                <div className="flex flex-wrap gap-2">
                                    {quickActions.map((action, i) => (
                                        <button 
                                            key={i}
                                            onClick={() => handleQuickAction(action)}
                                            className={`text-[10px] whitespace-nowrap px-2 py-1 rounded-full border transition-colors ${
                                                theme === 'dark' 
                                                ? 'bg-gray-700 border-gray-600 text-gray-300 hover:bg-gray-600' 
                                                : 'bg-blue-50 border-blue-100 text-blue-600 hover:bg-blue-100'
                                            }`}
                                        >
                                            {action}
                                        </button>
                                    ))}
                                </div>
                            </div>

                            {/* User Saved Prompts */}
                            <div className="p-2 space-y-2">
                                <div className="text-[10px] font-bold opacity-50 mb-1 uppercase px-1">Va≈°e prompty</div>
                                {savedPrompts.length === 0 ? (
                                    <div className="text-xs text-gray-500 text-center p-4">≈Ω√°dn√© ulo≈æen√© prompty.</div>
                                ) : (
                                    savedPrompts.map(p => (
                                        <div key={p.id} className={`p-2 rounded border flex justify-between gap-2 items-start ${theme === 'dark' ? 'bg-gray-700 border-gray-600' : 'bg-gray-50 border-gray-200'}`}>
                                            <div 
                                                className="text-xs flex-1 cursor-pointer hover:underline line-clamp-2"
                                                onClick={() => handleLoadPrompt(p.text)}
                                            >
                                                {p.text}
                                            </div>
                                            <button onClick={() => handleDeletePrompt(p.id)} className="text-red-500 hover:text-red-700"><IconTrash /></button>
                                        </div>
                                    ))
                                )}
                            </div>
                        </div>
                    )}
                    
                    <div className={`p-3 border-t flex flex-col gap-2 ${theme === 'dark' ? 'bg-gray-900 border-gray-700' : 'bg-white border-gray-200'}`}>
                        <div className="flex items-center gap-2">
                            <input type="file" accept="image/*" ref={fileInputRef} onChange={handleFileChange} className="hidden" />
                            <button onClick={() => fileInputRef.current?.click()} className={`p-1.5 rounded transition-colors ${image ? 'bg-blue-100 text-blue-600' : 'text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800 dark:text-gray-400'}`} title="Nahr√°t obr√°zek"><IconDocumentScanner /></button>
                            <div className="h-4 w-px bg-gray-300 dark:bg-gray-700 mx-1"></div>
                            
                            {/* API Key Toggle Button */}
                            <button onClick={() => setShowApiKeyInput(!showApiKeyInput)} className={`flex items-center gap-1 px-2 py-1 rounded text-xs font-bold transition-colors ${showApiKeyInput ? 'bg-blue-100 text-blue-700' : 'text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800'}`} title="Nastavit API Kl√≠ƒç">
                                <IconKey />
                            </button>
                            
                            {/* Reset History Button */}
                            <button onClick={clearHistory} className="flex items-center gap-1 px-2 py-1 rounded text-xs font-bold transition-colors text-red-500 hover:bg-red-100 dark:hover:bg-red-900/30" title="Vymazat historii">
                                <IconTrash />
                            </button>

                            <button onClick={() => setMode(mode === 'fast' ? 'normal' : 'fast')} className={`flex items-center gap-1 px-2 py-1 rounded text-xs font-bold transition-colors ${mode === 'fast' ? 'bg-yellow-100 text-yellow-700 border border-yellow-200' : 'text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800'}`} title="Rychl√° odpovƒõƒè"><IconBolt /> {mode === 'fast' && 'Fast'}</button>
                            <button onClick={() => setMode(mode === 'thinking' ? 'normal' : 'thinking')} className={`flex items-center gap-1 px-2 py-1 rounded text-xs font-bold transition-colors ${mode === 'thinking' ? 'bg-purple-100 text-purple-700 border border-purple-200' : 'text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800'}`} title="Thinking Mode"><IconNetworkIntelligence /> {mode === 'thinking' && 'Thinking'}</button>
                            <div className="flex-1"></div>
                            <button onClick={() => setShowPrompts(!showPrompts)} className={`flex items-center gap-1 px-2 py-1 rounded text-xs font-bold transition-colors ${showPrompts ? 'bg-blue-100 text-blue-700 border border-blue-200' : 'text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800'}`} title="Knihovna prompt≈Ø"><IconBookmark /> Knihovna</button>
                        </div>

                        {image && (
                            <div className="relative inline-block w-fit">
                                <img src={image} alt="Preview" className="h-16 rounded border shadow-sm" />
                                <button onClick={removeImage} className="absolute -top-1 -right-1 bg-red-500 text-white rounded-full p-0.5 shadow hover:bg-red-600"><IconX /></button>
                            </div>
                        )}

                        <div className="flex gap-2">
                            <textarea value={input} onChange={(e) => setInput(e.target.value)} onKeyDown={(e) => { if(e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); } }} placeholder={image ? "Popi≈°te tento v√Ωkres..." : "Zeptejte se na G-k√≥d..."} className={`flex-1 border rounded-lg p-2 text-sm resize-none h-12 focus:outline-none focus:ring-2 focus:ring-blue-500 ${theme === 'dark' ? 'bg-gray-800 border-gray-600 text-white' : 'bg-gray-50 border-gray-300 text-gray-900'}`} />
                            <div className="flex flex-col gap-1">
                                <button 
                                    onClick={handleSavePrompt} 
                                    disabled={!input.trim()} 
                                    className={`h-6 px-2 rounded font-bold flex items-center justify-center transition-colors ${!input.trim() ? 'bg-gray-300 text-gray-500' : 'bg-green-600 hover:bg-green-500 text-white'}`} 
                                    title="Ulo≈æit prompt"
                                >
                                    <IconSave />
                                </button>
                                <button 
                                    onClick={toggleListening}
                                    className={`h-6 px-2 rounded font-bold flex items-center justify-center transition-all ${isListening ? 'mic-active' : (theme === 'dark' ? 'bg-gray-700 text-gray-400' : 'bg-gray-200 text-gray-500')}`}
                                    title="Hlasov√© zad√°v√°n√≠"
                                >
                                    <IconMicrophone />
                                </button>
                                <button onClick={handleSend} disabled={loading || (!input.trim() && !image)} className={`h-6 px-4 rounded font-bold flex items-center justify-center transition-colors ${loading || (!input.trim() && !image) ? 'bg-gray-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-500 text-white'}`}><IconSpark /></button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- MATH HELPERS ---
        const dist = (p1, p2) => {
            if(!p1 || !p2) return 0;
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2));
        }

        const getNormal = (p1, p2) => {
            if (!p1 || !p2) return {x:0, z:0};
            const dx = p2.x - p1.x; const dz = p2.z - p1.z; const l = Math.sqrt(dx*dx + dz*dz);
            if (l===0 || isNaN(l)) return {x:0, z:0}; return { x: -dz/l, z: dx/l };
        };

        const intersectLines = (p1, p2, p3, p4) => {
            if (!p1 || !p2 || !p3 || !p4) return null;
            if (isNaN(p1.x) || isNaN(p1.z) || isNaN(p2.x) || isNaN(p2.z) || 
                isNaN(p3.x) || isNaN(p3.z) || isNaN(p4.x) || isNaN(p4.z)) return null;

            const d = (p1.x - p2.x) * (p3.z - p4.z) - (p1.z - p2.z) * (p3.x - p4.x);
            if (Math.abs(d) < 1e-9 || isNaN(d)) return null; 
            const t = ((p1.x - p3.x) * (p3.z - p4.z) - (p1.z - p3.z) * (p3.x - p4.x)) / d;
            
            const ix = p1.x + t * (p2.x - p1.x);
            const iz = p1.z + t * (p2.z - p1.z);
            if (isNaN(ix) || isNaN(iz)) return null;
            return { x: ix, z: iz };
        };

        const intersectLinesInfinite = (p1, p2, p3, p4) => {
            if (!p1 || !p2 || !p3 || !p4) return null;
            if (isNaN(p1.x) || isNaN(p1.z) || isNaN(p2.x) || isNaN(p2.z) || 
                isNaN(p3.x) || isNaN(p3.z) || isNaN(p4.x) || isNaN(p4.z)) return null;

            const d = (p1.x - p2.x) * (p3.z - p4.z) - (p1.z - p2.z) * (p3.x - p4.x);
            if (Math.abs(d) < 1e-9 || isNaN(d)) return null; 
            const t = ((p1.x - p3.x) * (p3.z - p4.z) - (p1.z - p3.z) * (p3.x - p4.x)) / d;
            const px = p1.x + t * (p2.x - p1.x);
            const pz = p1.z + t * (p2.z - p1.z);
            if(isNaN(px) || isNaN(pz)) return null;
            return { x: px, z: pz };
        };

        const intersectLineCircle = (p1, p2, center, r) => {
            if (!p1 || !p2 || !center) return null;
            const dx = p2.x - p1.x; const dz = p2.z - p1.z; const fx = p1.x - center.x; const fz = p1.z - center.z;
            const a = dx*dx + dz*dz; const b = 2*(fx*dx + fz*dz); const c = (fx*fx + fz*fz) - r*r;
            let discriminant = b*b - 4*a*c; if (discriminant < 0) return null;
            discriminant = Math.sqrt(discriminant);
            const t1 = (-b - discriminant) / (2*a); const t2 = (-b + discriminant) / (2*a);
            return [{ x: p1.x + t1*dx, z: p1.z + t1*dz }, { x: p1.x + t2*dx, z: p1.z + t2*dz }];
        };

        const getArcParams = (p1, p2, r, type) => {
            if (!p1 || !p2) return { error: true, cx: 0, cz: 0, r: 0 };
            const d2 = Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2); const d = Math.sqrt(d2);
            const isLongArc = r < 0; const absR = Math.abs(r); let safeR = absR; let error = false;
            if (d2 === 0) return { error: true, cx: p1.x, cz: p1.z, r: 0 };
            if (absR < d/2 - 0.001) { error = true; safeR = d/2 + 0.001; }
            const mx = (p1.x + p2.x) / 2; const mz = (p1.z + p2.z) / 2;
            const h = Math.sqrt(Math.max(0, safeR*safeR - d2/4));
            const dx = p2.x - p1.x; const dz = p2.z - p1.z;
            const ox = -dz / d; const oz = dx / d;
            let sign = (type === 'G3') ? -1 : 1; if (isLongArc) sign *= -1;
            const cx = mx + sign * h * ox; const cz = mz + sign * h * oz;
            if(isNaN(cx) || isNaN(cz)) return { error: true, cx: 0, cz: 0, r: 0 };
            return { cx, cz, r: safeR, error };
        };

        const isAngleBetween = (target, start, end, isG2) => {
            if (isNaN(target) || isNaN(start) || isNaN(end)) return false;
            const t = (target % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            const s = (start % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            const e = (end % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            if (isG2) { if (s >= e) return t <= s && t >= e; return t <= s || t >= e; } else { if (e >= s) return t >= s && t <= e; return t >= s || t <= e; }
        };

        const intersectHorizontalLineSegment = (xLine, p1, p2) => {
            if (!p1 || !p2) return null;
            const minX = Math.min(p1.x, p2.x); const maxX = Math.max(p1.x, p2.x);
            if (xLine < minX || xLine > maxX) return null; if (Math.abs(p2.x - p1.x) < 1e-6) return null;
            const t = (xLine - p1.x) / (p2.x - p1.x); return p1.z + t * (p2.z - p1.z);
        };
        const intersectHorizontalLineArc = (xLine, center, radius) => {
            if (!center) return [];
            const term = radius*radius - Math.pow(xLine - center.x, 2); if (term < 0) return [];
            const sqrtTerm = Math.sqrt(term); return [center.z - sqrtTerm, center.z + sqrtTerm];
        };
        const intersectVerticalLineSegment = (zLine, p1, p2) => {
            if (!p1 || !p2) return null;
            const minZ = Math.min(p1.z, p2.z); const maxZ = Math.max(p1.z, p2.z);
            if (zLine < minZ || zLine > maxZ) return null; if (Math.abs(p2.z - p1.z) < 1e-6) return null;
            const t = (zLine - p1.z) / (p2.z - p1.z); return p1.x + t * (p2.x - p1.x);
        };
        const intersectVerticalLineArc = (zLine, center, radius) => {
            if (!center) return [];
            const term = radius*radius - Math.pow(zLine - center.z, 2); if (term < 0) return [];
            const sqrtTerm = Math.sqrt(term); return [center.x - sqrtTerm, center.x + sqrtTerm];
        };

        // --- APP ---
        const App = () => {
            const [theme, setTheme] = useState('light');
            const [editMode, setEditMode] = useState('contour'); 
            const [mobileTab, setMobileTab] = useState('editor'); 
            const [copyFeedback, setCopyFeedback] = useState(false);
            
            const [simRunning, setSimRunning] = useState(false);
            const [simProgress, setSimProgress] = useState(0); 
            
            const [isLoaded, setIsLoaded] = useState(false);

            // DRAG & DROP & INSERT STATE
            const [draggedPointId, setDraggedPointId] = useState(null);
            const [hoverPointId, setHoverPointId] = useState(null);
            const [addPointMode, setAddPointMode] = useState(false); 

            // UNDO / REDO STATE
            const [past, setPast] = useState([]);
            const [future, setFuture] = useState([]);

            // MANUAL CODE OVERRIDE STATE
            const [useManualCode, setUseManualCode] = useState(false);
            const [manualGCode, setManualGCode] = useState('');

            const [params, setParams] = useState({
                machineType: 'LIMS=2000',
                mode: 'DIAMON',
                toolName: 'ROUGHER_T1',
                speed: 200,
                feed: 0.25,
                depthOfCut: 2.0,
                retractDistance: 2.0,
                allowanceX: 0.5,
                allowanceZ: 0.1,
                toolRadius: 0.8,
                doFinishing: true, 
                roughingStrategy: 'longitudinal',
                stockMode: 'cylinder', 
                stockMargin: 5.0, 
                stockDiameter: 100, 
                stockLength: 100,
                stockFace: 2.0,
                safeX: 150,
                safeZ: 5,
                machineStructure: 'lathe', 
                controlSystem: 'sinumerik',
                toolShape: 'round', // 'round' | 'polygon'
                toolLength: 10,
                toolAngle: 15, // 15 deg default
                toolTipAngle: 90 // Default 90 (Square)
            });

            const [contourPoints, setContourPoints] = useState([
                { id: 1, type: 'G0', x: 0, z: 0, r: 0, mode: 'ABS' },
                { id: 2, type: 'G1', x: 20, z: 0, r: 0, mode: 'ABS' },     
                { id: 3, type: 'G1', x: 20, z: -15, r: 0, mode: 'ABS' },   
                { id: 4, type: 'G1', x: 30, z: -15, r: 0, mode: 'ABS' },   
                { id: 5, type: 'G1', x: 35, z: -25, r: 0, mode: 'ABS' },   
                { id: 6, type: 'G1', x: 35, z: -40, r: 0, mode: 'ABS' },   
                { id: 7, type: 'G2', x: 55, z: -50, r: 10, mode: 'ABS' },  
                { id: 8, type: 'G1', x: 55, z: -55, r: 0, mode: 'ABS' }, 
                { id: 81, type: 'G1', x: 45, z: -55, r: 0, mode: 'ABS' }, 
                { id: 82, type: 'G1', x: 45, z: -60, r: 0, mode: 'ABS' }, 
                { id: 83, type: 'G1', x: 55, z: -60, r: 0, mode: 'ABS' }, 
                { id: 9, type: 'G1', x: 55, z: -65, r: 0, mode: 'ABS' }, 
                { id: 10, type: 'G3', x: 65, z: -75, r: 12, mode: 'ABS' },  
                { id: 11, type: 'G1', x: 80, z: -100, r: 0, mode: 'ABS' }  
            ]);

            const [stockPoints, setStockPoints] = useState([
                { id: 101, type: 'G0', x: 85, z: 2, r: 0, mode: 'ABS' },
                { id: 102, type: 'G1', x: 85, z: -105, r: 0, mode: 'ABS' },
                { id: 103, type: 'G1', x: 0, z: -105, r: 0, mode: 'ABS' }
            ]);
            
            const [errors, setErrors] = useState([]);
            const [gCodeInput, setGCodeInput] = useState('');
            const [generatedCode, setGeneratedCode] = useState([]);
            const [activeTab, setActiveTab] = useState('editor');
            
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const codeContainerRef = useRef(null);
            const [view, setView] = useState({ scale: 3, panX: 600, panY: 350 });
            const [isDragging, setIsDragging] = useState(false);
            const lastMousePos = useRef({ x: 0, y: 0 });
            const lastPinchDist = useRef(null);
            
            // --- HISTORY LOGIC ---
            const pushHistory = useCallback(() => {
                setPast(prev => [...prev, { 
                    contour: JSON.parse(JSON.stringify(contourPoints)), 
                    stock: JSON.parse(JSON.stringify(stockPoints)) 
                }]);
                setFuture([]);
            }, [contourPoints, stockPoints]);

            const undo = () => {
                if (past.length === 0) return;
                const previous = past[past.length - 1];
                const newPast = past.slice(0, -1);
                
                setFuture(prev => [{ 
                    contour: JSON.parse(JSON.stringify(contourPoints)), 
                    stock: JSON.parse(JSON.stringify(stockPoints)) 
                }, ...prev]);
                
                setContourPoints(previous.contour);
                setStockPoints(previous.stock);
                setPast(newPast);
            };

            const redo = () => {
                if (future.length === 0) return;
                const next = future[0];
                const newFuture = future.slice(1);
                
                setPast(prev => [...prev, { 
                    contour: JSON.parse(JSON.stringify(contourPoints)), 
                    stock: JSON.parse(JSON.stringify(stockPoints)) 
                }]);
                
                setContourPoints(next.contour);
                setStockPoints(next.stock);
                setFuture(newFuture);
            };

            // --- LOCAL STORAGE LOGIC ---
            const STORAGE_KEY = 'sinumerik_cam_save_v1';

            useEffect(() => {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        if (parsed.params) setParams(prev => ({...prev, ...parsed.params}));
                        if (parsed.contourPoints && parsed.contourPoints.length > 0) setContourPoints(parsed.contourPoints);
                        if (parsed.stockPoints && parsed.stockPoints.length > 0) setStockPoints(parsed.stockPoints);
                        if (parsed.theme) setTheme(parsed.theme);
                        if (parsed.manualGCode) setManualGCode(parsed.manualGCode);
                        if (parsed.useManualCode !== undefined) setUseManualCode(parsed.useManualCode);
                    } catch (e) {
                        console.error("Failed to load local storage:", e);
                    }
                }
                setIsLoaded(true);
            }, []);

            useEffect(() => {
                if (!isLoaded) return;
                const dataToSave = { params, contourPoints, stockPoints, theme, manualGCode, useManualCode };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
            }, [isLoaded, params, contourPoints, stockPoints, theme, manualGCode, useManualCode]);

            const handleResetApp = () => {
                if(confirm("Opravdu chcete vymazat ve≈°kerou ulo≈æenou pr√°ci a resetovat aplikaci?")) {
                    localStorage.removeItem(STORAGE_KEY);
                    window.location.reload();
                }
            };
            
            // --- PDF EXPORT LOGIC ---
            const handleExportPDF = () => {
                 if (!window.jspdf) {
                     alert("Knihovna pro PDF se je≈°tƒõ naƒç√≠t√°, zkuste to za chv√≠li.");
                     return;
                 }

                 const { jsPDF } = window.jspdf;
                 const doc = new jsPDF();
                 const noAccents = (str) => str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");

                 // 1. Header
                 doc.setFontSize(20);
                 doc.text(noAccents("Technologicky list - CAM"), 15, 20);
                 
                 doc.setFontSize(10);
                 doc.text(`Datum: ${new Date().toLocaleDateString()}`, 15, 30);
                 doc.text(noAccents(`System: ${params.controlSystem.toUpperCase()}`), 15, 35);
                 
                 // 2. Parameters
                 doc.setFontSize(12);
                 doc.text(noAccents("Parametry obrabeni:"), 15, 50);
                 doc.setFontSize(10);
                 let y = 60;
                 const addParam = (label, val) => {
                     doc.text(noAccents(`${label}: ${val}`), 20, y);
                     y += 6;
                 };
                 
                 addParam("Stroj", params.machineType);
                 addParam("Nastroj", params.toolName);
                 addParam("Rezna rychlost", params.speed + " m/min");
                 addParam("Posuv", params.feed + " mm/ot");
                 addParam("Hloubka trisky", params.depthOfCut + " mm");
                 
                 // 3. Image
                 if (canvasRef.current) {
                     const imgData = canvasRef.current.toDataURL("image/png");
                     // A4 width is 210. Margins 15. Width available 180.
                     const imgProps = doc.getImageProperties(imgData);
                     const pdfWidth = 100;
                     const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
                     
                     doc.text(noAccents("Nahled drahy:"), 100, 50);
                     doc.addImage(imgData, 'PNG', 100, 55, pdfWidth, pdfHeight);
                 }
                 
                 // 4. G-Code
                 y = 120; 
                 doc.setFontSize(12);
                 doc.text("G-Code:", 15, y);
                 y += 10;
                 doc.setFont("courier", "normal");
                 doc.setFontSize(9);
                 
                 generatedCode.forEach(lineObj => {
                     if (y > 280) {
                         doc.addPage();
                         y = 20;
                     }
                     doc.text(noAccents(lineObj.text), 15, y);
                     y += 5;
                 });
                 
                 doc.save("CAM_Export.pdf");
            };

            useEffect(() => {
                document.body.className = `h-[100dvh] w-screen overflow-hidden flex flex-col font-sans transition-colors duration-300 ${theme === 'dark' ? 'bg-gray-900 text-gray-100' : 'bg-gray-50 text-gray-900'}`;
            }, [theme]);

            const fitView = useCallback(() => {
                if (!containerRef.current) return;
                const points = resolvePointsToAbsolute(contourPoints);
                if (points.length === 0) return;
                let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
                points.forEach(p => {
                    const x = params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs;
                    const z = p.zAbs;
                    if(x < minX) minX = x; if(x > maxX) maxX = x;
                    if(z < minZ) minZ = z; if(z > maxZ) maxZ = z;
                });
                const pad = 20;
                
                const isCarousel = params.machineStructure === 'carousel';
                const visWidth = isCarousel ? (maxX - minX) : (maxZ - minZ);
                const visHeight = isCarousel ? (maxZ - minZ) : (maxX - minX);
                
                const width = visWidth + pad * 2;
                const height = visHeight + pad * 2;
                
                if (width <= 0 || height <= 0) return;
                const contW = containerRef.current.clientWidth;
                const contH = containerRef.current.clientHeight;
                if (contW === 0 || contH === 0) return;
                const scaleX = contW / width;
                const scaleY = contH / height;
                let newScale = Math.min(scaleX, scaleY) * 0.8; 
                if (newScale > 10) newScale = 10;
                if (newScale < 0.1) newScale = 0.1;
                
                const midZ = (minZ + maxZ) / 2;
                const midX = (minX + maxX) / 2;
                
                if (isCarousel) {
                    setView({ scale: newScale, panX: contW/2 - midX * newScale, panY: contH/2 + midZ * newScale });
                } else {
                    setView({ scale: newScale, panX: contW/2 - midZ * newScale, panY: contH/2 + midX * newScale });
                }
                
            }, [contourPoints, params.mode, params.machineStructure]);

            useEffect(() => { setTimeout(fitView, 100); }, [mobileTab, params.machineStructure]); 

            const resolvePointsToAbsolute = (pts) => {
                let lastX = 0; let lastZ = 0;
                return pts.map((p, index) => {
                    let valX = parseFloat(p.x); if(isNaN(valX)) valX = 0;
                    let valZ = parseFloat(p.z); if(isNaN(valZ)) valZ = 0;
                    let absX = valX; let absZ = valZ;
                    if (p.mode === 'INC') { absX = lastX + valX; absZ = lastZ + valZ; } else { absX = valX; absZ = valZ; }
                    lastX = absX; lastZ = absZ;
                    let rVal = parseFloat(p.r); if(isNaN(rVal)) rVal = 0;
                    return { ...p, xAbs: absX, zAbs: absZ, rVal };
                });
            };

            const handleAutoStock = () => {
                const absPts = resolvePointsToAbsolute(contourPoints);
                if (absPts.length === 0) return;
                let minZ = Infinity, maxZ = -Infinity;
                let maxD = 0;
                
                absPts.forEach(p => {
                    const x = params.mode === 'DIAMON' ? p.xAbs : p.xAbs * 2; 
                    if (Math.abs(x) > maxD) maxD = Math.abs(x);
                    if (p.zAbs < minZ) minZ = p.zAbs;
                    if (p.zAbs > maxZ) maxZ = p.zAbs;
                });
                
                const margin = parseFloat(params.stockMargin) || 5;
                const stockD = Math.ceil(maxD + margin*2); 
                const stockL = Math.ceil(Math.abs(minZ) + margin); 
                const stockF = 2.0;

                setParams(p => ({
                    ...p,
                    stockDiameter: stockD,
                    stockLength: stockL,
                    stockFace: stockF
                }));
            };

            const generateDefaultStock = () => {
                const absPts = resolvePointsToAbsolute(contourPoints);
                if (absPts.length === 0) return;
                let minZ = Infinity;
                let maxX = 0;
                
                absPts.forEach(p => {
                    const x = params.mode === 'DIAMON' ? p.xAbs/2 : p.xAbs;
                    if (Math.abs(x) > maxX) maxX = Math.abs(x);
                    if (p.zAbs < minZ) minZ = p.zAbs;
                });
                
                const sR = maxX + 5;
                const sL = minZ - 5;
                
                const newStock = [
                     { id: Date.now(), type: 'G0', x: sR, z: 2, r: 0, mode: 'ABS' },
                     { id: Date.now()+1, type: 'G1', x: sR, z: sL, r: 0, mode: 'ABS' },
                     { id: Date.now()+2, type: 'G1', x: 0, z: sL, r: 0, mode: 'ABS' }
                ];
                setStockPoints(newStock);
            };

            // NEW: MANUAL G-CODE PARSER FOR SIMULATION
            const parseManualGCodeToPath = (code, currentParams) => {
                const lines = code.split('\n');
                const path = [];
                // Initialize with safe position
                let currentX = parseFloat(currentParams.safeX) / 2; // Radius
                let currentZ = parseFloat(currentParams.safeZ);
                
                // Track modal states
                let lastMoveType = 'G0'; // Default G0

                // Add start point
                path.push({ x: currentX, z: currentZ, type: 'G0' });

                lines.forEach((line, idx) => {
                    const clean = line.toUpperCase().trim();
                    if (!clean || clean.startsWith(';') || clean.startsWith('(') || clean.startsWith('%')) {
                         // Map non-move lines to the last known position to keep indices synced
                         // But we won't add them to the path array to avoid drawing clutter, 
                         // we will just handle index mapping in the drawing loop or separate map.
                         // For simplicity here, we just ignore drawing them.
                         return;
                    }
                    
                    // Basic parsing
                    const gMatch = clean.match(/G([0-3])/);
                    const type = gMatch ? 'G' + gMatch[1] : lastMoveType; // Use last modal G code
                    
                    const xMatch = clean.match(/[XU]([-]?\d*\.?\d+)/);
                    const zMatch = clean.match(/[ZW]([-]?\d*\.?\d+)/);
                    const rMatch = clean.match(/(?:R|CR=)([-]?\d*\.?\d+)/);
                    
                    let targetX = currentX;
                    let targetZ = currentZ;
                    let hasMove = false;

                    if (xMatch) {
                        const val = parseFloat(xMatch[1]);
                        targetX = currentParams.mode === 'DIAMON' ? val / 2 : val;
                        hasMove = true;
                    }
                    if (zMatch) {
                        targetZ = parseFloat(zMatch[1]);
                        hasMove = true;
                    }
                    
                    // Only update modal state if explicit G code was present
                    if (gMatch) lastMoveType = type;

                    if (hasMove) {
                        if (type === 'G0' || type === 'G1') {
                            path.push({ x: targetX, z: targetZ, type: type, originalLineIdx: idx });
                            currentX = targetX;
                            currentZ = targetZ;
                        } else if (type === 'G2' || type === 'G3') {
                            if (rMatch) {
                                 const r = parseFloat(rMatch[1]);
                                 const p1 = { x: currentX, z: currentZ };
                                 const p2 = { x: targetX, z: targetZ };
                                 
                                 const arc = getArcParams(p1, p2, r, type);
                                 
                                 if (!arc.error) {
                                    const steps = 10;
                                    let sA = Math.atan2(p1.x - arc.cx, p1.z - arc.cz);
                                    let eA = Math.atan2(p2.x - arc.cx, p2.z - arc.cz);
                                    if (type === 'G2' && eA > sA) eA -= 2*Math.PI;
                                    if (type === 'G3' && eA < sA) eA += 2*Math.PI;

                                    for(let j=1; j<=steps; j++) {
                                         const a = sA + (eA - sA) * (j/steps);
                                         path.push({
                                             x: arc.cx + Math.sin(a)*arc.r,
                                             z: arc.cz + Math.cos(a)*arc.r,
                                             type: type,
                                             originalLineIdx: idx
                                         });
                                    }
                                 } else {
                                     path.push({ x: targetX, z: targetZ, type: type, originalLineIdx: idx });
                                 }
                            } else {
                                 path.push({ x: targetX, z: targetZ, type: type, originalLineIdx: idx });
                            }
                            currentX = targetX;
                            currentZ = targetZ;
                        }
                    } else if (gMatch) {
                        // G code change without move (e.g. G1 F0.2)
                         path.push({ x: currentX, z: currentZ, type: type, originalLineIdx: idx });
                    }
                });
                return path;
            };

            const calculatedData = useMemo(() => {
                const absContour = resolvePointsToAbsolute(contourPoints);
                const absStock = resolvePointsToAbsolute(stockPoints);
                const worldPoints = absContour.map(p => ({ ...p, xReal: params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs, zReal: p.zAbs }));
                const stockWorldPoints = absStock.map(p => ({ ...p, xReal: params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs, zReal: p.zAbs }));

                const tipR = parseFloat(params.toolRadius) || 0;
                const allowanceX = parseFloat(params.allowanceX) || 0;
                const allowanceZ = parseFloat(params.allowanceZ) || 0;
                const totalOffset = tipR + Math.max(allowanceX, allowanceZ);
                const retractDist = parseFloat(params.retractDistance) || 2.0; 
                
                let contourSegments = [];
                let rawOffsets = []; 
                let finishOffsetPath = [];
                let stockPathSegments = []; 
                const foundErrors = [];

                for (let i = 0; i < worldPoints.length - 1; i++) {
                    const p1 = worldPoints[i]; const p2 = worldPoints[i+1]; const type = p2.type;
                    if (type === 'G0' || type === 'G1') {
                        contourSegments.push({ type: 'line', p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal}, orig: p2 });
                    } else if (type === 'G2' || type === 'G3') {
                        const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, type);
                        if (arc.error) foundErrors.push(`≈ò√°dek ${i+2}: R√°dius R${p2.r} je p≈ô√≠li≈° mal√Ω.`);
                        else if (arc.r < totalOffset) foundErrors.push(`KOLIZE (≈ò√°dek ${i+2}): R√°dius kontury men≈°√≠ ne≈æ n√°stroj.`);
                        contourSegments.push({ type: 'arc', ...arc, p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal}, dir: type });
                    }
                }
                for (let i = 0; i < stockWorldPoints.length - 1; i++) {
                    const p1 = stockWorldPoints[i]; const p2 = stockWorldPoints[i+1]; const type = p2.type;
                    if (type === 'G0' || type === 'G1') {
                        stockPathSegments.push({ type: 'line', p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal} });
                    } else if (type === 'G2' || type === 'G3') {
                        const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, type);
                        const startAngle = Math.atan2(p1.xReal - arc.cx, p1.zReal - arc.cz);
                        const endAngle = Math.atan2(p2.xReal - arc.cx, p2.zReal - arc.cz);
                        stockPathSegments.push({ type: 'arc', ...arc, dir: type, startAngle, endAngle });
                    }
                }

                let incompleteMachiningCount = 0;
                
                // 1. GENERATE RAW OFFSETS (Skipping impossible arcs)
                for (let i = 0; i < contourSegments.length; i++) {
                    const seg = contourSegments[i];
                    let offSeg = null;
                    if (seg.type === 'line') {
                        const n = getNormal(seg.p1, seg.p2);
                        offSeg = { type: 'line', p1: { x: seg.p1.x + n.x * totalOffset, z: seg.p1.z + n.z * totalOffset }, p2: { x: seg.p2.x + n.x * totalOffset, z: seg.p2.z + n.z * totalOffset } };
                    } else if (seg.type === 'arc') {
                        let rNew = (seg.dir === 'G3') ? seg.r + totalOffset : seg.r - totalOffset;
                        if (rNew <= 1.5) { 
                            incompleteMachiningCount++;
                            offSeg = null; 
                        } else {
                            const startAngle = Math.atan2(seg.p1.x - seg.cx, seg.p1.z - seg.cz);
                            const endAngle = Math.atan2(seg.p2.x - seg.cx, seg.p2.z - seg.cz);
                            offSeg = { type: 'arc', cx: seg.cx, cz: seg.cz, r: rNew, dir: seg.dir, refP1: seg.p1, refP2: seg.p2, startAngle, endAngle, dir: seg.dir };
                        }
                    }
                    if (offSeg) rawOffsets.push(offSeg);
                }
                
                // 2. LOCAL TRIMMING & CONNECTING
                let trimmedOffsetPath = [];
                if (rawOffsets.length > 0) {
                    trimmedOffsetPath.push(JSON.parse(JSON.stringify(rawOffsets[0])));
                    
                    for (let i = 0; i < rawOffsets.length - 1; i++) {
                        let prevOff = trimmedOffsetPath[trimmedOffsetPath.length - 1]; 
                        let nextOff = JSON.parse(JSON.stringify(rawOffsets[i+1])); 
                        
                        let intersection = null;
                        
                        if (prevOff.type === 'line' && nextOff.type === 'line') {
                            intersection = intersectLines(prevOff.p1, prevOff.p2, nextOff.p1, nextOff.p2);
                        } else if (prevOff.type === 'line' && nextOff.type === 'arc') {
                            const ints = intersectLineCircle(prevOff.p1, prevOff.p2, {x:nextOff.cx, z:nextOff.cz}, nextOff.r);
                            if (ints && ints.length > 0) {
                                const d1 = Math.hypot(ints[0].x - prevOff.p2.x, ints[0].z - prevOff.p2.z);
                                const d2 = Math.hypot(ints[1].x - prevOff.p2.x, ints[1].z - prevOff.p2.z);
                                intersection = d1 < d2 ? ints[0] : ints[1];
                            }
                        } else if (prevOff.type === 'arc' && nextOff.type === 'line') {
                            const ints = intersectLineCircle(nextOff.p1, nextOff.p2, {x:prevOff.cx, z:prevOff.cz}, prevOff.r);
                            if (ints && ints.length > 0) {
                                const d1 = Math.hypot(ints[0].x - nextOff.p1.x, ints[0].z - nextOff.p1.z);
                                const d2 = Math.hypot(ints[1].x - nextOff.p1.x, ints[1].z - nextOff.p1.z);
                                intersection = d1 < d2 ? ints[0] : ints[1];
                            }
                        }

                        if (intersection) {
                            if (prevOff.type === 'line') prevOff.p2 = intersection;
                            else prevOff.endAngle = Math.atan2(intersection.x - prevOff.cx, intersection.z - prevOff.cz);
                            if (nextOff.type === 'line') nextOff.p1 = intersection;
                            else nextOff.startAngle = Math.atan2(intersection.x - nextOff.cx, intersection.z - nextOff.cz);
                            trimmedOffsetPath.push(nextOff);
                        } else {
                            // Gap bridging logic
                            let corner = null;
                            if (prevOff.type === 'line' && nextOff.type === 'line') {
                                corner = intersectLinesInfinite(prevOff.p1, prevOff.p2, nextOff.p1, nextOff.p2);
                            }

                            if (corner) {
                                prevOff.p2 = corner;
                                nextOff.p1 = corner;
                            } else {
                                const pStart = (prevOff.type === 'line') ? prevOff.p2 : {x: prevOff.cx + Math.sin(prevOff.endAngle)*prevOff.r, z: prevOff.cz + Math.cos(prevOff.endAngle)*prevOff.r};
                                const pEnd = (nextOff.type === 'line') ? nextOff.p1 : {x: nextOff.cx + Math.sin(nextOff.startAngle)*nextOff.r, z: nextOff.cz + Math.cos(nextOff.startAngle)*nextOff.r};
                                trimmedOffsetPath.push({ type: 'line', p1: pStart, p2: {x: pEnd.x, z: pStart.z} }); 
                                if (Math.abs(pEnd.z - pStart.z) > 0.001) {
                                    trimmedOffsetPath.push({ type: 'line', p1: {x: pEnd.x, z: pStart.z}, p2: pEnd }); 
                                }
                            }
                            trimmedOffsetPath.push(nextOff);
                        }
                    }
                }
                
                // 3. GLOBAL LOOP REMOVAL
                if (trimmedOffsetPath.length > 2) {
                    let loopFound = true;
                    let iterations = 0;
                    while (loopFound && iterations < 5) { 
                        loopFound = false;
                        iterations++;
                        outerLoop:
                        for (let i = 0; i < trimmedOffsetPath.length - 2; i++) {
                            for (let j = i + 2; j < trimmedOffsetPath.length; j++) {
                                const s1 = trimmedOffsetPath[i];
                                const s2 = trimmedOffsetPath[j];
                                if (s1.isDegenerate || s2.isDegenerate) continue;
                                let intersection = null;
                                if (s1.type === 'line' && s2.type === 'line') {
                                    intersection = intersectLines(s1.p1, s1.p2, s2.p1, s2.p2);
                                    if (intersection) {
                                         const tol = 0.5;
                                         const minX1 = Math.min(s1.p1.x, s1.p2.x) - tol; const maxX1 = Math.max(s1.p1.x, s1.p2.x) + tol;
                                         const minZ1 = Math.min(s1.p1.z, s1.p2.z) - tol; const maxZ1 = Math.max(s1.p1.z, s1.p2.z) + tol;
                                         const minX2 = Math.min(s2.p1.x, s2.p2.x) - tol; const maxX2 = Math.max(s2.p1.x, s2.p2.x) + tol;
                                         const minZ2 = Math.min(s2.p1.z, s2.p2.z) - tol; const maxZ2 = Math.max(s2.p1.z, s2.p2.z) + tol;
                                         if (!(intersection.x >= minX1 && intersection.x <= maxX1 && intersection.z >= minZ1 && intersection.z <= maxZ1 &&
                                               intersection.x >= minX2 && intersection.x <= maxX2 && intersection.z >= minZ2 && intersection.z <= maxZ2)) {
                                             intersection = null;
                                         }
                                    }
                                }
                                if (intersection) {
                                    if (s1.type === 'line') s1.p2 = intersection;
                                    else s1.endAngle = Math.atan2(intersection.x - s1.cx, intersection.z - s1.cz); 
                                    if (s2.type === 'line') s2.p1 = intersection;
                                    else s2.startAngle = Math.atan2(intersection.x - s2.cx, intersection.z - s2.cz);
                                    trimmedOffsetPath.splice(i + 1, j - (i + 1));
                                    loopFound = true; 
                                    break outerLoop; 
                                }
                            }
                        }
                    }
                }

                const offsetPath = trimmedOffsetPath; 
                
                if (params.doFinishing) {
                    let finRaw = [];
                    for (let i = 0; i < contourSegments.length; i++) {
                        const seg = contourSegments[i];
                         if (seg.type === 'line') {
                            const n = getNormal(seg.p1, seg.p2);
                            finRaw.push({ type: 'line', p1: { x: seg.p1.x + n.x * tipR, z: seg.p1.z + n.z * tipR }, p2: { x: seg.p2.x + n.x * tipR, z: seg.p2.z + n.z * tipR } });
                        } else if (seg.type === 'arc') {
                            let rNew = (seg.dir === 'G3') ? seg.r + tipR : seg.r - tipR;
                            if (rNew <= 1.5) { } else {
                                const startAngle = Math.atan2(seg.p1.x - seg.cx, seg.p1.z - seg.cz);
                                const endAngle = Math.atan2(seg.p2.x - seg.cx, seg.p2.z - seg.cz);
                                finRaw.push({ type: 'arc', cx: seg.cx, cz: seg.cz, r: rNew, dir: seg.dir, refP1: seg.p1, refP2: seg.p2, startAngle, endAngle });
                            }
                        }
                    }
                    if (finRaw.length > 0) {
                         finishOffsetPath.push(JSON.parse(JSON.stringify(finRaw[0])));
                         for (let i = 0; i < finRaw.length - 1; i++) {
                            let prevOff = finishOffsetPath[finishOffsetPath.length - 1]; 
                            let nextOff = JSON.parse(JSON.stringify(finRaw[i+1])); 
                            let intersection = null;
                            if (prevOff.type === 'line' && nextOff.type === 'line') {
                                intersection = intersectLines(prevOff.p1, prevOff.p2, nextOff.p1, nextOff.p2);
                            } else if (prevOff.type === 'line' && nextOff.type === 'arc') {
                                const ints = intersectLineCircle(prevOff.p1, prevOff.p2, {x:nextOff.cx, z:nextOff.cz}, nextOff.r);
                                if(ints && ints.length > 0) {
                                    const d1 = Math.hypot(ints[0].x - prevOff.p2.x, ints[0].z - prevOff.p2.z);
                                    const d2 = Math.hypot(ints[1].x - prevOff.p2.x, ints[1].z - prevOff.p2.z);
                                    intersection = d1 < d2 ? ints[0] : ints[1];
                                }
                            } else if (prevOff.type === 'arc' && nextOff.type === 'line') {
                                const ints = intersectLineCircle(nextOff.p1, nextOff.p2, {x:prevOff.cx, z:prevOff.cz}, prevOff.r);
                                if(ints && ints.length > 0) {
                                    const d1 = Math.hypot(ints[0].x - nextOff.p1.x, ints[0].z - nextOff.p1.z);
                                    const d2 = Math.hypot(ints[1].x - nextOff.p1.x, ints[1].z - nextOff.p1.z);
                                    intersection = d1 < d2 ? ints[0] : ints[1];
                                }
                            }
                            
                            if (intersection) {
                                if (prevOff.type === 'line') prevOff.p2 = intersection;
                                else prevOff.endAngle = Math.atan2(intersection.x - prevOff.cx, intersection.z - prevOff.cz);
                                if (nextOff.type === 'line') nextOff.p1 = intersection;
                                else nextOff.startAngle = Math.atan2(intersection.x - nextOff.cx, intersection.z - nextOff.cz);
                                finishOffsetPath.push(nextOff);
                            } else {
                                let corner = null;
                                if (prevOff.type === 'line' && nextOff.type === 'line') {
                                    corner = intersectLinesInfinite(prevOff.p1, prevOff.p2, nextOff.p1, nextOff.p2);
                                }
                                if(corner) {
                                    prevOff.p2 = corner;
                                    nextOff.p1 = corner;
                                } else {
                                    const pStart = (prevOff.type === 'line') ? prevOff.p2 : {x: prevOff.cx + Math.sin(prevOff.endAngle)*prevOff.r, z: prevOff.cz + Math.cos(prevOff.endAngle)*prevOff.r};
                                    const pEnd = (nextOff.type === 'line') ? nextOff.p1 : {x: nextOff.cx + Math.sin(nextOff.startAngle)*nextOff.r, z: nextOff.cz + Math.cos(nextOff.startAngle)*nextOff.r};
                                    finishOffsetPath.push({ type: 'line', p1: pStart, p2: {x: pEnd.x, z: pStart.z} });
                                    if (Math.abs(pEnd.z - pStart.z) > 0.001) {
                                        finishOffsetPath.push({ type: 'line', p1: {x: pEnd.x, z: pStart.z}, p2: pEnd }); 
                                    }
                                }
                                finishOffsetPath.push(nextOff);
                            }
                         }
                    }
                    if (finishOffsetPath.length > 2) {
                        let loopFound = true;
                        let iterations = 0;
                        while (loopFound && iterations < 5) { 
                            loopFound = false;
                            iterations++;
                            outerLoopFin:
                            for (let i = 0; i < finishOffsetPath.length - 2; i++) {
                                for (let j = i + 2; j < finishOffsetPath.length; j++) {
                                    const s1 = finishOffsetPath[i];
                                    const s2 = finishOffsetPath[j];
                                    if (s1.isDegenerate || s2.isDegenerate) continue;
                                    let intersection = null;
                                    if (s1.type === 'line' && s2.type === 'line') {
                                        intersection = intersectLines(s1.p1, s1.p2, s2.p1, s2.p2);
                                        if (intersection) {
                                             const tol = 0.5;
                                             const minX1 = Math.min(s1.p1.x, s1.p2.x) - tol; const maxX1 = Math.max(s1.p1.x, s1.p2.x) + tol;
                                             const minZ1 = Math.min(s1.p1.z, s1.p2.z) - tol; const maxZ1 = Math.max(s1.p1.z, s1.p2.z) + tol;
                                             const minX2 = Math.min(s2.p1.x, s2.p2.x) - tol; const maxX2 = Math.max(s2.p1.x, s2.p2.x) + tol;
                                             const minZ2 = Math.min(s2.p1.z, s2.p2.z) - tol; const maxZ2 = Math.max(s2.p1.z, s2.p2.z) + tol;
                                             if (!(intersection.x >= minX1 && intersection.x <= maxX1 && intersection.z >= minZ1 && intersection.z <= maxZ1 &&
                                                   intersection.x >= minX2 && intersection.x <= maxX2 && intersection.z >= minZ2 && intersection.z <= maxZ2)) {
                                                 intersection = null;
                                             }
                                        }
                                    }
                                    if (intersection) {
                                        if (s1.type === 'line') s1.p2 = intersection;
                                        else s1.endAngle = Math.atan2(intersection.x - s1.cx, intersection.z - s1.cz); 
                                        if (s2.type === 'line') s2.p1 = intersection;
                                        else s2.startAngle = Math.atan2(intersection.x - s2.cx, intersection.z - s2.cz);
                                        finishOffsetPath.splice(i + 1, j - (i + 1));
                                        loopFound = true; 
                                        break outerLoopFin;
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (incompleteMachiningCount > 0) foundErrors.push({ type: 'warning', msg: `POZN√ÅMKA: V ${incompleteMachiningCount} m√≠stech nedojde ke kompletn√≠mu obroben√≠.` });
                setErrors(foundErrors);

                const passes = [];
                const step = parseFloat(params.depthOfCut) || 1;
                const sRad = (parseFloat(params.stockDiameter) || 100)/2;
                const stockFace = parseFloat(params.stockFace) || 0;
                
                if (params.roughingStrategy === 'face') {
                    let currentZ = stockFace;
                    const minZPart = -1000;
                    let safe = 0;
                    while (currentZ > minZPart && safe < 500) {
                        currentZ -= step; safe++;
                        let xsEnd = [];
                        offsetPath.forEach(os => {
                            if (os.isDegenerate) return;
                            if (os.type === 'line') {
                                const x = intersectVerticalLineSegment(currentZ, os.p1, os.p2);
                                if (x !== null) xsEnd.push(x);
                            } else if (os.type === 'arc') {
                                const res = intersectVerticalLineArc(currentZ, {x: os.cx, z: os.cz}, os.r);
                                res.forEach(x => {
                                    const angle = Math.atan2(x - os.cx, currentZ - os.cz);
                                    if (isAngleBetween(angle, os.startAngle, os.endAngle, os.dir === 'G2')) xsEnd.push(x);
                                });
                            }
                        });
                        xsEnd.sort((a, b) => a - b); 
                        let xTarget = 0;
                        if (xsEnd.length > 0) {
                            const validXs = xsEnd.filter(x => x < sRad + 1);
                            if (validXs.length > 0) xTarget = validXs[validXs.length - 1]; 
                        } else {
                            let maxOZ = -9999;
                            offsetPath.forEach(p => { 
                                if(p.isDegenerate) return;
                                const z1 = p.type==='line' ? p.p1.z : p.cz + p.r; 
                                const z2 = p.type==='line' ? p.p2.z : p.cz - p.r; 
                                maxOZ = Math.max(maxOZ, z1, z2);
                            });
                            if (currentZ > maxOZ) xTarget = -1; else continue; 
                        }
                        if (xTarget >= sRad - 0.01) continue;
                        passes.push({ type: 'face', z: currentZ, xStart: sRad + 2, xEnd: xTarget });
                        if (currentZ < -200) break; 
                    }
                } else {
                    let currentX = sRad;
                    if (params.stockMode === 'casting' && stockWorldPoints.length > 0) {
                       let maxStockX = -9999;
                       stockWorldPoints.forEach(p => { if (p.xReal > maxStockX) maxStockX = p.xReal; });
                       currentX = maxStockX; 
                    }
                    const cylStockZ = (parseFloat(params.stockLength) || 100) * -1;
                    let safe = 0;
                    while (currentX > -50 && safe < 500) {
                        currentX -= step; safe++;
                        let zsEnd = [];
                        offsetPath.forEach(os => {
                            if(os.isDegenerate) return;
                            if (os.type === 'line') {
                                const z = intersectHorizontalLineSegment(currentX, os.p1, os.p2);
                                if (z !== null) zsEnd.push(z);
                            } else if (os.type === 'arc') {
                                const res = intersectHorizontalLineArc(currentX, {x: os.cx, z: os.cz}, os.r);
                                res.forEach(z => {
                                    const angle = Math.atan2(currentX - os.cx, z - os.cz);
                                    if (isAngleBetween(angle, os.startAngle, os.endAngle, os.dir === 'G2')) zsEnd.push(z);
                                });
                            }
                        });
                        zsEnd.sort((a, b) => b - a);
                        zsEnd = zsEnd.filter((z, i) => i === 0 || Math.abs(z - zsEnd[i-1]) > 0.01);

                        if (zsEnd.length > 0) {
                            let zTarget = zsEnd[0];
                            let zStartCut = allowanceZ;
                            if (params.stockMode === 'casting') {
                                let zsStart = [];
                                stockPathSegments.forEach(ss => {
                                    if (ss.type === 'line') {
                                        const z = intersectHorizontalLineSegment(currentX, ss.p1, ss.p2);
                                        if (z !== null) zsStart.push(z);
                                    } else if (ss.type === 'arc') {
                                        const res = intersectHorizontalLineArc(currentX, {x: ss.cx, z: ss.cz}, ss.r);
                                        res.forEach(z => {
                                            const angle = Math.atan2(currentX - ss.cx, z - ss.cz);
                                            if (isAngleBetween(angle, ss.startAngle, ss.endAngle, ss.dir === 'G2')) zsStart.push(z);
                                        });
                                    }
                                });
                                zsStart.sort((a, b) => b - a);
                                const validStarts = zsStart.filter(z => z > zTarget + 0.01);
                                if (validStarts.length > 0) zStartCut = validStarts[0];
                                else if (zsStart.length === 0) continue; 
                            } else {
                                if (currentX > sRad) continue; 
                                if (zTarget < cylStockZ) zTarget = cylStockZ;
                                zStartCut = stockFace;
                            }
                            if (zStartCut > zTarget) {
                                passes.push({ type: 'long', x: currentX, zStart: zStartCut, zEnd: zTarget });
                            }
                        }
                        let minPartX = 9999;
                        offsetPath.forEach(os => {
                           if(os.isDegenerate) return;
                           if (os.type === 'line') minPartX = Math.min(minPartX, os.p1.x, os.p2.x);
                           else minPartX = Math.min(minPartX, os.cx - os.r); 
                        });
                        if (currentX < minPartX - 1) break; 
                    }
                }

                let simPath = [];
                let totalPathLength = 0;
                let estimatedTimeSeconds = 0;
                
                // Helper to add to path and calculate length/time
                const addToPath = (x1, z1, x2, z2, type) => {
                    const dist = Math.hypot(x2 - x1, z2 - z1);
                    totalPathLength += dist;
                    
                    // Simple Time Estimation Logic
                    if (type === 'G0') {
                        // Rapid traverse assumption: 5000 mm/min
                        estimatedTimeSeconds += (dist / 5000) * 60;
                    } else {
                        // Cutting feed logic
                        // Need RPM. If G96 (const surface speed), RPM varies with X.
                        // RPM = (Vc * 1000) / (PI * D)
                        const feed = parseFloat(params.feed) || 0.1;
                        const speed = parseFloat(params.speed) || 200;
                        
                        let avgX = Math.abs((x1 + x2) / 2); // Radius
                        if (avgX < 1) avgX = 1; // Prevent div by zero
                        const diam = avgX * 2;
                        
                        let rpm = (speed * 1000) / (Math.PI * diam);
                        if (rpm > 2000) rpm = 2000; // Limit
                        
                        const mmPerMin = feed * rpm;
                        if (mmPerMin > 0) {
                            estimatedTimeSeconds += (dist / mmPerMin) * 60;
                        }
                    }
                    return { x: x2, z: z2, type };
                };
                
                if (useManualCode) {
                    // USE MANUAL / AI CODE
                    simPath = parseManualGCodeToPath(manualGCode, params);
                    // Recalculate basic stats for manual code
                    for(let i=0; i<simPath.length-1; i++) {
                        addToPath(simPath[i].x, simPath[i].z, simPath[i+1].x, simPath[i+1].z, simPath[i+1].type);
                    }
                } else {
                    // USE AUTO GENERATED CODE
                    simPath.push({x: params.safeX/2, z: params.safeZ, type: 'G0'});
                    let currentSimX = params.safeX/2;
                    let currentSimZ = params.safeZ;

                    passes.forEach(pass => {
                        const tx = pass.type === 'long' ? (pass.type==='long' ? pass.x : pass.xStart) : pass.xStart; 
                        const tz = pass.type === 'long' ? pass.zStart + 1 : pass.z; 
                        
                        if (Math.abs(currentSimZ - tz) > 0.001) {
                            simPath.push(addToPath(currentSimX, currentSimZ, currentSimX, tz, 'G0'));
                            currentSimZ = tz;
                        }
                        if (Math.abs(currentSimX - tx) > 0.001) {
                             simPath.push(addToPath(currentSimX, currentSimZ, tx, tz, 'G0'));
                             currentSimX = tx;
                        }

                        if (pass.type === 'long') {
                            const xRetract = pass.x + retractDist; 
                            const xCut = pass.x;
                            simPath.push(addToPath(currentSimX, currentSimZ, xCut, pass.zEnd, 'G1'));          
                            simPath.push(addToPath(xCut, pass.zEnd, xRetract, pass.zEnd + retractDist, 'G1'));   
                            simPath.push(addToPath(xRetract, pass.zEnd + retractDist, xRetract, pass.zStart + 1, 'G0'));   
                            currentSimX = xRetract;
                            currentSimZ = pass.zStart + 1;
                        } else {
                            const zRetract = pass.z + retractDist; 
                            const zCut = pass.z;
                            simPath.push(addToPath(currentSimX, currentSimZ, pass.xEnd, zCut, 'G1')); 
                            simPath.push(addToPath(pass.xEnd, zCut, pass.xEnd, zRetract, 'G1')); 
                            simPath.push(addToPath(pass.xEnd, zRetract, pass.xStart, zRetract, 'G0')); 
                            currentSimX = pass.xStart;
                            currentSimZ = zRetract;
                        }
                    });
                    
                    simPath.push(addToPath(currentSimX, currentSimZ, params.safeX/2, params.safeZ, 'G0'));

                    if (params.doFinishing && finishOffsetPath.length > 0) {
                         const startSeg = finishOffsetPath[0];
                         const startX = startSeg.type === 'line' ? startSeg.p1.x : (startSeg.cx + Math.sin(startSeg.startAngle)*startSeg.r);
                         const startZ = startSeg.type === 'line' ? startSeg.p1.z : (startSeg.cz + Math.cos(startSeg.startAngle)*startSeg.r);
                         
                         // Approach
                         const lastPt = simPath[simPath.length-1];
                         simPath.push(addToPath(lastPt.x, lastPt.z, startX + 2, startZ, 'G0')); 
                         simPath.push(addToPath(startX + 2, startZ, startX, startZ, 'G1')); 

                         finishOffsetPath.forEach(seg => {
                             if (seg.isDegenerate) return;
                             const prev = simPath[simPath.length-1];
                             
                             if (seg.type === 'line') {
                                 simPath.push(addToPath(prev.x, prev.z, seg.p2.x, seg.p2.z, 'G1'));
                             } else {
                                 const steps = 10;
                                 let sA = seg.startAngle;
                                 let eA = seg.endAngle;
                                 if (seg.dir === 'G2' && eA > sA) eA -= 2*Math.PI;
                                 if (seg.dir === 'G3' && eA < sA) eA += 2*Math.PI;
                                 
                                 // Add arc length approximate
                                 let lastArcX = prev.x;
                                 let lastArcZ = prev.z;
                                 
                                 for(let j=1; j<=steps; j++) {
                                     const a = sA + (eA - sA) * (j/steps);
                                     const nextX = seg.cx + Math.sin(a)*seg.r;
                                     const nextZ = seg.cz + Math.cos(a)*seg.r;
                                     
                                     // We calculate time for small segments but push them as one arc visually in G-code gen logic, 
                                     // but for sim path we push points.
                                     addToPath(lastArcX, lastArcZ, nextX, nextZ, seg.dir); // Just for stats calc
                                     simPath.push({x: nextX, z: nextZ, type: seg.dir});
                                     lastArcX = nextX;
                                     lastArcZ = nextZ;
                                 }
                             }
                         });
                         const finalPt = simPath[simPath.length-1];
                         simPath.push(addToPath(finalPt.x, finalPt.z, finalPt.x + 2, finalPt.z + 2, 'G0'));
                         const veryLast = simPath[simPath.length-1];
                         simPath.push(addToPath(veryLast.x, veryLast.z, params.safeX/2, params.safeZ, 'G0'));
                    }
                }

                return { worldPoints, stockWorldPoints, offsetPath, finishOffsetPath, stockPathSegments, passes, simPath, retractDist, totalPathLength, estimatedTimeSeconds };
            }, [contourPoints, stockPoints, params, useManualCode, manualGCode]);

            // --- G-Code and Mapping Generation ---
            useEffect(() => {
                let animationFrameId; let startTime;
                const animate = (time) => {
                    if (!startTime) startTime = time;
                    if (simRunning) {
                        setSimProgress(prev => { 
                            // ZPOMALENO z 0.003 na 0.0015
                            const next = prev + 0.0015; 
                            if (next >= 1) { 
                                setSimRunning(false); 
                                return 1; 
                            } 
                            return next; 
                        });
                        animationFrameId = requestAnimationFrame(animate);
                    }
                };
                if (simRunning) animationFrameId = requestAnimationFrame(animate);
                return () => cancelAnimationFrame(animationFrameId);
            }, [simRunning]);

            useEffect(() => {
                // If using manual code, we don't generate standard code
                if (useManualCode) {
                    const lines = manualGCode.split('\n').map((line, idx) => ({ text: line, simIdx: idx }));
                    setGeneratedCode(lines);
                    return;
                }

                const d = new Date();
                const lines = []; 
                const add = (text, simIdx = null) => lines.push({ text, simIdx });
                
                const cmt = (text) => {
                    if (params.controlSystem === 'fanuc') return `( ${text} )`;
                    return `; ${text}`;
                };
                const addCmt = (text) => add(cmt(text), null);
                
                // Block number counter
                let blockNum = 10;
                const N = () => {
                    const s = `N${blockNum} `;
                    blockNum += 10;
                    return s;
                };

                // Helper for lines with block numbers
                const addN = (text, simIdx = null) => {
                    add(`${N()}${text}`, simIdx);
                };

                const note = (cmd, text) => ` ${cmd}${cmt(text)}`; 

                // Konfigurace pro jednotliv√© syst√©my
                let arcR = (r) => `CR=${(parseFloat(r) || 0).toFixed(3)}`; // Default Sinumerik

                if (params.controlSystem === 'sinumerik') {
                    addCmt(`Vygenerovan√Ω k√≥d SINUMERIK 840D`);
                    addCmt(`Datum: ${d.toLocaleDateString()}`);
                    addN(`G18${note('', 'Rovina ZX')}`);
                    addN(`G90${note('', 'Absolutn√≠ programov√°n√≠')}`);
                    addN(`G54${note('', 'Posunut√≠ poƒç√°tku')}`);
                    addN(`G95${note('', 'Posuv na ot√°ƒçku')}`);
                    addN(`G75 Z0${note('', 'N√°jezd do ref. bodu')}`);
                    addN(`G75 X0`);
                    addN(`LIMS=2000${note('', 'Limit ot√°ƒçek')}`);
                    addN(`G96 S${params.speed} ${params.machineType}${note('', 'Konst. ≈ôezn√° rychlost')}`);
                    
                    const diamNote = params.mode === 'DIAMON' ? 'Programov√°n√≠ pr≈Ømƒõru' : 'Programov√°n√≠ polomƒõru';
                    addN(`${params.mode}${note('', diamNote)}`);

                    addN(`T="${params.toolName}" D1 M6${note('', 'V√Ωmƒõna n√°stroje')}`);
                    addN(`M3${note('', 'V≈ôeteno CW')}`);
                    addN(`M8${note('', 'Chlazen√≠ ZAP')}`);

                    arcR = (r) => `CR=${(parseFloat(r) || 0).toFixed(3)}`;
                } else if (params.controlSystem === 'fanuc') {
                    addCmt(`Vygenerovan√Ω k√≥d FANUC`);
                    addCmt(`Datum: ${d.toLocaleDateString()}`);
                    addN(`G21${note('', 'Metrick√Ω vstup')}`);
                    addN(`G40${note('', 'Zru≈°en√≠ kompenzace')}`);
                    addN(`G99${note('', 'Posuv mm/ot')}`);
                    addN(`G18${note('', 'Rovina ZX')}`);
                    addN(`G28 U0 W0${note('', 'Referenƒçn√≠ bod')}`);
                    addN(`G50 S2000${note('', 'Max ot√°ƒçky')}`);
                    addN(`G96 S${params.speed} M3${note('', 'Konst. ≈ôezn√° rychlost')}`);
                    addN(`T0101${note('', 'N√°stroj 1 / Korekce 1')}`);
                    addN(`M8${note('', 'Chlazen√≠ ZAP')}`);
                    arcR = (r) => `R${(parseFloat(r) || 0).toFixed(3)}`;
                } else if (params.controlSystem === 'heidenhain') {
                    addCmt(`Vygenerovan√Ω k√≥d HEIDENHAIN ISO`);
                    addCmt(`Datum: ${d.toLocaleDateString()}`);
                    addN(`G18${note('', 'Rovina ZX')}`);
                    addN(`G90${note('', 'Absolutn√≠')}`);
                    addN(`G71${note('', 'Metrick√Ω syst√©m')}`);
                    addN(`G54${note('', 'Nulov√Ω bod')}`);
                    addN(`G96 S${params.speed} M3${note('', '≈òezn√° rychlost')}`);
                    addN(`T1 M6${note('', 'N√°stroj')}`);
                    addN(`M8`);
                    arcR = (r) => `R${(parseFloat(r) || 0).toFixed(3)}`;
                }
                
                let simCounter = 0; 
                addN(`G0 X${params.safeX} Z${params.safeZ}${note('', 'Rychloposuv')}`, 0); 

                const rDist = calculatedData.retractDist || 2.0;

                addCmt(`--- HRUBOVANI (${params.roughingStrategy === 'face' ? 'CELNI' : 'PODELNE'}) ---`);
                
                calculatedData.passes.forEach((pass, i) => {
                    addCmt(`Pr≈Øchod ${i+1}`);
                    if (pass.type === 'long') {
                        const xVal = params.mode === 'DIAMON' ? (pass.x * 2).toFixed(3) : pass.x.toFixed(3);
                        const xRetract = params.mode === 'DIAMON' ? ((pass.x + rDist) * 2).toFixed(3) : (pass.x + rDist).toFixed(3);
                        simCounter += 1; addN(`G0 X${xRetract} Z${(pass.zStart + 1).toFixed(3)}`, simCounter);
                        simCounter += 1; addN(`G1 X${xVal} F${params.feed}`, simCounter); 
                        simCounter += 1; addN(`G1 Z${pass.zEnd.toFixed(3)}`, simCounter);
                        simCounter += 1; addN(`G1 X${xRetract} Z${(pass.zEnd + rDist).toFixed(3)}`, simCounter);
                        simCounter += 1; addN(`G0 Z${(pass.zStart + 1).toFixed(3)}`, simCounter);
                    } else {
                        const zVal = pass.z.toFixed(3);
                        const zRetract = (pass.z + rDist).toFixed(3);
                        const xStart = params.mode === 'DIAMON' ? (pass.xStart * 2).toFixed(3) : pass.xStart.toFixed(3);
                        const xEnd = params.mode === 'DIAMON' ? (pass.xEnd * 2).toFixed(3) : pass.xEnd.toFixed(3);
                        const xEndRetract = params.mode === 'DIAMON' ? ((pass.xEnd + rDist) * 2).toFixed(3) : (pass.xEnd + rDist).toFixed(3);
                        simCounter += 1; addN(`G0 X${xStart} Z${zRetract}`, simCounter);
                        simCounter += 1; addN(`G1 Z${zVal} F${params.feed}`, simCounter);
                        simCounter += 1; addN(`G1 X${xEnd}`, simCounter);
                        simCounter += 1; addN(`G1 X${xEndRetract} Z${zRetract}`, simCounter);
                        simCounter += 1; addN(`G0 X${xStart}`, simCounter);
                    }
                });

                simCounter += 1;
                addN(`G0 X${params.safeX} Z${params.safeZ}`, simCounter);

                if (params.doFinishing && calculatedData.finishOffsetPath.length > 0) {
                    addCmt(`--- DOKONCOVANI ---`);
                    const startSeg = calculatedData.finishOffsetPath[0];
                    const sX = startSeg.type === 'line' ? startSeg.p1.x : (startSeg.cx + Math.sin(startSeg.startAngle)*startSeg.r);
                    const sZ = startSeg.type === 'line' ? startSeg.p1.z : (startSeg.cz + Math.cos(startSeg.startAngle)*startSeg.r);
                    const sX_out = params.mode === 'DIAMON' ? (sX * 2).toFixed(3) : sX.toFixed(3);
                    simCounter += 1; addN(`G0 X${sX_out} Z${sZ.toFixed(3)}`, simCounter);
                    simCounter += 1; addN(`G1 X${sX_out} Z${sZ.toFixed(3)}`, simCounter); 

                    calculatedData.finishOffsetPath.forEach(seg => {
                        if(seg.isDegenerate) return;
                        if (seg.type === 'line') {
                             const eX = params.mode === 'DIAMON' ? (seg.p2.x * 2).toFixed(3) : seg.p2.x.toFixed(3);
                             simCounter += 1;
                             addN(`G1 X${eX} Z${seg.p2.z.toFixed(3)}`, simCounter);
                        } else {
                             simCounter += 10;
                             const eX = params.mode === 'DIAMON' ? ((seg.cx + Math.sin(seg.endAngle)*seg.r) * 2).toFixed(3) : (seg.cx + Math.sin(seg.endAngle)*seg.r).toFixed(3);
                             const eZ = (seg.cz + Math.cos(seg.endAngle)*seg.r).toFixed(3);
                             addN(`${seg.dir} X${eX} Z${eZ} ${arcR(seg.r)} ${seg.isCornerRoll ? cmt('Obeplut√≠ rohu') : ''}`, simCounter);
                        }
                    });
                    simCounter += 2; 
                    addN(`G0 X${params.safeX} Z${params.safeZ}`, simCounter);
                }

                if (params.controlSystem === 'fanuc') {
                    addN(`M9`);
                    addN(`M5`);
                    addN(`G28 U0 W0`);
                    addN(`M30${note('', 'Konec programu')}`);
                } else if (params.controlSystem === 'heidenhain') {
                    addN(`M9`);
                    addN(`M5`);
                    addN(`M30`);
                } else {
                    addN(`M30${note('', 'Konec programu')}`);
                }
                
                addCmt(`--- KONTURA (Pro referenci) ---`);
                contourPoints.forEach(p => {
                    let line = `${p.type} X${(parseFloat(p.x)||0)} Z${(parseFloat(p.z)||0)}`;
                    if (p.type === 'G2' || p.type === 'G3') line += ` ${arcR(p.r)}`; 
                    addCmt(line); 
                });

                setGeneratedCode(lines);
            }, [calculatedData, params, contourPoints, useManualCode, manualGCode]);

            const handleLineClick = (simIdx) => {
                if (simIdx !== null && calculatedData.simPath.length > 0) {
                    const progress = simIdx / (calculatedData.simPath.length - 1);
                    setSimProgress(progress);
                }
            };
            
            const toggleSimulation = () => {
                if (simRunning) {
                    setSimRunning(false);
                } else {
                    if (simProgress >= 1) {
                        setSimProgress(0);
                    }
                    setSimRunning(true);
                }
            };

            const stopSimulation = () => {
                setSimRunning(false);
                setSimProgress(0);
            };
            
            useEffect(() => {
                if (!codeContainerRef.current) return;
                const activeEl = codeContainerRef.current.querySelector('.code-line.active');
                if (activeEl) {
                    activeEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }, [simProgress]);
            
            const currentSimIdx = Math.floor(simProgress * (calculatedData.simPath.length - 1));
            const activeLineIndex = generatedCode.findIndex(line => line.simIdx !== null && line.simIdx > currentSimIdx);
            const highlightIndex = activeLineIndex === -1 ? generatedCode.findLastIndex(l => l.simIdx !== null) : activeLineIndex;

            const draw = useCallback(() => {
                const canvas = canvasRef.current;
                const container = containerRef.current;
                if (!canvas || !container) return;
                
                const ctx = canvas.getContext('2d');
                const w = container.clientWidth;
                const h = container.clientHeight;
                if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }

                const colors = theme === 'dark' ? {
                    bg: '#111827', grid: '#374151', axis: '#ef4444', stock: '#9ca3af',
                    contour: '#3b82f6', offset: '#a855f7', pass: '#22c55e', finish: '#f472b6', error: '#ef4444', text: '#9ca3af', tool: '#facc15'
                } : {
                    bg: '#ffffff', grid: '#e5e7eb', axis: '#ef4444', stock: '#6b7280',
                    contour: '#2563eb', offset: '#9333ea', pass: '#16a34a', finish: '#db2777', error: '#ef4444', text: '#6b7280', tool: '#fbbf24'
                };

                ctx.fillStyle = colors.bg; ctx.fillRect(0, 0, w, h);
                const toScreen = (x, z) => {
                    if(isNaN(x) || isNaN(z)) return {x:0, y:0};
                    
                    if (params.machineStructure === 'carousel') {
                        return { x: view.panX + x * view.scale, y: view.panY - z * view.scale };
                    } else {
                        return { x: view.panX + z * view.scale, y: view.panY - x * view.scale };
                    }
                };

                ctx.strokeStyle = colors.grid; ctx.lineWidth = 1; ctx.beginPath();
                
                ctx.fillStyle = theme === 'dark' ? '#6b7280' : '#9ca3af';
                ctx.font = "10px sans-serif";
                
                for (let i=-500; i<=500; i+=20) {
                     const p1 = toScreen(-500, i); const p2 = toScreen(500, i);
                     ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                     
                     const p3 = toScreen(i, -500); const p4 = toScreen(i, 500);
                     ctx.moveTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y);
                }
                ctx.stroke();

                for (let i=-500; i<=500; i+=20) {
                    if (i === 0) continue; 

                    const ptHoriz = toScreen(0, i); 
                    
                    if (params.machineStructure === 'carousel') {
                        const ptX = toScreen(i, 0); 
                        ctx.textAlign = "center"; 
                        ctx.textBaseline = "top";
                        ctx.fillText(i.toString(), ptX.x, ptX.y + 2);

                        const ptZ = toScreen(0, i); 
                        ctx.textAlign = "right"; 
                        ctx.textBaseline = "middle";
                        ctx.fillText(i.toString(), ptZ.x - 4, ptZ.y);
                    } else {
                        const ptZ = toScreen(0, i);
                        ctx.textAlign = "center"; 
                        ctx.textBaseline = "top";
                        ctx.fillText(i.toString(), ptZ.x, ptZ.y + 2);

                        const ptX = toScreen(i, 0);
                        ctx.textAlign = "right"; 
                        ctx.textBaseline = "middle";
                        ctx.fillText(i.toString(), ptX.x - 4, ptX.y);
                    }
                }

                const zero = toScreen(0,0);
                ctx.strokeStyle = colors.axis; ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(0, zero.y); ctx.lineTo(w, zero.y);
                ctx.moveTo(zero.x, 0); ctx.lineTo(zero.x, h);
                ctx.stroke();
                ctx.fillStyle = colors.axis; ctx.font = "bold 12px monospace";
                ctx.textAlign = "left"; ctx.textBaseline = "alphabetic";
                
                if (params.machineStructure === 'carousel') {
                    ctx.fillText("X+", w - 20, zero.y + 15); 
                    ctx.fillText("Z+", zero.x + 10, 15);
                } else {
                    ctx.fillText("Z+", w - 20, zero.y + 15); 
                    ctx.fillText("X+", zero.x + 10, 15);
                }
                ctx.fillText("X0 Z0", zero.x + 4, zero.y - 4); 

                if (params.stockMode === 'cylinder') {
                    const sRad = (parseFloat(params.stockDiameter) || 0)/2;
                    const sLen = parseFloat(params.stockLength) || 0;
                    const sFace = parseFloat(params.stockFace) || 0;
                    const s1 = toScreen(sRad, sFace); 
                    const s2 = toScreen(sRad, -sLen); 
                    const s3 = toScreen(0, -sLen);
                    const sStart = toScreen(0, sFace);
                    ctx.fillStyle = theme === 'dark' ? 'rgba(100,100,100,0.1)' : 'rgba(200,200,200,0.3)';
                    ctx.beginPath(); ctx.moveTo(sStart.x, sStart.y); ctx.lineTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.lineTo(s3.x, s3.y); ctx.fill();
                    ctx.strokeStyle = colors.stock; ctx.setLineDash([5, 5]); ctx.beginPath();
                    ctx.moveTo(sStart.x, sStart.y); ctx.lineTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.lineTo(s3.x, s3.y);
                    ctx.stroke(); ctx.setLineDash([]);
                } else if (calculatedData.stockPathSegments.length > 0) {
                    ctx.beginPath();
                    calculatedData.stockPathSegments.forEach((seg, i) => {
                        if (seg.type === 'line') {
                            const p1 = toScreen(seg.p1.x, seg.p1.z); const p2 = toScreen(seg.p2.x, seg.p2.z);
                            if (i === 0) ctx.moveTo(p1.x, p1.y); else ctx.lineTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                        } else if (seg.type === 'arc') {
                             const sa_scr = -seg.startAngle; 
                             const steps = 15;
                             let sA = seg.startAngle;
                             let eA = seg.endAngle;
                             if (seg.dir === 'G2' && eA > sA) eA -= 2*Math.PI;
                             if (seg.dir === 'G3' && eA < sA) eA += 2*Math.PI;
                             
                             for(let j=0; j<=steps; j++) {
                                 const a = sA + (eA - sA) * (j/steps);
                                 const px = seg.cx + Math.sin(a) * seg.r;
                                 const pz = seg.cz + Math.cos(a) * seg.r;
                                 const pt = toScreen(px, pz);
                                 if (j === 0 && i === 0) ctx.moveTo(pt.x, pt.y);
                                 else if (j===0) ctx.moveTo(pt.x, pt.y); 
                                 else ctx.lineTo(pt.x, pt.y);
                             }
                        }
                    });
                    ctx.strokeStyle = colors.stock; ctx.setLineDash([4, 4]); ctx.lineWidth = 1; ctx.stroke(); ctx.setLineDash([]);
                }

                if (calculatedData.worldPoints.length > 0) {
                    ctx.beginPath();
                    const start = toScreen(calculatedData.worldPoints[0].xReal, calculatedData.worldPoints[0].zReal);
                    ctx.moveTo(start.x, start.y);
                    for (let i = 0; i < calculatedData.worldPoints.length - 1; i++) {
                        const p1 = calculatedData.worldPoints[i];
                        const p2 = calculatedData.worldPoints[i+1];
                        const ptEnd = toScreen(p2.xReal, p2.zReal);
                        
                        if (p2.type === 'G0' || p2.type === 'G1') {
                            ctx.lineTo(ptEnd.x, ptEnd.y);
                        } else if (p2.type === 'G2' || p2.type === 'G3') {
                            const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, p2.type);
                            if (!arc.error) {
                                const steps = 20;
                                let sA = Math.atan2(p1.xReal - arc.cx, p1.zReal - arc.cz);
                                let eA = Math.atan2(p2.xReal - arc.cx, p2.zReal - arc.cz);
                                if (p2.type === 'G2' && eA > sA) eA -= 2*Math.PI;
                                if (p2.type === 'G3' && eA < sA) eA += 2*Math.PI;
                                
                                for(let j=1; j<=steps; j++) {
                                    const a = sA + (eA - sA) * (j/steps);
                                    const px = arc.cx + Math.sin(a) * arc.r;
                                    const pz = arc.cz + Math.cos(a) * arc.r;
                                    const pt = toScreen(px, pz);
                                    ctx.lineTo(pt.x, pt.y);
                                }
                            } else {
                                ctx.lineTo(ptEnd.x, ptEnd.y);
                            }
                        }
                    }
                    ctx.strokeStyle = colors.contour; ctx.lineWidth = 3; ctx.stroke();
                }

                if (calculatedData.offsetPath.length > 0) {
                    ctx.beginPath();
                    calculatedData.offsetPath.forEach((seg, i) => {
                        if(seg.isDegenerate) return;
                        if (seg.type === 'line') {
                            const p1 = toScreen(seg.p1.x, seg.p1.z); const p2 = toScreen(seg.p2.x, seg.p2.z);
                            if (i === 0) ctx.moveTo(p1.x, p1.y); else ctx.lineTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                        } else if (seg.type === 'arc') {
                             const center = toScreen(seg.cx, seg.cz);
                             const rScreen = seg.r * view.scale;
                             const counterClockwise = (params.machineStructure === 'lathe') ? (seg.dir !== 'G3') : (seg.dir === 'G3');
                             
                             if(!isNaN(center.x)) {
                                 const startAng = params.machineStructure === 'carousel' ? -seg.startAngle : seg.startAngle + Math.PI/2;
                                 const endAng = params.machineStructure === 'carousel' ? -seg.endAngle : seg.endAngle + Math.PI/2;
                                 
                                 // Simple polyline approximation for offset path to avoid complex angle logic for dashed lines
                                 const steps = 10;
                                 let sA = seg.startAngle;
                                 let eA = seg.endAngle;
                                 if (seg.dir === 'G2' && eA > sA) eA -= 2*Math.PI;
                                 if (seg.dir === 'G3' && eA < sA) eA += 2*Math.PI;
                                 for(let j=0; j<=steps; j++) {
                                    const a = sA + (eA - sA) * (j/steps);
                                    const px = seg.cx + Math.sin(a) * seg.r;
                                    const pz = seg.cz + Math.cos(a) * seg.r;
                                    const pt = toScreen(px, pz);
                                    if(j===0 && i===0) ctx.moveTo(pt.x, pt.y);
                                    else if(j===0) {} 
                                    else ctx.lineTo(pt.x, pt.y);
                                 }
                             }
                        }
                    });
                    ctx.strokeStyle = colors.offset; ctx.lineWidth = 1; ctx.setLineDash([2,2]); ctx.stroke(); ctx.setLineDash([]);
                }
                
                if (params.doFinishing && calculatedData.finishOffsetPath.length > 0) {
                    ctx.beginPath();
                    calculatedData.finishOffsetPath.forEach((seg, i) => {
                        if(seg.isDegenerate) return;
                        if (seg.type === 'line') {
                            const p1 = toScreen(seg.p1.x, seg.p1.z); 
                            const p2 = toScreen(seg.p2.x, seg.p2.z);
                            if (i === 0) ctx.moveTo(p1.x, p1.y);
                            if (i > 0) ctx.lineTo(p1.x, p1.y); 
                            else ctx.moveTo(p1.x, p1.y);
                            
                            ctx.lineTo(p2.x, p2.y);
                        } else if (seg.type === 'arc') {
                            const steps = 15;
                            let sA = seg.startAngle;
                            let eA = seg.endAngle;
                            if (seg.dir === 'G2' && eA > sA) eA -= 2*Math.PI;
                            if (seg.dir === 'G3' && eA < sA) eA += 2*Math.PI;
                            for(let j=0; j<=steps; j++) {
                                const a = sA + (eA - sA) * (j/steps);
                                const px = seg.cx + Math.sin(a) * seg.r;
                                const pz = seg.cz + Math.cos(a) * seg.r;
                                const pt = toScreen(px, pz);
                                if(i===0 && j===0) ctx.moveTo(pt.x, pt.y);
                                else ctx.lineTo(pt.x, pt.y);
                            }
                        }
                    });
                    ctx.strokeStyle = colors.finish; ctx.lineWidth = 2; ctx.stroke();
                }

                ctx.beginPath();
                calculatedData.passes.forEach(pass => {
                    if (pass.type === 'long') {
                        const p1 = toScreen(pass.x, pass.zStart); const p2 = toScreen(pass.x, pass.zEnd);
                        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                    } else {
                        const p1 = toScreen(pass.xStart, pass.z); const p2 = toScreen(pass.xEnd, pass.z);
                        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                    }
                });
                ctx.strokeStyle = colors.pass; ctx.lineWidth = 1.5; ctx.stroke();

                if (calculatedData.simPath.length > 0) {
                    ctx.beginPath();
                    for (let i = 0; i < calculatedData.simPath.length - 1; i++) {
                        const p1 = calculatedData.simPath[i];
                        const p2 = calculatedData.simPath[i+1];
                        if (p2.type === 'G0' || p2.type === 'G1' || p2.type === 'G2' || p2.type === 'G3') {
                            const s = toScreen(p1.x, p1.z);
                            const e = toScreen(p2.x, p2.z);
                            // Draw all moves, including G0 (as dashed red lines)
                            if (Math.abs(s.x - e.x) > 0.1 || Math.abs(s.y - e.y) > 0.1) {
                                ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y);
                            }
                        }
                    }
                    ctx.strokeStyle = theme === 'dark' ? '#ef4444' : '#ef4444'; ctx.lineWidth = 1.5; 
                    ctx.setLineDash([6, 6]); ctx.stroke(); ctx.setLineDash([]);
                }

                if ((simRunning || simProgress > 0) && calculatedData.simPath.length > 0) {
                    const totalPoints = calculatedData.simPath.length;
                    const floatIndex = simProgress * (totalPoints - 1);
                    const idx = Math.floor(floatIndex);
                    const t = floatIndex - idx;
                    const pCurrent = calculatedData.simPath[idx];
                    
                    if (pCurrent) {
                        const pNext = calculatedData.simPath[Math.min(idx + 1, totalPoints - 1)] || pCurrent;
                        const curX = pCurrent.x + (pNext.x - pCurrent.x) * t;
                        const curZ = pCurrent.z + (pNext.z - pCurrent.z) * t;
                        const pt = toScreen(curX, curZ);
                        
                        const tRad = parseFloat(params.toolRadius) || 0.8;
                        const rPix = tRad * view.scale; 

                        ctx.fillStyle = colors.tool; 
                        ctx.strokeStyle = theme === 'dark' ? '#000' : '#000'; 
                        ctx.lineWidth = 1;

                        if (params.toolShape === 'round') {
                            ctx.beginPath();
                            ctx.arc(pt.x, pt.y, rPix, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                        } else if (params.toolShape === 'polygon') {
                            const lenPix = (parseFloat(params.toolLength) || 10) * view.scale;
                            const rotRad = -(parseFloat(params.toolAngle) || 0) * (Math.PI / 180);
                            const tipAng = (parseFloat(params.toolTipAngle) || 90) * (Math.PI / 180);

                            const a1 = rotRad; 
                            const a2 = rotRad - tipAng; 

                            const distToCorner = rPix / Math.sin(tipAng / 2);
                            
                            const bisector = (a1 + a2) / 2;
                            const cornerX = Math.cos(bisector + Math.PI) * distToCorner;
                            const cornerY = Math.sin(bisector + Math.PI) * distToCorner;

                            ctx.save();
                            ctx.translate(pt.x, pt.y); 
                            
                            ctx.beginPath();
                            ctx.moveTo(cornerX, cornerY);
                            
                            const x1 = cornerX + Math.cos(a1) * lenPix;
                            const y1 = cornerY + Math.sin(a1) * lenPix;
                            ctx.lineTo(x1, y1);
                            
                            const x2 = cornerX + Math.cos(a2) * lenPix;
                            const y2 = cornerY + Math.sin(a2) * lenPix;
                            ctx.lineTo(x2, y2);
                            
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            
                            ctx.restore();
                            
                            ctx.beginPath(); ctx.arc(pt.x, pt.y, rPix, 0, Math.PI * 2); ctx.stroke();
                        }
                        
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(pt.x, pt.y, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                if (!simRunning) {
                    const activePoints = editMode === 'contour' ? calculatedData.worldPoints : calculatedData.stockWorldPoints;
                    ctx.font = "bold 11px sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                    if(activePoints) {
                        activePoints.forEach((p, i) => {
                            if (!p) return;
                            const pt = toScreen(p.xReal, p.zReal);
                            
                            const isHovered = (i === hoverPointId);
                            const isDragged = (i === draggedPointId);
                            const radius = (isHovered || isDragged) ? 8 : 4; 

                            ctx.fillStyle = editMode === 'contour' ? colors.contour : colors.pass;
                            if (isHovered || isDragged) ctx.fillStyle = '#f59e0b'; 

                            ctx.beginPath(); 
                            ctx.arc(pt.x, pt.y, radius, 0, Math.PI*2); 
                            ctx.fill();
                            
                            if (!isHovered && !isDragged) {
                                const label = `${i+1}`; 
                                const tx = pt.x + 8; const ty = pt.y - 8;
                                ctx.fillStyle = theme === 'dark' ? '#fbbf24' : '#d97706'; 
                                ctx.fillText(label, tx, ty);
                            }
                        });
                    }
                }

            }, [calculatedData, view, theme, params, editMode, mobileTab, simRunning, simProgress, draggedPointId, hoverPointId]);

            useEffect(() => {
                if (!containerRef.current || !canvasRef.current) return;
                const resizeObserver = new ResizeObserver(() => { draw(); });
                resizeObserver.observe(containerRef.current);
                return () => resizeObserver.disconnect();
            }, [draw]);

            // Handlers ... (same)
            const handleWheel = (e) => { const s = Math.max(0.2, Math.min(view.scale * (1 - Math.sign(e.deltaY)*0.15), 50)); setView(v => ({...v, scale: s})); };
            
            const getPointAt = (clientX, clientY) => {
                if (!canvasRef.current || simRunning) return null;
                const rect = canvasRef.current.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                
                const activePoints = editMode === 'contour' ? calculatedData.worldPoints : calculatedData.stockWorldPoints;
                if (!activePoints) return null;

                const threshold = 15; 
                let closestIdx = null;
                let minD = Infinity;

                const toScreen = (xReal, zReal) => {
                     if (params.machineStructure === 'carousel') {
                        return { x: view.panX + xReal * view.scale, y: view.panY - zReal * view.scale };
                    } else {
                        return { x: view.panX + zReal * view.scale, y: view.panY - xReal * view.scale };
                    }
                };

                for (let i = 0; i < activePoints.length; i++) {
                    const p = activePoints[i];
                    if (!p) continue;
                    const pt = toScreen(p.xReal, p.zReal);
                    const d = Math.hypot(pt.x - x, pt.y - y);
                    if (d < threshold && d < minD) {
                        minD = d;
                        closestIdx = i;
                    }
                }
                return closestIdx;
            };

            const handleInsertAfter = (index) => {
                 pushHistory();
                 const list = editMode === 'contour' ? contourPoints : stockPoints; 
                 const setList = editMode === 'contour' ? setContourPoints : setStockPoints; 
                 const prev = list[index]; 
                 const newPoint = { ...prev, id: Date.now(), z: parseFloat(prev.z) - 5 }; 
                 const newList = [...list]; 
                 newList.splice(index + 1, 0, newPoint); 
                 setList(newList);
                 
                 setActiveTab('editor');
                 setMobileTab('editor');
            };

            const handleMouseDown = (e) => { 
                const pointIdx = getPointAt(e.clientX, e.clientY);
                
                if (addPointMode) {
                    if (pointIdx !== null) {
                        handleInsertAfter(pointIdx);
                        setAddPointMode(false); 
                    }
                    return; 
                }

                if (pointIdx !== null) {
                    pushHistory(); 
                    setDraggedPointId(pointIdx);
                    setIsDragging(true); 
                } else {
                    setIsDragging(true); 
                }
                lastMousePos.current = { x: e.clientX, y: e.clientY }; 
            };

            const handleMouseMove = (e) => {
                const pointIdx = getPointAt(e.clientX, e.clientY);
                
                if (addPointMode) {
                    if (canvasRef.current) canvasRef.current.style.cursor = pointIdx !== null ? 'pointer' : 'copy'; 
                    setHoverPointId(pointIdx);
                    return; 
                }

                if (!isDragging) {
                    setHoverPointId(pointIdx);
                    if (canvasRef.current) canvasRef.current.style.cursor = pointIdx !== null ? 'move' : 'crosshair';
                }

                if (!isDragging) return;

                const dx = e.clientX - lastMousePos.current.x; 
                const dy = e.clientY - lastMousePos.current.y;
                lastMousePos.current = { x: e.clientX, y: e.clientY };

                if (draggedPointId !== null) {
                    let dX_unit = 0;
                    let dZ_unit = 0;

                    if (params.machineStructure === 'carousel') {
                        dX_unit = dx / view.scale;
                        dZ_unit = -dy / view.scale;
                    } else {
                        dZ_unit = dx / view.scale;
                        dX_unit = -dy / view.scale; 
                    }

                    const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                    
                    setList(prev => {
                        const newList = [...prev];
                        const pt = {...newList[draggedPointId]};
                        pt.x = parseFloat(pt.x) + dX_unit;
                        pt.z = parseFloat(pt.z) + dZ_unit;
                        newList[draggedPointId] = pt;
                        return newList;
                    });

                } else {
                    setView(v => ({ ...v, panX: v.panX + dx, panY: v.panY + dy }));
                }
            };
            
            const handleMouseUp = () => {
                 setIsDragging(false);
                 setDraggedPointId(null);
            };

            const handleTouchStart = (e) => {
                if (e.touches.length === 1) {
                    const t = e.touches[0];
                    const pointIdx = getPointAt(t.clientX, t.clientY);

                    if (addPointMode) {
                        if (pointIdx !== null) {
                            handleInsertAfter(pointIdx);
                            setAddPointMode(false);
                        }
                        return;
                    }

                    if (pointIdx !== null) {
                         pushHistory();
                         setDraggedPointId(pointIdx);
                         setIsDragging(true);
                    } else {
                         setIsDragging(true);
                    }
                    lastMousePos.current = { x: t.clientX, y: t.clientY };
                } else if (e.touches.length === 2) {
                    const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    lastPinchDist.current = dist;
                }
            };

            const handleTouchMove = (e) => {
                if (addPointMode) return; 

                if (isDragging && e.touches.length === 1) {
                    const t = e.touches[0];
                    const dx = t.clientX - lastMousePos.current.x;
                    const dy = t.clientY - lastMousePos.current.y;
                    lastMousePos.current = { x: t.clientX, y: t.clientY };

                    if (draggedPointId !== null) {
                         let dX_unit = 0; let dZ_unit = 0;
                         if (params.machineStructure === 'carousel') {
                            dX_unit = dx / view.scale; dZ_unit = -dy / view.scale;
                         } else {
                            dZ_unit = dx / view.scale; dX_unit = -dy / view.scale; 
                         }
                         const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                         setList(prev => {
                            const newList = [...prev];
                            const pt = {...newList[draggedPointId]};
                            pt.x = parseFloat(pt.x) + dX_unit;
                            pt.z = parseFloat(pt.z) + dZ_unit;
                            newList[draggedPointId] = pt;
                            return newList;
                        });
                    } else {
                        setView(v => ({ ...v, panX: v.panX + dx, panY: v.panY + dy }));
                    }
                }
                if (e.touches.length === 2 && lastPinchDist.current) {
                    const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    const zoomFactor = dist / lastPinchDist.current;
                    setView(v => { const newScale = Math.max(0.2, Math.min(v.scale * zoomFactor, 50)); return { ...v, scale: newScale }; });
                    lastPinchDist.current = dist;
                }
            };

            const handleTouchEnd = () => {
                setIsDragging(false);
                setDraggedPointId(null);
                lastPinchDist.current = null;
            };

            const processGCodeString = (text) => {
                pushHistory();
                const lines = text.split('\n'); const newPoints = []; let currentType = 'G1'; let idCounter = Date.now(); let lastX = 100; let lastZ = 0;
                lines.forEach(line => {
                    const clean = line.toUpperCase().trim(); if (!clean || clean.startsWith(';')) return;
                    const gMatch = clean.match(/G([0-3])/); if (gMatch) currentType = 'G' + gMatch[1];
                    const xMatch = clean.match(/X([-]?\d+\.?\d*)/); const zMatch = clean.match(/Z([-]?\d+\.?\d*)/); const rMatch = clean.match(/(?:R|CR=)([-]?\d+\.?\d*)/);
                    if (xMatch || zMatch) {
                        const newX = xMatch ? parseFloat(xMatch[1]) : lastX; const newZ = zMatch ? parseFloat(zMatch[1]) : lastZ;
                        newPoints.push({ id: idCounter++, type: currentType, x: newX, z: newZ, r: rMatch ? parseFloat(rMatch[1]) : 0, mode: 'ABS' });
                        lastX = newX; lastZ = newZ;
                    }
                });
                if (newPoints.length > 0) {
                    if (editMode === 'contour') setContourPoints(newPoints); else setStockPoints(newPoints); 
                    setErrors([]); fitView(); 
                } else alert("Nepoda≈ôilo se rozpoznat ≈æ√°dn√© body v G-k√≥du.");
            };
            
            const parseGCode = () => processGCodeString(gCodeInput);

            const handleCopyGCode = async () => {
                const text = useManualCode ? manualGCode : generatedCode.map(l => l.text).join('\n');
                try {
                    await navigator.clipboard.writeText(text);
                    setCopyFeedback(true);
                    setTimeout(() => setCopyFeedback(false), 2000);
                } catch (err) {
                    console.error("Copy failed", err);
                    alert("Nepoda≈ôilo se zkop√≠rovat k√≥d do schr√°nky.");
                }
            };

            const handleDownload = () => {
                const text = useManualCode ? manualGCode : generatedCode.map(l => l.text).join('\n');
                const blob = new Blob([text], {type: "text/plain"});
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                
                let ext = 'mpf';
                if(params.controlSystem === 'heidenhain') ext = 'h';
                else if(params.controlSystem === 'fanuc') ext = 'nc';
                
                a.download = `program_${new Date().toISOString().slice(0,10)}.${ext}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };
            
            const toggleMode = (id) => { 
                pushHistory();
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                setList(prev => prev.map(p => p.id===id ? {...p, mode: p.mode==='ABS'?'INC':'ABS'} : p));
            };
            
            const updatePoint = (id, f, v) => {
                pushHistory();
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                setList(prev => prev.map(p => p.id===id ? {...p, [f]: v} : p));
            };
            
            const addPoint = () => { 
                pushHistory();
                const list = editMode === 'contour' ? contourPoints : stockPoints; 
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints; 
                const last = list.length > 0 ? list[list.length - 1] : { x: 100, z: 0 }; 
                setList([...list, {id: Date.now(), type:'G1', x:last.x, z: parseFloat(last.z)-10, r:0, mode: 'ABS'}]); 
            };
            
            const insertPoint = (index) => { 
                pushHistory();
                const list = editMode === 'contour' ? contourPoints : stockPoints; 
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints; 
                const prev = list[index]; 
                const newPoint = { ...prev, id: Date.now(), z: parseFloat(prev.z) - 5 }; 
                const newList = [...list]; newList.splice(index + 1, 0, newPoint); 
                setList(newList); 
            };
            
            const removePoint = (id) => { 
                const list = editMode === 'contour' ? contourPoints : stockPoints; 
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints; 
                if (list.length > 1) {
                    pushHistory();
                    setList(list.filter(p=>p.id!==id)); 
                }
            };
            
            const currentPoints = editMode === 'contour' ? contourPoints : stockPoints;

            return (
                <div className="flex flex-col md:flex-row h-full">
                    <div className={`${mobileTab === 'editor' ? 'flex' : 'hidden'} md:flex w-full md:w-96 flex-col border-r shadow-xl z-10 h-full overflow-hidden ${theme === 'dark' ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'}`}>
                        <div className={`p-4 border-b flex justify-between items-center ${theme === 'dark' ? 'bg-gray-900 border-gray-700' : 'bg-gray-100 border-gray-200'}`}>
                            <div className="flex items-center gap-2">
                                <h1 className="font-bold text-lg text-blue-500">Sinumerik CAM <span className="text-xs text-gray-400 font-normal">v1.8</span></h1>
                                <div className="flex gap-1 ml-2">
                                    <button onClick={undo} disabled={past.length===0} className={`p-1 rounded ${past.length===0 ? 'text-gray-300' : 'text-gray-600 hover:bg-gray-200 dark:text-gray-400 dark:hover:bg-gray-700'}`} title="Zpƒõt"><IconUndo /></button>
                                    <button onClick={redo} disabled={future.length===0} className={`p-1 rounded ${future.length===0 ? 'text-gray-300' : 'text-gray-600 hover:bg-gray-200 dark:text-gray-400 dark:hover:bg-gray-700'}`} title="Vp≈ôed"><IconRedo /></button>
                                </div>
                            </div>
                            <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')} className="p-2 rounded hover:bg-gray-700 hover:text-white transition-colors">
                                {theme === 'light' ? <IconMoon /> : <IconSun />}
                            </button>
                        </div>
                        {errors.length > 0 && (
                            <div className="bg-red-50 border-l-4 border-red-500 text-red-700 p-2 text-xs">
                                <div className="font-bold flex gap-2 items-center"><IconWarning /> Nalezeny probl√©my:</div>
                                <ul className="list-disc pl-6 mt-1 space-y-1">{errors.map((e, i) => <li key={i}>{e.msg || e}</li>)}</ul>
                            </div>
                        )}
                        <div className="flex border-b border-gray-200 dark:border-gray-700">
                             {['editor', 'params', 'import', 'AI'].map(tab => (
                                <button key={tab} onClick={() => setActiveTab(tab)} 
                                    className={`flex-1 p-3 text-sm font-medium capitalize ${activeTab===tab ? 'bg-blue-100 text-blue-700' : 'text-gray-500'}`}>
                                    {tab === 'AI' ? (
                                        <div className="flex items-center justify-center gap-1">
                                            <IconVoiceChat /> Chat
                                        </div>
                                    ) : tab}
                                </button>
                            ))}
                        </div>
                         <div className="flex-1 overflow-y-auto p-4 custom-scrollbar pb-20 md:pb-4">
                            {activeTab === 'editor' && (
                                <div className="space-y-3">
                                    <div className="flex gap-2 mb-2 bg-gray-200 p-1 rounded dark:bg-gray-700">
                                        <button onClick={() => setEditMode('contour')} className={`flex-1 flex items-center justify-center gap-2 text-xs py-1.5 rounded font-bold transition-all ${editMode==='contour' ? 'bg-white shadow text-blue-600 dark:bg-gray-600 dark:text-blue-300' : 'text-gray-500 hover:text-gray-700'}`}><IconEdit /> Kontura</button>
                                        <button onClick={() => { setEditMode('stock'); if(stockPoints.length === 0) generateDefaultStock(); }} className={`flex-1 flex items-center justify-center gap-2 text-xs py-1.5 rounded font-bold transition-all ${editMode==='stock' ? 'bg-white shadow text-green-600 dark:bg-gray-600 dark:text-green-300' : 'text-gray-500 hover:text-gray-700'}`}><IconBox /> Polotovar</button>
                                    </div>
                                    <div className="flex gap-1 px-2 text-xs font-bold text-gray-500 mb-1">
                                        <div className="w-6 text-center">#</div>
                                        <div className="w-14">Typ</div>
                                        <div className="w-8 text-center">M√≥d</div>
                                        <div className="w-16 text-center">X/U</div>
                                        <div className="w-16 text-center">Z/W</div>
                                        <div className="w-10 text-center">R</div>
                                    </div>
                                    {currentPoints.map((p, index) => (
                                        <div key={p.id} className={`border rounded p-2 flex flex-wrap gap-1 items-center ${theme === 'dark' ? 'bg-gray-750 border-gray-600' : 'bg-gray-50 border-gray-300'} ${editMode==='stock' ? 'border-l-4 border-l-green-500' : 'border-l-4 border-l-blue-500'}`}>
                                            <div className="w-6 font-mono text-xs text-gray-500 font-bold">{index+1}</div>
                                            <select value={p.type} onChange={(e) => updatePoint(p.id, 'type', e.target.value)} className={`border rounded text-xs px-1 py-1 w-14 ${theme==='dark'?'bg-gray-900 border-gray-600 text-white':'bg-white border-gray-300 text-gray-900'}`}><option>G0</option><option>G1</option><option>G2</option><option>G3</option></select>
                                            <button onClick={() => toggleMode(p.id)} className={`w-8 h-6 flex items-center justify-center rounded text-xs font-bold ${p.mode==='INC' ? 'bg-purple-100 text-purple-700 border border-purple-300' : 'bg-gray-100 text-gray-600 border border-gray-300'}`} title={p.mode === 'INC' ? 'P≈ô√≠r≈Østkovƒõ' : 'Absolutnƒõ'}>{p.mode === 'INC' ? 'INC' : 'ABS'}</button>
                                            <SmartInput type="number" value={p.x} onValueChange={(v) => updatePoint(p.id, 'x', v)} className={`border rounded text-sm w-16 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600 text-white':'bg-white border-gray-300 text-gray-900'}`} placeholder={p.mode==='INC' ? 'U' : 'X'} />
                                            <SmartInput type="number" value={p.z} onValueChange={(v) => updatePoint(p.id, 'z', v)} className={`border rounded text-sm w-16 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600 text-white':'bg-white border-gray-300 text-gray-900'}`} placeholder={p.mode==='INC' ? 'W' : 'Z'} />
                                            {(p.type === 'G2' || p.type === 'G3') && <SmartInput type="number" value={p.r} onValueChange={(v) => updatePoint(p.id, 'r', v)} className={`border rounded text-sm w-10 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600 text-white':'bg-white border-gray-300 text-gray-900'}`} placeholder="R" />}
                                            <div className="flex ml-auto gap-1">
                                                <button onClick={() => insertPoint(index)} className="text-blue-500 hover:text-blue-700 p-1" title="Vlo≈æit ≈ô√°dek za"><IconInsert /></button>
                                                <button onClick={() => removePoint(p.id)} className="text-red-400 hover:text-red-600 p-1" title="Smazat ≈ô√°dek"><IconTrash /></button>
                                            </div>
                                        </div>
                                    ))}
                                    <div className="grid grid-cols-2 gap-2">
                                        <button onClick={addPoint} className={`col-span-2 py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 ${editMode==='stock'?'bg-green-600 hover:bg-green-500':'bg-blue-600 hover:bg-blue-500'}`}><IconPlus /> P≈ôidat bod</button>
                                        <button onClick={handleCopyGCode} className={`py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 transition-all ${copyFeedback ? 'bg-green-600' : 'bg-gray-600 hover:bg-gray-500'}`}><IconClipboard /> {copyFeedback ? "Zkop√≠rov√°no" : "Kop√≠rovat"}</button>
                                        <button onClick={handleDownload} className="py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 bg-purple-600 hover:bg-purple-500"><IconDownload /> Ulo≈æit MPF</button>
                                        <button onClick={handleExportPDF} className="py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 bg-indigo-600 hover:bg-indigo-500"><IconFileText /> Export PDF</button>
                                    </div>
                                </div>
                            )}
                             {activeTab === 'params' && (
                                <div className="space-y-4">
                                    <h3 className={`font-bold border-b pb-1 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Konfigurace</h3>
                                    <div className="flex gap-2 mb-2">
                                        <button onClick={() => setParams({...params, machineStructure: 'lathe'})} className={`flex-1 py-1 text-xs border rounded flex items-center justify-center gap-1 ${params.machineStructure==='lathe' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Soustruh</button>
                                        <button onClick={() => setParams({...params, machineStructure: 'carousel'})} className={`flex-1 py-1 text-xs border rounded flex items-center justify-center gap-1 ${params.machineStructure==='carousel' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Karusel</button>
                                    </div>

                                    <h3 className={`font-bold border-b pb-1 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>≈ò√≠dic√≠ syst√©m</h3>
                                    <div className="flex gap-1 mb-2">
                                        <button onClick={() => setParams({...params, controlSystem: 'sinumerik'})} className={`flex-1 py-1 text-[10px] border rounded flex items-center justify-center gap-1 ${params.controlSystem==='sinumerik' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Sinumerik</button>
                                        <button onClick={() => setParams({...params, controlSystem: 'fanuc'})} className={`flex-1 py-1 text-[10px] border rounded flex items-center justify-center gap-1 ${params.controlSystem==='fanuc' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Fanuc</button>
                                        <button onClick={() => setParams({...params, controlSystem: 'heidenhain'})} className={`flex-1 py-1 text-[10px] border rounded flex items-center justify-center gap-1 ${params.controlSystem==='heidenhain' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Heidenhain</button>
                                    </div>

                                    <h3 className={`font-bold border-b pb-1 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Polotovar</h3>
                                    <div className="flex gap-2 mb-2">
                                        <button onClick={() => setParams({...params, stockMode: 'cylinder'})} className={`flex-1 py-1 text-xs border rounded ${params.stockMode==='cylinder' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>V√°lec</button>
                                        <button onClick={() => { setParams({...params, stockMode: 'casting'}); setActiveTab('editor'); setEditMode('stock'); if(stockPoints.length === 0) generateDefaultStock(); }} className={`flex-1 py-1 text-xs border rounded ${params.stockMode==='casting' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Vlastn√≠ tvar</button>
                                    </div>
                                    {params.stockMode === 'cylinder' ? (
                                        <div className="space-y-2">
                                            <div className="flex items-end gap-2">
                                                <div className="flex-1"><label className="text-xs text-gray-500">Pr≈Ømƒõr (D)</label><SmartInput type="number" value={params.stockDiameter} onValueChange={v=>setParams({...params, stockDiameter:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">D√©lka (Z-)</label><SmartInput type="number" value={params.stockLength} onValueChange={v=>setParams({...params, stockLength:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                            </div>
                                            <div className="flex items-end gap-2">
                                                <div className="flex-1"><label className="text-xs text-gray-500">P≈ô√≠davek ƒçelo (Z+)</label><SmartInput type="number" value={params.stockFace} onValueChange={v=>setParams({...params, stockFace:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">P≈ô√≠davek (pro Auto)</label><SmartInput type="number" value={params.stockMargin} onValueChange={v=>setParams({...params, stockMargin:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                            </div>
                                            <button onClick={handleAutoStock} className="w-full py-1.5 bg-indigo-600 text-white rounded text-xs font-bold flex items-center justify-center gap-1 hover:bg-indigo-500"><IconMagic /> Auto-rozmƒõr</button>
                                        </div>
                                    ) : (
                                        <div className="text-xs text-gray-500 italic p-2 bg-gray-100 rounded dark:bg-gray-800">Pro definici tvarov√©ho polotovaru (odlitku) pou≈æijte p≈ôep√≠naƒç "Polotovar" v z√°lo≈æce <b>Editor</b> a nakreslete jeho tvar.</div>
                                    )}
                                    
                                    <h3 className={`font-bold border-b pb-1 mt-4 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Bezpeƒçn√° poloha (N√°jezd)</h3>
                                    <div className="flex gap-2 mb-2">
                                        <div className="flex-1"><label className="text-xs text-gray-500">X (Pr≈Ømƒõr)</label><SmartInput type="number" value={params.safeX} onValueChange={v=>setParams({...params, safeX:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                        <div className="flex-1"><label className="text-xs text-gray-500">Z</label><SmartInput type="number" value={params.safeZ} onValueChange={v=>setParams({...params, safeZ:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                    </div>

                                    <h3 className={`font-bold border-b pb-1 mt-4 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Hrubov√°n√≠</h3>
                                    
                                    {/* MATERIAL DATABASE */}
                                    <div className={`p-2 rounded mb-2 border ${theme==='dark'?'bg-gray-800 border-gray-600':'bg-blue-50 border-blue-200'}`}>
                                        <div className="flex items-center gap-1 text-xs font-bold mb-1 opacity-70"><IconDatabase /> Datab√°ze materi√°l≈Ø (Rychl√© nastaven√≠)</div>
                                        <div className="grid grid-cols-2 gap-1">
                                            {Object.keys(MATERIALS).map(matKey => (
                                                <button 
                                                    key={matKey}
                                                    onClick={() => setParams(p => ({
                                                        ...p, 
                                                        speed: MATERIALS[matKey].speed,
                                                        feed: MATERIALS[matKey].feed,
                                                        depthOfCut: MATERIALS[matKey].depth
                                                    }))}
                                                    className={`text-[10px] px-2 py-1 rounded border transition-colors ${
                                                        theme==='dark' 
                                                        ? 'bg-gray-700 border-gray-600 hover:bg-gray-600 text-gray-300' 
                                                        : 'bg-white border-gray-300 hover:bg-blue-100 text-gray-700'
                                                    }`}
                                                >
                                                    {MATERIALS[matKey].name}
                                                </button>
                                            ))}
                                        </div>
                                    </div>

                                    <div className="flex gap-2 mb-2">
                                        <button onClick={() => setParams({...params, roughingStrategy: 'longitudinal', toolAngle: 15})} className={`flex-1 py-1 text-xs border rounded flex items-center justify-center gap-1 ${params.roughingStrategy==='longitudinal' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-700'}`}><IconArrowRight /> Pod√©lnƒõ (Z)</button>
                                        <button onClick={() => setParams({...params, roughingStrategy: 'face', toolAngle: -15})} className={`flex-1 py-1 text-xs border rounded flex items-center justify-center gap-1 ${params.roughingStrategy==='face' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-700'}`}><IconArrowDown /> ƒåelnƒõ (X)</button>
                                    </div>
                                    <div className="grid grid-cols-2 gap-2">
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Hloubka (ap)</label><SmartInput type="number" step="0.5" value={params.depthOfCut} onValueChange={v=>setParams({...params, depthOfCut:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Posuv (F)</label><SmartInput type="number" step="0.05" value={params.feed} onValueChange={v=>setParams({...params, feed:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Rychlost (Vc)</label><SmartInput type="number" step="10" value={params.speed} onValueChange={v=>setParams({...params, speed:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Odskok (G1 -> G0)</label><SmartInput type="number" step="0.5" value={params.retractDistance} onValueChange={v=>setParams({...params, retractDistance:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                    </div>
                                    <h3 className={`font-bold border-b pb-1 mt-4 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>N√°stroj</h3>
                                    <div className="grid grid-cols-2 gap-2">
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">R√°dius (R)</label><SmartInput type="number" step="0.1" value={params.toolRadius} onValueChange={v=>setParams({...params, toolRadius:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">P≈ô√≠davek X</label><SmartInput type="number" step="0.1" value={params.allowanceX} onValueChange={v=>setParams({...params, allowanceX:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">P≈ô√≠davek Z</label><SmartInput type="number" step="0.1" value={params.allowanceZ} onValueChange={v=>setParams({...params, allowanceZ:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                    </div>
                                    {/* Tool Shape Selector */}
                                    <div className="mt-2">
                                        <label className="text-xs text-gray-500 mb-1 block">Tvar destiƒçky</label>
                                        <div className="flex gap-1">
                                            <button onClick={() => setParams({...params, toolShape: 'round'})} className={`flex-1 py-1 border rounded flex items-center justify-center gap-1 ${params.toolShape==='round' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`} title="Kulat√°"><IconShapeCircle /></button>
                                            <button onClick={() => setParams({...params, toolShape: 'polygon', toolTipAngle: 90})} className={`flex-1 py-1 border rounded flex items-center justify-center gap-1 ${params.toolShape==='polygon' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`} title="Hranat√°"><IconShapePolygon /></button>
                                        </div>
                                        {params.toolShape === 'polygon' && (
                                            <div className="flex gap-2 mt-2">
                                                <div className="flex-1"><label className="text-xs text-gray-500">D√©lka hrany (L)</label><SmartInput type="number" value={params.toolLength} onValueChange={v=>setParams({...params, toolLength:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">Natoƒçen√≠ (¬∞)</label><SmartInput type="number" value={params.toolAngle} onValueChange={v=>setParams({...params, toolAngle:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">Vrcholov√Ω √∫hel (Œµ)</label><SmartInput type="number" value={params.toolTipAngle} onValueChange={v=>setParams({...params, toolTipAngle:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                            </div>
                                        )}
                                    </div>
                                    <div className="mt-4 pt-2 border-t dark:border-gray-700">
                                        <label className="flex items-center space-x-2 cursor-pointer">
                                            <input type="checkbox" checked={params.doFinishing} onChange={e => setParams({...params, doFinishing: e.target.checked})} className="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600" />
                                            <span className="text-sm font-bold text-gray-700 dark:text-gray-300">Dokonƒçovac√≠ operace (Na ƒçisto)</span>
                                        </label>
                                        <p className="text-xs text-gray-500 mt-1 pl-6">Vygeneruje dr√°hu n√°stroje p≈ôesnƒõ po kontu≈ôe (pouze s korekc√≠ R, bez p≈ô√≠davku).</p>
                                    </div>
                                    
                                    <div className="mt-8 pt-4 border-t dark:border-gray-700 flex justify-center">
                                        <button onClick={handleResetApp} className="text-xs text-red-500 hover:text-red-700 flex items-center gap-1">
                                            <IconRefresh /> Resetovat v≈°e (Vymazat ulo≈æen√©)
                                        </button>
                                    </div>
                                </div>
                            )}
                            {activeTab === 'AI' && (
                                <AiAssistant 
                                    contourPoints={contourPoints} 
                                    stockPoints={stockPoints} 
                                    params={params} 
                                    onUpdateContour={(pts) => {
                                        const newPts = pts.map((p, i) => ({...p, id: p.id || Date.now() + i}));
                                        pushHistory();
                                        setContourPoints(newPts);
                                        setActiveTab('editor');
                                        setEditMode('contour');
                                    }}
                                    onUpdateStock={(pts) => {
                                        const newPts = pts.map((p, i) => ({...p, id: p.id || Date.now() + i}));
                                        pushHistory();
                                        setStockPoints(newPts);
                                        setActiveTab('editor');
                                        setEditMode('stock');
                                        setParams(p => ({...p, stockMode: 'casting'}));
                                    }}
                                    onUpdateParams={(newParams) => {
                                        pushHistory();
                                        setParams(prev => ({...prev, ...newParams}));
                                        setActiveTab('params');
                                    }}
                                    onUpdateGCode={(code) => {
                                        setManualGCode(code);
                                        setUseManualCode(true);
                                        setActiveTab('editor'); 
                                    }}
                                    theme={theme}
                                />
                            )}
                             {activeTab === 'import' && (
                                <div className="flex flex-col h-full">
                                    <textarea className={`flex-1 border p-2 font-mono text-xs mb-2 ${theme==='dark'?'bg-gray-800 text-white border-gray-600':'bg-white text-gray-900 border-gray-300'}`} value={gCodeInput} onChange={e=>setGCodeInput(e.target.value)} placeholder="G1 X... Z..."></textarea>
                                    <button onClick={parseGCode} className="bg-green-600 text-white py-2 rounded">Import</button>
                                </div>
                            )}
                        </div>
                    </div>

                     <div className={`${mobileTab === 'preview' ? 'flex' : 'hidden'} md:flex flex-1 flex-col relative pb-20 md:pb-0 ${theme === 'dark' ? 'bg-gray-900' : 'bg-gray-50'}`}>
                        <div className="absolute top-4 right-4 z-10 flex gap-2">
                            <div className="bg-white p-1 rounded shadow flex gap-1 items-center">
                                <button onClick={toggleSimulation} className={`p-1 rounded hover:bg-green-100 ${simRunning ? 'text-green-600' : 'text-gray-600'}`} title={simRunning ? "Pauza" : "Spustit"}>
                                    {simRunning ? <IconPause /> : <IconPlay />}
                                </button>
                                <button onClick={stopSimulation} className="p-1 rounded hover:bg-red-100 text-gray-600" title="Stop"><IconStop /></button>
                            </div>
                            
                            <div className="bg-white p-1 rounded shadow flex gap-1 items-center">
                                <button 
                                    onClick={() => setAddPointMode(!addPointMode)} 
                                    className={`p-1 rounded hover:bg-blue-100 ${addPointMode ? 'text-blue-600 bg-blue-50' : 'text-gray-600'}`} 
                                    title="Vlo≈æit za bod"
                                >
                                    <IconPlusCircle />
                                </button>
                            </div>

                            <button onClick={fitView} className="bg-white p-2 rounded shadow text-gray-700 hover:text-blue-600" title="Centrovat pohled"><IconTarget /></button>
                        </div>
                        <div ref={containerRef} className={`flex-1 overflow-hidden relative canvas-container`}
                             onWheel={handleWheel} 
                             onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}
                             onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd}>
                            <canvas ref={canvasRef} className="block" />
                        </div>
                        <div ref={codeContainerRef} className={`h-48 border-t flex flex-col ${theme === 'dark' ? 'bg-gray-950 border-gray-700' : 'bg-white border-gray-300'}`}>
                             {/* Control Bar for Code View */}
                             <div className={`p-1 border-b flex justify-between items-center text-xs ${theme === 'dark' ? 'bg-gray-900 border-gray-700' : 'bg-gray-100 border-gray-300'}`}>
                                 <span className="font-bold px-2 text-gray-500">G-CODE</span>
                                 <div className="flex gap-4">
                                     {calculatedData.estimatedTimeSeconds > 0 && (
                                         <div className="flex items-center gap-1 text-gray-500" title="Odhadovan√Ω ƒças obr√°bƒõn√≠">
                                             <IconClock /> <span>{Math.floor(calculatedData.estimatedTimeSeconds/60)}m {Math.round(calculatedData.estimatedTimeSeconds%60)}s</span>
                                             <span className="opacity-50">| {(calculatedData.totalPathLength/1000).toFixed(2)}m</span>
                                         </div>
                                     )}
                                     {useManualCode && manualGCode.includes("CYCLE") && (
                                         <span className="text-orange-500 font-bold flex items-center gap-1"><IconWarning /> Simul√°tor neum√≠ cykly (jen G0/G1)</span>
                                     )}
                                 </div>
                                 <div className="flex gap-2">
                                     <button 
                                        onClick={() => setUseManualCode(false)} 
                                        className={`px-2 py-0.5 rounded transition-colors ${!useManualCode ? (theme==='dark'?'bg-blue-600 text-white':'bg-blue-600 text-white') : 'text-gray-500 hover:bg-gray-200'}`}
                                     >
                                         Auto (Gener√°tor)
                                     </button>
                                     <button 
                                        onClick={() => { setUseManualCode(true); if(!manualGCode) setManualGCode(generatedCode.map(l=>l.text).join('\n')); }} 
                                        className={`px-2 py-0.5 rounded transition-colors ${useManualCode ? 'bg-purple-600 text-white' : 'text-gray-500 hover:bg-gray-200'}`}
                                     >
                                         <span className="flex items-center gap-1"><IconTerminal /> Manu√°l / AI</span>
                                     </button>
                                 </div>
                             </div>

                             {useManualCode ? (
                                 <textarea 
                                    className={`flex-1 w-full p-2 font-mono text-xs resize-none focus:outline-none ${theme === 'dark' ? 'bg-gray-950 text-green-400' : 'bg-white text-gray-800'}`}
                                    value={manualGCode}
                                    onChange={(e) => setManualGCode(e.target.value)}
                                    spellCheck={false}
                                    placeholder="Zde m≈Ø≈æete ps√°t vlastn√≠ G-k√≥d nebo nechat AI vygenerovat program..."
                                 />
                             ) : (
                                 <div className="flex-1 overflow-y-auto font-mono text-xs p-2">
                                    {generatedCode.map((line, idx) => (
                                        <div 
                                            key={idx} 
                                            onClick={() => handleLineClick(line.simIdx)}
                                            className={`code-line whitespace-pre px-2 py-0.5 cursor-pointer ${idx === highlightIndex ? 'active' : ''} ${theme === 'dark' ? 'text-green-300' : 'text-gray-800'}`}
                                        >
                                            {line.text}
                                        </div>
                                    ))}
                                 </div>
                             )}
                        </div>
                    </div>

                    <div className="md:hidden fixed bottom-0 left-0 right-0 h-16 bg-white border-t border-gray-200 flex z-50 safe-pb dark:bg-gray-900 dark:border-gray-700">
                        <button onClick={() => setMobileTab('editor')} className={`flex-1 flex flex-col items-center justify-center ${mobileTab==='editor' ? 'text-blue-600' : 'text-gray-500'}`}>
                            <IconEdit />
                            <span className="text-xs font-bold mt-1">Editor</span>
                        </button>
                        <button onClick={() => setMobileTab('preview')} className={`flex-1 flex flex-col items-center justify-center ${mobileTab==='preview' ? 'text-blue-600' : 'text-gray-500'}`}>
                            <IconEye />
                            <span className="text-xs font-bold mt-1">N√°hled</span>
                        </button>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
=======

<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gener√°tor CAM pro Sinumerik 840D (Auto-Trim) - Full AI Control</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- jsPDF pro generov√°n√≠ PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- Gemini SDK Import Map -->
    <script type="importmap">
    {
      "imports": {
        "@google/genai": "https://esm.run/@google/genai"
      }
    }
    </script>

    <style>
        body { overscroll-behavior: none; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #9ca3af; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .canvas-container { cursor: crosshair; touch-action: none; background-image: radial-gradient(#ccc 1px, transparent 1px); background-size: 20px 20px; }
        .dark .canvas-container { background-image: radial-gradient(#333 1px, transparent 1px); }
        .safe-pb { padding-bottom: env(safe-area-inset-bottom); }
        /* Styl pro aktivn√≠ ≈ô√°dek k√≥du */
        .code-line.active { background-color: rgba(59, 130, 246, 0.2); font-weight: bold; border-left: 3px solid #3b82f6; }
        .dark .code-line.active { background-color: rgba(59, 130, 246, 0.3); border-left: 3px solid #60a5fa; }
        
        /* Animace pro mikrofon */
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        .mic-active { animation: pulse-red 1.5s infinite; background-color: #ef4444 !important; border-color: #ef4444 !important; color: white !important; }
    </style>
</head>
<body class="h-[100dvh] w-screen overflow-hidden flex flex-col font-sans transition-colors duration-300">

    <div id="root" class="h-full w-full"></div>

    <script type="text/babel" data-type="module">
        import { GoogleGenAI } from "@google/genai";

        // --- POLYFILL PRO PROCESS.ENV & API KEY MANAGEMENT ---
        const CUSTOM_KEY_STORAGE = 'sinumerik_custom_api_key';
        const KEY_HISTORY_STORAGE = 'sinumerik_api_key_history';
        
        // P≈òEDVYPLNƒöN√ù KL√çƒå (Bezpeƒçnostn√≠ riziko na ve≈ôejn√©m GitHubu!)
        // U≈æivatel si p≈ô√°l tento kl√≠ƒç p≈ôedvyplnit.
        const HARDCODED_SUFFIX = "SyCLBHN-IxCTKc0tXDsdp7T0TTj81FlnKlI";
        const DEFAULT_FULL_KEY = "AIza" + HARDCODED_SUFFIX;
        
        // Inicializace: Zkus√≠me naƒç√≠st vlastn√≠ kl√≠ƒç z localStorage, jinak pou≈æijeme hardcoded default
        const initialKey = localStorage.getItem(CUSTOM_KEY_STORAGE) || DEFAULT_FULL_KEY;

        if (typeof process === "undefined") {
            window.process = { env: { API_KEY: initialKey } };
        } else if (!process.env.API_KEY) {
             process.env.API_KEY = initialKey;
        }
        
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // --- ICONS ---
        const IconTrash = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;
        const IconPlus = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>;
        const IconSun = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>;
        const IconMoon = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>;
        const IconEdit = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path></svg>;
        const IconBox = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>;
        const IconMagic = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><path d="m12 2 2.5 5.5L20 9l-4 3.5L17.5 18 12 15l-5.5 3L8 12.5 4 9l5.5-1.5L12 2z"></path></svg>;
        const IconClipboard = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>;
        const IconInsert = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>;
        const IconTarget = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line></svg>;
        const IconEye = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>;
        const IconPlay = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M5 3l14 9-14 9V3z"/></svg>;
        const IconPause = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>;
        const IconStop = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="6" width="12" height="12" /></svg>;
        const IconDownload = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>;
        const IconUpload = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>;
        const IconArrowRight = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>;
        const IconArrowDown = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></svg>;
        const IconWarning = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ef4444" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>;
        const IconRefresh = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>;
        const IconUndo = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 7v6h6"></path><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"></path></svg>;
        const IconRedo = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 7v6h-6"></path><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13"></path></svg>;
        const IconFileText = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>;
        const IconPlusCircle = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>;
        const IconSpark = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z"/><path d="M20 3v4"/><path d="M22 5h-4"/><path d="M4 17v2"/><path d="M5 18H3"/></svg>;
        const IconVoiceChat = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/><line x1="9" y1="10" x2="15" y2="10"/><line x1="12" y1="7" x2="12" y2="13"/></svg>;
        const IconKey = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path></svg>;
        const IconMicrophone = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>;
        const IconClock = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>;
        const IconDatabase = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path></svg>;

        // NEW ICONS FOR FEATURES
        const IconDocumentScanner = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 7V5a2 2 0 0 1 2-2h2"/><path d="M17 3h2a2 2 0 0 1 2-2v2"/><path d="M21 17v2a2 2 0 0 1-2 2h-2"/><path d="M7 21H5a2 2 0 0 1-2-2v-2"/><rect x="7" y="7" width="10" height="10" rx="1"/></svg>;
        const IconBolt = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M11 21l-1-11H4l11-10 1 11h6L11 21z"/></svg>;
        const IconNetworkIntelligence = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line></svg>;
        const IconX = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;
        const IconSave = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>;
        const IconBookmark = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>;
        const IconTerminal = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line></svg>;

        // Shape Icons for Buttons
        const IconShapeCircle = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none"><circle cx="12" cy="12" r="10"/></svg>;
        const IconShapePolygon = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M3 3h18v18H3z"/></svg>;

        // --- CONSTANTS ---
        const MATERIALS = {
            'Ocel 11 373 (S235)': { speed: 200, feed: 0.25, depth: 2.5, name: "Ocel (Mƒõkk√°)" },
            'Ocel 14 220 (Cement)': { speed: 160, feed: 0.2, depth: 1.5, name: "Ocel (Tvrd≈°√≠)" },
            'Nerez 17 240 (304)': { speed: 120, feed: 0.15, depth: 1.0, name: "Nerez" },
            'Hlin√≠k (AlSi)': { speed: 400, feed: 0.35, depth: 4.0, name: "Hlin√≠k" },
            'Mosaz': { speed: 300, feed: 0.2, depth: 2.5, name: "Mosaz" },
            'Plast (POM)': { speed: 500, feed: 0.4, depth: 5.0, name: "Plast" }
        };

        // --- COMPONENTS ---
        
        const SmartInput = ({ value, onValueChange, className, placeholder, type = "text", step }) => {
            const [localVal, setLocalVal] = useState(value);
            const [isDirty, setIsDirty] = useState(false);

            useEffect(() => { setLocalVal(value); }, [value]);

            useEffect(() => {
                if (!isDirty) return;
                const handler = setTimeout(() => { onValueChange(localVal); setIsDirty(false); }, 600); 
                return () => clearTimeout(handler);
            }, [localVal, isDirty, onValueChange]);

            const handleChange = (e) => { setLocalVal(e.target.value); setIsDirty(true); };
            const handleBlur = () => { if (isDirty) { onValueChange(localVal); setIsDirty(false); } };
            const handleKeyDown = (e) => { if (e.key === 'Enter') { if (isDirty) { onValueChange(localVal); setIsDirty(false); } e.target.blur(); } };

            return (
                <input type={type} className={className} placeholder={placeholder} value={localVal} onChange={handleChange} onBlur={handleBlur} onKeyDown={handleKeyDown} step={step} />
            );
        };
        
        const AiAssistant = ({ contourPoints, stockPoints, params, onUpdateContour, onUpdateStock, onUpdateParams, onUpdateGCode, theme }) => {
            // --- AI HISTORY LOGIC ---
            const CHAT_STORAGE_KEY = 'sinumerik_chat_history_v1';
            
            const [messages, setMessages] = useState(() => {
                const saved = localStorage.getItem(CHAT_STORAGE_KEY);
                if (saved) {
                    try { return JSON.parse(saved); } catch(e) {}
                }
                return [{ role: 'model', text: 'Dobr√Ω den, jsem v√°≈° AI asistent pro CNC programov√°n√≠. S ƒç√≠m v√°m mohu pomoci?' }];
            });

            // Save history on change
            useEffect(() => {
                localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(messages));
            }, [messages]);

            const clearHistory = () => {
                if(confirm("Opravdu chcete vymazat celou historii chatu?")) {
                    const resetState = [{ role: 'model', text: 'Historie byla vymaz√°na. Jak mohu pomoci d√°le?' }];
                    setMessages(resetState);
                    localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(resetState));
                }
            };
            
            const [input, setInput] = useState('');
            const [loading, setLoading] = useState(false);
            const [mode, setMode] = useState('normal'); 
            const [image, setImage] = useState(null); 
            const [savedPrompts, setSavedPrompts] = useState([]);
            const [showPrompts, setShowPrompts] = useState(false);
            const [isListening, setIsListening] = useState(false);
            
            // API Key Management State
            const [showApiKeyInput, setShowApiKeyInput] = useState(false);
            
            // LOGIKA PRO ROZDƒöLEN√ù KL√çƒå (Split Key Logic)
            const [apiKeySuffix, setApiKeySuffix] = useState(() => {
                // Naƒçteme cel√Ω kl√≠ƒç z √∫lo≈æi≈°tƒõ
                const fullKey = localStorage.getItem('sinumerik_custom_api_key') || '';
                // Pokud zaƒç√≠n√° na AIza, vezmeme zbytek.
                if (fullKey.startsWith('AIza')) {
                    return fullKey.substring(4); // Od≈ô√≠zneme prvn√≠ 4 znaky
                }
                // P≈òEDVYPLNƒöN√ù KL√çƒå NA ≈Ω√ÅDOST
                return HARDCODED_SUFFIX;
            });

            // API KEY HISTORY
            const [keyHistory, setKeyHistory] = useState([]);

            useEffect(() => {
                try {
                    const hist = JSON.parse(localStorage.getItem(KEY_HISTORY_STORAGE) || '[]');
                    setKeyHistory(hist);
                } catch(e) {}
            }, []);

            const updateKeyHistory = (newSuffix) => {
                const cleanSuffix = newSuffix.trim();
                const newHist = [cleanSuffix, ...keyHistory.filter(k => k !== cleanSuffix)].slice(0, 5); 
                setKeyHistory(newHist);
                localStorage.setItem(KEY_HISTORY_STORAGE, JSON.stringify(newHist));
            };

            const deleteFromHistory = (val) => {
                const newHist = keyHistory.filter(k => k !== val);
                setKeyHistory(newHist);
                localStorage.setItem(KEY_HISTORY_STORAGE, JSON.stringify(newHist));
            };

            const scrollRef = useRef(null);
            const fileInputRef = useRef(null);
            const importPromptsInputRef = useRef(null);
            const PROMPTS_KEY = 'sinumerik_cam_ai_prompts';
            
            // Recognition ref
            const recognitionRef = useRef(null);

            useEffect(() => {
                if(scrollRef.current) scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
            }, [messages]);

            useEffect(() => {
                const saved = localStorage.getItem(PROMPTS_KEY);
                if (saved) {
                    try { setSavedPrompts(JSON.parse(saved)); } catch(e) {}
                }
            }, []);

            const toggleListening = () => {
                if (isListening) {
                    if (recognitionRef.current) recognitionRef.current.stop();
                    setIsListening(false);
                } else {
                    if (!window.webkitSpeechRecognition && !window.SpeechRecognition) {
                        alert("V√°≈° prohl√≠≈æeƒç nepodporuje rozpozn√°v√°n√≠ hlasu.");
                        return;
                    }
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    const recognition = new SpeechRecognition();
                    recognition.lang = 'cs-CZ';
                    recognition.interimResults = false;
                    recognition.maxAlternatives = 1;

                    recognition.onstart = () => setIsListening(true);
                    recognition.onend = () => setIsListening(false);
                    recognition.onerror = (event) => { 
                        console.error(event.error); 
                        setIsListening(false); 
                        if (event.error === 'not-allowed') {
                             alert("P≈ô√≠stup k mikrofonu byl zam√≠tnut. Povolte pros√≠m mikrofon v nastaven√≠ prohl√≠≈æeƒçe.");
                        }
                    };
                    
                    recognition.onresult = (event) => {
                        const transcript = event.results[0][0].transcript;
                        setInput(prev => prev + (prev ? ' ' : '') + transcript);
                    };

                    recognitionRef.current = recognition;
                    recognition.start();
                }
            };

            const handleSaveApiKey = (overrideSuffix = null) => {
                const suffix = (typeof overrideSuffix === 'string' ? overrideSuffix : apiKeySuffix).trim();
                
                // P≈ô√≠pad 1: Maz√°n√≠ kl√≠ƒçe (pokud je pole pr√°zdn√©)
                if (!suffix) {
                    if(confirm("Opravdu chcete smazat ulo≈æen√Ω API kl√≠ƒç?")) {
                        localStorage.removeItem('sinumerik_custom_api_key');
                        if(window.process && window.process.env) window.process.env.API_KEY = "";
                        alert("üóëÔ∏è Kl√≠ƒç byl odstranƒõn.");
                        setShowApiKeyInput(false);
                    }
                    return;
                }

                // P≈ô√≠pad 2: Ukl√°d√°n√≠ kl√≠ƒçe s validac√≠
                if (suffix.length < 20) { 
                    alert("‚ùå ODM√çTNUTO: Zadan√Ω kl√≠ƒç se zd√° b√Ωt neplatn√Ω nebo p≈ô√≠li≈° kr√°tk√Ω.");
                    return;
                }

                try {
                    // Spoj√≠me fixn√≠ prefix a u≈æivatelsk√Ω suffix
                    const fullKey = "AIza" + suffix;
                    localStorage.setItem('sinumerik_custom_api_key', fullKey);
                    
                    // Nastav√≠me do prost≈ôed√≠ pro okam≈æit√© pou≈æit√≠
                    if(window.process && window.process.env) window.process.env.API_KEY = fullKey;
                    
                    // Ulo≈æit do historie
                    updateKeyHistory(suffix);
                    
                    // POTVRZOVAC√ç OKNO - P≈òIJET√ç
                    alert("‚úÖ P≈òIJATO: API kl√≠ƒç byl √∫spƒõ≈°nƒõ ulo≈æen a aktivov√°n.\n\nNyn√≠ m≈Ø≈æete vyu≈æ√≠vat AI asistenta.");
                    setShowApiKeyInput(false);
                } catch(e) {
                     alert("‚ùå Chyba p≈ôi ukl√°d√°n√≠ kl√≠ƒçe: " + e.message);
                }
            };

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setImage(reader.result);
                    };
                    reader.readAsDataURL(file);
                }
            };

            const removeImage = () => {
                setImage(null);
                if (fileInputRef.current) fileInputRef.current.value = '';
            };

            const handleSavePrompt = () => {
                if (!input.trim()) return;
                const newPrompt = { id: Date.now(), text: input.trim() };
                const updated = [newPrompt, ...savedPrompts];
                setSavedPrompts(updated);
                localStorage.setItem(PROMPTS_KEY, JSON.stringify(updated));
            };

            const handleDeletePrompt = (id) => {
                const updated = savedPrompts.filter(p => p.id !== id);
                setSavedPrompts(updated);
                localStorage.setItem(PROMPTS_KEY, JSON.stringify(updated));
            };
            
            const handleExportPrompts = () => {
                const data = JSON.stringify(savedPrompts, null, 2);
                const blob = new Blob([data], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'prompty_zaloha.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            const handleImportPrompts = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const imported = JSON.parse(ev.target.result);
                        if (Array.isArray(imported)) {
                            const newPrompts = imported.map(p => ({
                                id: Date.now() + Math.random(),
                                text: p.text || p 
                            }));
                            const updated = [...savedPrompts, ...newPrompts];
                            setSavedPrompts(updated);
                            localStorage.setItem(PROMPTS_KEY, JSON.stringify(updated));
                            alert("Prompty √∫spƒõ≈°nƒõ importov√°ny.");
                        } else {
                            alert("Neplatn√Ω form√°t souboru.");
                        }
                    } catch (err) {
                        alert("Chyba p≈ôi ƒçten√≠ souboru: " + err.message);
                    }
                };
                reader.readAsText(file);
                e.target.value = ''; 
            };

            const handleLoadPrompt = (text) => {
                setInput(text);
                setShowPrompts(false);
            };
            
            const handleQuickAction = (actionText) => {
                setInput(actionText);
                setTimeout(() => handleSend(actionText), 100);
            };

            const handleSend = async (overrideInput = null) => {
                const textToSend = overrideInput || input;
                if (!textToSend.trim() && !image) return;
                
                // Kontrola existence kl√≠ƒçe p≈ôed odesl√°n√≠m
                if (!process.env.API_KEY || process.env.API_KEY.trim() === "") {
                    setShowApiKeyInput(true);
                    setMessages(prev => [...prev, { role: 'model', text: "‚ö†Ô∏è Pro komunikaci s AI je nutn√© zadat API kl√≠ƒç. Otev≈ôel jsem pro v√°s nastaven√≠ naho≈ôe. Zadejte pros√≠m zbytek va≈°eho Google Gemini API kl√≠ƒçe." }]);
                    return;
                }
                
                const userMsg = { role: 'user', text: textToSend, image: image };
                setMessages(prev => [...prev, userMsg]);
                setInput('');
                setImage(null);
                if (fileInputRef.current) fileInputRef.current.value = '';
                setLoading(true);

                try {
                    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
                    
                    const systemContext = `
                        Current CNC Configuration:
                        - Machine: ${params.machineType} (${params.machineStructure})
                        - Control: ${params.controlSystem}
                        - Params: ${JSON.stringify(params, null, 2)}
                        - Contour Points: ${JSON.stringify(contourPoints)}
                        - Stock Points: ${JSON.stringify(stockPoints)}
                    `;

                    const systemInstruction = `Jsi expertn√≠ AI asistent pro aplikaci 'Sinumerik CAM Generator'.
                    
                    TAH√ÅK PARAMETR≈Æ (CO M≈Æ≈ΩE≈† MƒöNIT V "params"):
                    - toolRadius (ƒç√≠slo): R√°dius ≈°piƒçky n√°stroje (nap≈ô. 0.4, 0.8). KRITICK√â PRO KOREKCE!
                    - toolName (≈ôetƒõzec): N√°zev n√°stroje (nap≈ô. "N≈Æ≈Ω").
                    - speed (ƒç√≠slo): ≈òezn√° rychlost (m/min).
                    - feed (ƒç√≠slo): Posuv (mm/ot).
                    - depthOfCut (ƒç√≠slo): Hloubka t≈ô√≠sky (ap).
                    - roughingStrategy (≈ôetƒõzec): 'longitudinal' (pod√©lnƒõ) / 'face' (ƒçelnƒõ).
                    - doFinishing (bool): Zda generovat dokonƒçovac√≠ t≈ô√≠sku.
                    - allowanceX, allowanceZ (ƒç√≠sla): P≈ô√≠davky na dokonƒçen√≠.
                    - machineType (≈ôetƒõzec): Nap≈ô. 'LIMS=2000'.
                    - controlSystem (≈ôetƒõzec): 'sinumerik' / 'fanuc' / 'heidenhain'.
                    - stockMode, stockDiameter, stockLength... (parametry polotovaru).

                    PRAVIDLO PRO KOREKCI R√ÅDIUSU (TOOL RADIUS COMPENSATION):
                    V parametrech je nastaven 'toolRadius' (aktu√°lnƒõ: ${params.toolRadius}).
                    Pokud generuje≈° G-k√≥d pro obroben√≠ kontury na ƒçisto:
                    1. MUS√ç≈† pou≈æ√≠t G41 (vlevo) nebo G42 (vpravo) podle smƒõru obr√°bƒõn√≠.
                    2. NEBO pokud generuje≈° body ruƒçnƒõ, mus√≠≈° sou≈ôadnice posunout o r√°dius a vektorovƒõ p≈ôipoƒç√≠tat korekci (ekvidistanta).
                    3. NIKDY nejeƒè st≈ôedem n√°stroje p≈ô√≠mo po sou≈ôadnic√≠ch kontury, pokud to nen√≠ z√°mƒõr (nap≈ô. hrubov√°n√≠ s p≈ô√≠davkem vƒõt≈°√≠m ne≈æ r√°dius).

                    HLAVN√ç OMEZEN√ç APLIKACE A SIMUL√ÅTORU:
                    1. TOTO NEN√ç PLNOHODNOTN√ù CAD/CAM. Je to lehk√Ω webov√Ω n√°stroj pro generov√°n√≠ G-k√≥du soustru≈æen√≠.
                    2. SIMUL√ÅTOR: Vykresluje pouze explicitn√≠ sou≈ôadnice (G0/G1/G2/G3). NEUM√ç simulovat/vykreslit vysok√© cykly (jako CYCLE95, G71, G72). Pokud vygeneruje≈° k√≥d s cykly, simul√°tor uk√°≈æe pouze ƒç√°ru od startu do konce, nikoliv odeb√≠r√°n√≠ materi√°lu.
                    3. GENER√ÅTOR: Pokud chce u≈æivatel zmƒõnit parametry, VRA≈§ JSON:
                       - Zmƒõna kontury: {"type": "contour", "points": [{"type": "G1", "x": 20, "z": -10, "r": 0, "mode": "ABS"}, ...]}
                       - Zmƒõna polotovaru: {"type": "stock", "points": [...]}
                       - Zmƒõna parametr≈Ø: {"type": "params", "data": {"feed": 0.2, "speed": 150, "toolName": "N≈Æ≈Ω", "roughingStrategy": "face"}}
                       Dostupn√© parametry: machineType, toolName, speed, feed, depthOfCut, roughingStrategy ('longitudinal'/'face'), stockMode ('cylinder'/'casting').

                    JAZYK: Odpov√≠dej ƒçesky, struƒçnƒõ a technicky p≈ôesnƒõ. Buƒè n√°pomocn√Ω oper√°torovi CNC.
                    `;

                    let modelName = "gemini-2.5-flash"; 
                    let requestConfig = {
                        systemInstruction: { parts: [{ text: systemInstruction }] }
                    };

                    if (mode === 'fast' && !userMsg.image) {
                        modelName = "gemini-2.5-flash-lite-latest";
                    } else if (mode === 'thinking') {
                        modelName = "gemini-3-pro-preview"; 
                        requestConfig.thinkingConfig = { thinkingBudget: 32768 };
                    }
                    if (userMsg.image) {
                        modelName = "gemini-2.5-flash"; 
                    }

                    const history = messages.map(m => {
                        const parts = [];
                        if (m.image) {
                             parts.push({ text: "[User uploaded an image]" });
                        }
                        if (m.text) parts.push({ text: m.text });
                        return { role: m.role, parts };
                    });

                    const currentParts = [];
                    if (userMsg.image) {
                        const base64Data = userMsg.image.split(',')[1];
                        const mimeType = userMsg.image.split(';')[0].split(':')[1];
                        currentParts.push({ inlineData: { mimeType, data: base64Data } });
                    }
                    currentParts.push({ text: systemContext + "\n\nUser Request: " + userMsg.text });

                    const contents = [
                        ...history,
                        { role: 'user', parts: currentParts }
                    ];

                    let text = "";
                    
                    try {
                        const result = await ai.models.generateContent({
                            model: modelName,
                            contents: contents,
                            config: requestConfig
                        });
                        text = result.text;
                    } catch (retryError) {
                        // Fallback pro chyby p≈ôet√≠≈æen√≠ nebo kv√≥ty
                        if (retryError.message.includes("429") || retryError.message.includes("503") || retryError.status === 429 || retryError.status === 503) {
                             console.warn("Model error, switching to Flash:", retryError);
                             setMessages(prev => [...prev, { role: 'model', text: "‚ö†Ô∏è Model 'Pro' je moment√°lnƒõ p≈ôet√≠≈æen nebo do≈°lo k vyƒçerp√°n√≠ kv√≥ty. P≈ôep√≠n√°m na 'Flash' model a zkou≈°√≠m to znovu..." }]);
                             
                             // Odstranit thinking config pro fallback
                             const fallbackConfig = { ...requestConfig };
                             delete fallbackConfig.thinkingConfig;
                             
                             const fallbackResult = await ai.models.generateContent({
                                model: "gemini-2.5-flash",
                                contents: contents,
                                config: fallbackConfig
                            });
                            text = fallbackResult.text;
                        } else {
                            throw retryError;
                        }
                    }
                    
                    let suggestedPoints = null;
                    let suggestedStock = null;
                    let suggestedParams = null;
                    let suggestedCode = null;

                    try {
                        const jsonMatch = text.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.type === 'contour') suggestedPoints = parsed.points;
                            else if (parsed.type === 'stock') suggestedStock = parsed.points;
                            else if (parsed.type === 'params') suggestedParams = parsed.data;
                            else if (Array.isArray(parsed) && parsed[0].type) suggestedPoints = parsed; 
                        }
                    } catch (e) {}

                    const codeLines = text.split('\n').filter(l => /^[N]?\d*\s*[GM]\d+/.test(l.trim()));
                    if (codeLines.length > 3) {
                         const codeBlockMatch = text.match(/```(?:gcode|nc)?([\s\S]*?)```/i);
                         if (codeBlockMatch) {
                             suggestedCode = codeBlockMatch[1].trim();
                         } else {
                             suggestedCode = codeLines.join('\n');
                         }
                    }

                    setMessages(prev => [...prev, { role: 'model', text: text, suggestedPoints, suggestedStock, suggestedParams, suggestedCode }]);

                } catch (error) {
                    console.error("AI Error:", error);
                    let errMsg = "Chyba p≈ôi komunikaci s AI: " + error.message;
                    
                    // Detekce probl√©m≈Ø s kl√≠ƒçem (403 Permission Denied / Referer blocked)
                    if (error.message.includes("403") || error.message.includes("referer") || error.message.includes("blocked") || error.message.includes("API_KEY")) {
                         errMsg = "‚ö†Ô∏è P≈ô√≠stup k AI byl zam√≠tnut (Error 403). V√Ωchoz√≠ API kl√≠ƒç nefunguje ve va≈°em prost≈ôed√≠ (pravdƒõpodobnƒõ kv≈Øli omezen√≠ dom√©ny). Pros√≠m zadejte sv≈Øj vlastn√≠ Google Gemini API kl√≠ƒç v panelu naho≈ôe.";
                         setShowApiKeyInput(true);
                    }
                    
                    setMessages(prev => [...prev, { role: 'model', text: errMsg }]);
                }
                setLoading(false);
            };

            const quickActions = [
                "Srazit v≈°echny hrany 1mm",
                "Zaoblit rohy R2",
                "Zmƒõnit na hlin√≠k (vysok√© ot√°ƒçky)",
                "Optimalizovat hrubov√°n√≠",
                "P≈ôidat dokonƒçovac√≠ p≈ô√≠davek 0.2mm"
            ];

            return (
                <div className="flex flex-col h-full relative">
                    
                    {/* API Key Panel - SPLIT INPUT */}
                    {showApiKeyInput && (
                        <div className={`p-4 border-b ${theme === 'dark' ? 'bg-gray-800 border-gray-700' : 'bg-gray-100 border-gray-200'}`}>
                            <label className="block text-xs font-bold mb-1 opacity-70">V√°≈° Google API Kl√≠ƒç</label>
                            <div className="flex gap-2 items-center">
                                {/* Prefix (Read-only) */}
                                <div className="flex flex-1 gap-0">
                                    <div className={`px-3 py-1 text-sm border border-r-0 rounded-l flex items-center select-none font-mono ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-gray-400' : 'bg-gray-200 border-gray-300 text-gray-600'}`}>
                                        AIza
                                    </div>
                                    <input 
                                        type="password" 
                                        value={apiKeySuffix} 
                                        onChange={(e) => setApiKeySuffix(e.target.value)} 
                                        placeholder="SyCLBHN-IxCT..." 
                                        className={`flex-1 border rounded-r px-2 py-1 text-sm focus:outline-none focus:ring-1 focus:ring-blue-500 font-mono ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300'}`}
                                    />
                                </div>
                                <button onClick={() => handleSaveApiKey()} className="bg-green-600 hover:bg-green-500 text-white px-3 py-1 rounded text-xs font-bold">Ulo≈æit</button>
                            </div>
                            <p className="text-[10px] mt-1 opacity-60">Zadejte pouze chybƒõj√≠c√≠ ƒç√°st kl√≠ƒçe (za "AIza"). Ulo≈æeno bezpeƒçnƒõ ve va≈°em prohl√≠≈æeƒçi.</p>
                            
                            {/* API KEY HISTORY LIST */}
                            {keyHistory.length > 0 && (
                                <div className="mt-3 border-t pt-2 dark:border-gray-700">
                                    <div className="text-[10px] uppercase font-bold opacity-50 mb-1">Historie kl√≠ƒç≈Ø (posledn√≠ch 5)</div>
                                    <div className="space-y-1">
                                        {keyHistory.map((k, i) => (
                                            <div key={i} className={`flex items-center justify-between p-1.5 rounded border text-xs ${theme === 'dark' ? 'bg-gray-700/50 border-gray-600' : 'bg-gray-50 border-gray-300'}`}>
                                                <span className="font-mono truncate max-w-[200px] opacity-70">...{k.slice(-10)}</span>
                                                <div className="flex gap-1">
                                                    <button 
                                                        onClick={() => { setApiKeySuffix(k); handleSaveApiKey(k); }} 
                                                        className={`px-2 py-0.5 rounded text-[10px] font-bold ${theme === 'dark' ? 'bg-blue-700 text-white hover:bg-blue-600' : 'bg-blue-100 text-blue-700 hover:bg-blue-200'}`}
                                                    >
                                                        Naƒç√≠st
                                                    </button>
                                                    <button 
                                                        onClick={() => deleteFromHistory(k)} 
                                                        className="px-2 py-0.5 rounded text-[10px] bg-red-100 text-red-600 hover:bg-red-200 dark:bg-red-900/30 dark:text-red-400"
                                                    >
                                                        Smazat
                                                    </button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    <div ref={scrollRef} className={`flex-1 overflow-y-auto p-4 space-y-4 ${theme === 'dark' ? 'bg-gray-800' : 'bg-gray-50'}`}>
                        {messages.map((msg, idx) => (
                            <div key={idx} className={`flex flex-col ${msg.role === 'user' ? 'items-end' : 'items-start'}`}>
                                <div className={`max-w-[85%] rounded-lg p-3 text-sm whitespace-pre-wrap ${
                                    msg.role === 'user' 
                                        ? (theme === 'dark' ? 'bg-blue-700 text-white' : 'bg-blue-600 text-white')
                                        : (theme === 'dark' ? 'bg-gray-700 text-gray-200' : 'bg-white border text-gray-800 shadow-sm')
                                }`}>
                                    {msg.image && (
                                        <div className="mb-2">
                                            <img src={msg.image} alt="Upload" className="max-w-full h-auto rounded border" style={{maxHeight: '150px'}} />
                                        </div>
                                    )}
                                    {msg.text}
                                </div>
                                {msg.suggestedPoints && (
                                    <button onClick={() => onUpdateContour(msg.suggestedPoints)} className="mt-2 text-xs bg-green-600 hover:bg-green-500 text-white py-1.5 px-3 rounded flex items-center gap-1 shadow-sm"><IconPlusCircle /> Aplikovat body kontury</button>
                                )}
                                {msg.suggestedStock && (
                                    <button onClick={() => onUpdateStock(msg.suggestedStock)} className="mt-2 text-xs bg-green-600 hover:bg-green-500 text-white py-1.5 px-3 rounded flex items-center gap-1 shadow-sm"><IconBox /> Aplikovat polotovar</button>
                                )}
                                {msg.suggestedParams && (
                                    <button onClick={() => onUpdateParams(msg.suggestedParams)} className="mt-2 text-xs bg-orange-600 hover:bg-orange-500 text-white py-1.5 px-3 rounded flex items-center gap-1 shadow-sm"><IconEdit /> Aktualizovat parametry</button>
                                )}
                                {msg.suggestedCode && (
                                    <button onClick={() => onUpdateGCode(msg.suggestedCode)} className="mt-2 text-xs bg-purple-600 hover:bg-purple-500 text-white py-1.5 px-3 rounded flex items-center gap-1 shadow-sm"><IconTerminal /> Pou≈æ√≠t tento G-K√≥d</button>
                                )}
                            </div>
                        ))}
                        {loading && (
                            <div className="flex items-start">
                                <div className={`max-w-[85%] rounded-lg p-3 text-sm ${theme === 'dark' ? 'bg-gray-700' : 'bg-white border shadow-sm'}`}>
                                    <div className="flex gap-1">
                                        <span className="animate-bounce">‚óè</span>
                                        <span className="animate-bounce delay-100">‚óè</span>
                                        <span className="animate-bounce delay-200">‚óè</span>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                    
                    {/* Saved Prompts Panel (LIBRARY) */}
                    {showPrompts && (
                        <div className={`absolute bottom-[80px] left-2 right-2 rounded-lg shadow-xl border z-20 max-h-80 overflow-y-auto ${theme === 'dark' ? 'bg-gray-800 border-gray-600' : 'bg-white border-gray-300'}`}>
                            <div className={`p-2 border-b flex justify-between items-center ${theme === 'dark' ? 'border-gray-700 bg-gray-900' : 'border-gray-200 bg-gray-100'}`}>
                                <span className="text-xs font-bold px-2">Knihovna prompt≈Ø</span>
                                <div className="flex gap-2">
                                     <button onClick={handleExportPrompts} title="Exportovat do .txt" className="p-1 hover:bg-gray-200 dark:hover:bg-gray-700 rounded text-blue-600"><IconDownload /></button>
                                     <button onClick={() => importPromptsInputRef.current?.click()} title="Importovat z .txt" className="p-1 hover:bg-gray-200 dark:hover:bg-gray-700 rounded text-green-600"><IconUpload /></button>
                                     <button onClick={() => setShowPrompts(false)} className="p-1 hover:bg-gray-200 dark:hover:bg-gray-700 rounded"><IconX /></button>
                                </div>
                                <input type="file" ref={importPromptsInputRef} onChange={handleImportPrompts} className="hidden" accept=".txt,.json" />
                            </div>
                            
                            {/* Pre-set Quick Actions */}
                            <div className={`p-2 border-b ${theme === 'dark' ? 'border-gray-700' : 'border-gray-100'}`}>
                                <div className="text-[10px] font-bold opacity-50 mb-2 uppercase px-1">P≈ôednastaven√© akce</div>
                                <div className="flex flex-wrap gap-2">
                                    {quickActions.map((action, i) => (
                                        <button 
                                            key={i}
                                            onClick={() => handleQuickAction(action)}
                                            className={`text-[10px] whitespace-nowrap px-2 py-1 rounded-full border transition-colors ${
                                                theme === 'dark' 
                                                ? 'bg-gray-700 border-gray-600 text-gray-300 hover:bg-gray-600' 
                                                : 'bg-blue-50 border-blue-100 text-blue-600 hover:bg-blue-100'
                                            }`}
                                        >
                                            {action}
                                        </button>
                                    ))}
                                </div>
                            </div>

                            {/* User Saved Prompts */}
                            <div className="p-2 space-y-2">
                                <div className="text-[10px] font-bold opacity-50 mb-1 uppercase px-1">Va≈°e prompty</div>
                                {savedPrompts.length === 0 ? (
                                    <div className="text-xs text-gray-500 text-center p-4">≈Ω√°dn√© ulo≈æen√© prompty.</div>
                                ) : (
                                    savedPrompts.map(p => (
                                        <div key={p.id} className={`p-2 rounded border flex justify-between gap-2 items-start ${theme === 'dark' ? 'bg-gray-700 border-gray-600' : 'bg-gray-50 border-gray-200'}`}>
                                            <div 
                                                className="text-xs flex-1 cursor-pointer hover:underline line-clamp-2"
                                                onClick={() => handleLoadPrompt(p.text)}
                                            >
                                                {p.text}
                                            </div>
                                            <button onClick={() => handleDeletePrompt(p.id)} className="text-red-500 hover:text-red-700"><IconTrash /></button>
                                        </div>
                                    ))
                                )}
                            </div>
                        </div>
                    )}
                    
                    <div className={`p-3 border-t flex flex-col gap-2 ${theme === 'dark' ? 'bg-gray-900 border-gray-700' : 'bg-white border-gray-200'}`}>
                        <div className="flex items-center gap-2">
                            <input type="file" accept="image/*" ref={fileInputRef} onChange={handleFileChange} className="hidden" />
                            <button onClick={() => fileInputRef.current?.click()} className={`p-1.5 rounded transition-colors ${image ? 'bg-blue-100 text-blue-600' : 'text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800 dark:text-gray-400'}`} title="Nahr√°t obr√°zek"><IconDocumentScanner /></button>
                            <div className="h-4 w-px bg-gray-300 dark:bg-gray-700 mx-1"></div>
                            
                            {/* API Key Toggle Button */}
                            <button onClick={() => setShowApiKeyInput(!showApiKeyInput)} className={`flex items-center gap-1 px-2 py-1 rounded text-xs font-bold transition-colors ${showApiKeyInput ? 'bg-blue-100 text-blue-700' : 'text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800'}`} title="Nastavit API Kl√≠ƒç">
                                <IconKey />
                            </button>
                            
                            {/* Reset History Button */}
                            <button onClick={clearHistory} className="flex items-center gap-1 px-2 py-1 rounded text-xs font-bold transition-colors text-red-500 hover:bg-red-100 dark:hover:bg-red-900/30" title="Vymazat historii">
                                <IconTrash />
                            </button>

                            <button onClick={() => setMode(mode === 'fast' ? 'normal' : 'fast')} className={`flex items-center gap-1 px-2 py-1 rounded text-xs font-bold transition-colors ${mode === 'fast' ? 'bg-yellow-100 text-yellow-700 border border-yellow-200' : 'text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800'}`} title="Rychl√° odpovƒõƒè"><IconBolt /> {mode === 'fast' && 'Fast'}</button>
                            <button onClick={() => setMode(mode === 'thinking' ? 'normal' : 'thinking')} className={`flex items-center gap-1 px-2 py-1 rounded text-xs font-bold transition-colors ${mode === 'thinking' ? 'bg-purple-100 text-purple-700 border border-purple-200' : 'text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800'}`} title="Thinking Mode"><IconNetworkIntelligence /> {mode === 'thinking' && 'Thinking'}</button>
                            <div className="flex-1"></div>
                            <button onClick={() => setShowPrompts(!showPrompts)} className={`flex items-center gap-1 px-2 py-1 rounded text-xs font-bold transition-colors ${showPrompts ? 'bg-blue-100 text-blue-700 border border-blue-200' : 'text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800'}`} title="Knihovna prompt≈Ø"><IconBookmark /> Knihovna</button>
                        </div>

                        {image && (
                            <div className="relative inline-block w-fit">
                                <img src={image} alt="Preview" className="h-16 rounded border shadow-sm" />
                                <button onClick={removeImage} className="absolute -top-1 -right-1 bg-red-500 text-white rounded-full p-0.5 shadow hover:bg-red-600"><IconX /></button>
                            </div>
                        )}

                        <div className="flex gap-2">
                            <textarea value={input} onChange={(e) => setInput(e.target.value)} onKeyDown={(e) => { if(e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); } }} placeholder={image ? "Popi≈°te tento v√Ωkres..." : "Zeptejte se na G-k√≥d..."} className={`flex-1 border rounded-lg p-2 text-sm resize-none h-12 focus:outline-none focus:ring-2 focus:ring-blue-500 ${theme === 'dark' ? 'bg-gray-800 border-gray-600 text-white' : 'bg-gray-50 border-gray-300 text-gray-900'}`} />
                            <div className="flex flex-col gap-1">
                                <button 
                                    onClick={handleSavePrompt} 
                                    disabled={!input.trim()} 
                                    className={`h-6 px-2 rounded font-bold flex items-center justify-center transition-colors ${!input.trim() ? 'bg-gray-300 text-gray-500' : 'bg-green-600 hover:bg-green-500 text-white'}`} 
                                    title="Ulo≈æit prompt"
                                >
                                    <IconSave />
                                </button>
                                <button 
                                    onClick={toggleListening}
                                    className={`h-6 px-2 rounded font-bold flex items-center justify-center transition-all ${isListening ? 'mic-active' : (theme === 'dark' ? 'bg-gray-700 text-gray-400' : 'bg-gray-200 text-gray-500')}`}
                                    title="Hlasov√© zad√°v√°n√≠"
                                >
                                    <IconMicrophone />
                                </button>
                                <button onClick={handleSend} disabled={loading || (!input.trim() && !image)} className={`h-6 px-4 rounded font-bold flex items-center justify-center transition-colors ${loading || (!input.trim() && !image) ? 'bg-gray-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-500 text-white'}`}><IconSpark /></button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- MATH HELPERS ---
        const dist = (p1, p2) => {
            if(!p1 || !p2) return 0;
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2));
        }

        const getNormal = (p1, p2) => {
            if (!p1 || !p2) return {x:0, z:0};
            const dx = p2.x - p1.x; const dz = p2.z - p1.z; const l = Math.sqrt(dx*dx + dz*dz);
            if (l===0 || isNaN(l)) return {x:0, z:0}; return { x: -dz/l, z: dx/l };
        };

        const intersectLines = (p1, p2, p3, p4) => {
            if (!p1 || !p2 || !p3 || !p4) return null;
            if (isNaN(p1.x) || isNaN(p1.z) || isNaN(p2.x) || isNaN(p2.z) || 
                isNaN(p3.x) || isNaN(p3.z) || isNaN(p4.x) || isNaN(p4.z)) return null;

            const d = (p1.x - p2.x) * (p3.z - p4.z) - (p1.z - p2.z) * (p3.x - p4.x);
            if (Math.abs(d) < 1e-9 || isNaN(d)) return null; 
            const t = ((p1.x - p3.x) * (p3.z - p4.z) - (p1.z - p3.z) * (p3.x - p4.x)) / d;
            
            const ix = p1.x + t * (p2.x - p1.x);
            const iz = p1.z + t * (p2.z - p1.z);
            if (isNaN(ix) || isNaN(iz)) return null;
            return { x: ix, z: iz };
        };

        const intersectLinesInfinite = (p1, p2, p3, p4) => {
            if (!p1 || !p2 || !p3 || !p4) return null;
            if (isNaN(p1.x) || isNaN(p1.z) || isNaN(p2.x) || isNaN(p2.z) || 
                isNaN(p3.x) || isNaN(p3.z) || isNaN(p4.x) || isNaN(p4.z)) return null;

            const d = (p1.x - p2.x) * (p3.z - p4.z) - (p1.z - p2.z) * (p3.x - p4.x);
            if (Math.abs(d) < 1e-9 || isNaN(d)) return null; 
            const t = ((p1.x - p3.x) * (p3.z - p4.z) - (p1.z - p3.z) * (p3.x - p4.x)) / d;
            const px = p1.x + t * (p2.x - p1.x);
            const pz = p1.z + t * (p2.z - p1.z);
            if(isNaN(px) || isNaN(pz)) return null;
            return { x: px, z: pz };
        };

        const intersectLineCircle = (p1, p2, center, r) => {
            if (!p1 || !p2 || !center) return null;
            const dx = p2.x - p1.x; const dz = p2.z - p1.z; const fx = p1.x - center.x; const fz = p1.z - center.z;
            const a = dx*dx + dz*dz; const b = 2*(fx*dx + fz*dz); const c = (fx*fx + fz*fz) - r*r;
            let discriminant = b*b - 4*a*c; if (discriminant < 0) return null;
            discriminant = Math.sqrt(discriminant);
            const t1 = (-b - discriminant) / (2*a); const t2 = (-b + discriminant) / (2*a);
            return [{ x: p1.x + t1*dx, z: p1.z + t1*dz }, { x: p1.x + t2*dx, z: p1.z + t2*dz }];
        };

        const getArcParams = (p1, p2, r, type) => {
            if (!p1 || !p2) return { error: true, cx: 0, cz: 0, r: 0 };
            const d2 = Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2); const d = Math.sqrt(d2);
            const isLongArc = r < 0; const absR = Math.abs(r); let safeR = absR; let error = false;
            if (d2 === 0) return { error: true, cx: p1.x, cz: p1.z, r: 0 };
            if (absR < d/2 - 0.001) { error = true; safeR = d/2 + 0.001; }
            const mx = (p1.x + p2.x) / 2; const mz = (p1.z + p2.z) / 2;
            const h = Math.sqrt(Math.max(0, safeR*safeR - d2/4));
            const dx = p2.x - p1.x; const dz = p2.z - p1.z;
            const ox = -dz / d; const oz = dx / d;
            let sign = (type === 'G3') ? -1 : 1; if (isLongArc) sign *= -1;
            const cx = mx + sign * h * ox; const cz = mz + sign * h * oz;
            if(isNaN(cx) || isNaN(cz)) return { error: true, cx: 0, cz: 0, r: 0 };
            return { cx, cz, r: safeR, error };
        };

        const isAngleBetween = (target, start, end, isG2) => {
            if (isNaN(target) || isNaN(start) || isNaN(end)) return false;
            const t = (target % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            const s = (start % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            const e = (end % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            if (isG2) { if (s >= e) return t <= s && t >= e; return t <= s || t >= e; } else { if (e >= s) return t >= s && t <= e; return t >= s || t <= e; }
        };

        const intersectHorizontalLineSegment = (xLine, p1, p2) => {
            if (!p1 || !p2) return null;
            const minX = Math.min(p1.x, p2.x); const maxX = Math.max(p1.x, p2.x);
            if (xLine < minX || xLine > maxX) return null; if (Math.abs(p2.x - p1.x) < 1e-6) return null;
            const t = (xLine - p1.x) / (p2.x - p1.x); return p1.z + t * (p2.z - p1.z);
        };
        const intersectHorizontalLineArc = (xLine, center, radius) => {
            if (!center) return [];
            const term = radius*radius - Math.pow(xLine - center.x, 2); if (term < 0) return [];
            const sqrtTerm = Math.sqrt(term); return [center.z - sqrtTerm, center.z + sqrtTerm];
        };
        const intersectVerticalLineSegment = (zLine, p1, p2) => {
            if (!p1 || !p2) return null;
            const minZ = Math.min(p1.z, p2.z); const maxZ = Math.max(p1.z, p2.z);
            if (zLine < minZ || zLine > maxZ) return null; if (Math.abs(p2.z - p1.z) < 1e-6) return null;
            const t = (zLine - p1.z) / (p2.z - p1.z); return p1.x + t * (p2.x - p1.x);
        };
        const intersectVerticalLineArc = (zLine, center, radius) => {
            if (!center) return [];
            const term = radius*radius - Math.pow(zLine - center.z, 2); if (term < 0) return [];
            const sqrtTerm = Math.sqrt(term); return [center.x - sqrtTerm, center.x + sqrtTerm];
        };

        // --- APP ---
        const App = () => {
            const [theme, setTheme] = useState('light');
            const [editMode, setEditMode] = useState('contour'); 
            const [mobileTab, setMobileTab] = useState('editor'); 
            const [copyFeedback, setCopyFeedback] = useState(false);
            
            const [simRunning, setSimRunning] = useState(false);
            const [simProgress, setSimProgress] = useState(0); 
            
            const [isLoaded, setIsLoaded] = useState(false);

            // DRAG & DROP & INSERT STATE
            const [draggedPointId, setDraggedPointId] = useState(null);
            const [hoverPointId, setHoverPointId] = useState(null);
            const [addPointMode, setAddPointMode] = useState(false); 

            // UNDO / REDO STATE
            const [past, setPast] = useState([]);
            const [future, setFuture] = useState([]);

            // MANUAL CODE OVERRIDE STATE
            const [useManualCode, setUseManualCode] = useState(false);
            const [manualGCode, setManualGCode] = useState('');

            const [params, setParams] = useState({
                machineType: 'LIMS=2000',
                mode: 'DIAMON',
                toolName: 'ROUGHER_T1',
                speed: 200,
                feed: 0.25,
                depthOfCut: 2.0,
                retractDistance: 2.0,
                allowanceX: 0.5,
                allowanceZ: 0.1,
                toolRadius: 0.8,
                doFinishing: true, 
                roughingStrategy: 'longitudinal',
                stockMode: 'cylinder', 
                stockMargin: 5.0, 
                stockDiameter: 100, 
                stockLength: 100,
                stockFace: 2.0,
                safeX: 150,
                safeZ: 5,
                machineStructure: 'lathe', 
                controlSystem: 'sinumerik',
                toolShape: 'round', // 'round' | 'polygon'
                toolLength: 10,
                toolAngle: 15, // 15 deg default
                toolTipAngle: 90 // Default 90 (Square)
            });

            const [contourPoints, setContourPoints] = useState([
                { id: 1, type: 'G0', x: 0, z: 0, r: 0, mode: 'ABS' },
                { id: 2, type: 'G1', x: 20, z: 0, r: 0, mode: 'ABS' },     
                { id: 3, type: 'G1', x: 20, z: -15, r: 0, mode: 'ABS' },   
                { id: 4, type: 'G1', x: 30, z: -15, r: 0, mode: 'ABS' },   
                { id: 5, type: 'G1', x: 35, z: -25, r: 0, mode: 'ABS' },   
                { id: 6, type: 'G1', x: 35, z: -40, r: 0, mode: 'ABS' },   
                { id: 7, type: 'G2', x: 55, z: -50, r: 10, mode: 'ABS' },  
                { id: 8, type: 'G1', x: 55, z: -55, r: 0, mode: 'ABS' }, 
                { id: 81, type: 'G1', x: 45, z: -55, r: 0, mode: 'ABS' }, 
                { id: 82, type: 'G1', x: 45, z: -60, r: 0, mode: 'ABS' }, 
                { id: 83, type: 'G1', x: 55, z: -60, r: 0, mode: 'ABS' }, 
                { id: 9, type: 'G1', x: 55, z: -65, r: 0, mode: 'ABS' }, 
                { id: 10, type: 'G3', x: 65, z: -75, r: 12, mode: 'ABS' },  
                { id: 11, type: 'G1', x: 80, z: -100, r: 0, mode: 'ABS' }  
            ]);

            const [stockPoints, setStockPoints] = useState([
                { id: 101, type: 'G0', x: 85, z: 2, r: 0, mode: 'ABS' },
                { id: 102, type: 'G1', x: 85, z: -105, r: 0, mode: 'ABS' },
                { id: 103, type: 'G1', x: 0, z: -105, r: 0, mode: 'ABS' }
            ]);
            
            const [errors, setErrors] = useState([]);
            const [gCodeInput, setGCodeInput] = useState('');
            const [generatedCode, setGeneratedCode] = useState([]);
            const [activeTab, setActiveTab] = useState('editor');
            
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const codeContainerRef = useRef(null);
            const [view, setView] = useState({ scale: 3, panX: 600, panY: 350 });
            const [isDragging, setIsDragging] = useState(false);
            const lastMousePos = useRef({ x: 0, y: 0 });
            const lastPinchDist = useRef(null);
            
            // --- HISTORY LOGIC ---
            const pushHistory = useCallback(() => {
                setPast(prev => [...prev, { 
                    contour: JSON.parse(JSON.stringify(contourPoints)), 
                    stock: JSON.parse(JSON.stringify(stockPoints)) 
                }]);
                setFuture([]);
            }, [contourPoints, stockPoints]);

            const undo = () => {
                if (past.length === 0) return;
                const previous = past[past.length - 1];
                const newPast = past.slice(0, -1);
                
                setFuture(prev => [{ 
                    contour: JSON.parse(JSON.stringify(contourPoints)), 
                    stock: JSON.parse(JSON.stringify(stockPoints)) 
                }, ...prev]);
                
                setContourPoints(previous.contour);
                setStockPoints(previous.stock);
                setPast(newPast);
            };

            const redo = () => {
                if (future.length === 0) return;
                const next = future[0];
                const newFuture = future.slice(1);
                
                setPast(prev => [...prev, { 
                    contour: JSON.parse(JSON.stringify(contourPoints)), 
                    stock: JSON.parse(JSON.stringify(stockPoints)) 
                }]);
                
                setContourPoints(next.contour);
                setStockPoints(next.stock);
                setFuture(newFuture);
            };

            // --- LOCAL STORAGE LOGIC ---
            const STORAGE_KEY = 'sinumerik_cam_save_v1';

            useEffect(() => {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        if (parsed.params) setParams(prev => ({...prev, ...parsed.params}));
                        if (parsed.contourPoints && parsed.contourPoints.length > 0) setContourPoints(parsed.contourPoints);
                        if (parsed.stockPoints && parsed.stockPoints.length > 0) setStockPoints(parsed.stockPoints);
                        if (parsed.theme) setTheme(parsed.theme);
                        if (parsed.manualGCode) setManualGCode(parsed.manualGCode);
                        if (parsed.useManualCode !== undefined) setUseManualCode(parsed.useManualCode);
                    } catch (e) {
                        console.error("Failed to load local storage:", e);
                    }
                }
                setIsLoaded(true);
            }, []);

            useEffect(() => {
                if (!isLoaded) return;
                const dataToSave = { params, contourPoints, stockPoints, theme, manualGCode, useManualCode };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
            }, [isLoaded, params, contourPoints, stockPoints, theme, manualGCode, useManualCode]);

            const handleResetApp = () => {
                if(confirm("Opravdu chcete vymazat ve≈°kerou ulo≈æenou pr√°ci a resetovat aplikaci?")) {
                    localStorage.removeItem(STORAGE_KEY);
                    window.location.reload();
                }
            };
            
            // --- PDF EXPORT LOGIC ---
            const handleExportPDF = () => {
                 if (!window.jspdf) {
                     alert("Knihovna pro PDF se je≈°tƒõ naƒç√≠t√°, zkuste to za chv√≠li.");
                     return;
                 }

                 const { jsPDF } = window.jspdf;
                 const doc = new jsPDF();
                 const noAccents = (str) => str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");

                 // 1. Header
                 doc.setFontSize(20);
                 doc.text(noAccents("Technologicky list - CAM"), 15, 20);
                 
                 doc.setFontSize(10);
                 doc.text(`Datum: ${new Date().toLocaleDateString()}`, 15, 30);
                 doc.text(noAccents(`System: ${params.controlSystem.toUpperCase()}`), 15, 35);
                 
                 // 2. Parameters
                 doc.setFontSize(12);
                 doc.text(noAccents("Parametry obrabeni:"), 15, 50);
                 doc.setFontSize(10);
                 let y = 60;
                 const addParam = (label, val) => {
                     doc.text(noAccents(`${label}: ${val}`), 20, y);
                     y += 6;
                 };
                 
                 addParam("Stroj", params.machineType);
                 addParam("Nastroj", params.toolName);
                 addParam("Rezna rychlost", params.speed + " m/min");
                 addParam("Posuv", params.feed + " mm/ot");
                 addParam("Hloubka trisky", params.depthOfCut + " mm");
                 
                 // 3. Image
                 if (canvasRef.current) {
                     const imgData = canvasRef.current.toDataURL("image/png");
                     // A4 width is 210. Margins 15. Width available 180.
                     const imgProps = doc.getImageProperties(imgData);
                     const pdfWidth = 100;
                     const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
                     
                     doc.text(noAccents("Nahled drahy:"), 100, 50);
                     doc.addImage(imgData, 'PNG', 100, 55, pdfWidth, pdfHeight);
                 }
                 
                 // 4. G-Code
                 y = 120; 
                 doc.setFontSize(12);
                 doc.text("G-Code:", 15, y);
                 y += 10;
                 doc.setFont("courier", "normal");
                 doc.setFontSize(9);
                 
                 generatedCode.forEach(lineObj => {
                     if (y > 280) {
                         doc.addPage();
                         y = 20;
                     }
                     doc.text(noAccents(lineObj.text), 15, y);
                     y += 5;
                 });
                 
                 doc.save("CAM_Export.pdf");
            };

            useEffect(() => {
                document.body.className = `h-[100dvh] w-screen overflow-hidden flex flex-col font-sans transition-colors duration-300 ${theme === 'dark' ? 'bg-gray-900 text-gray-100' : 'bg-gray-50 text-gray-900'}`;
            }, [theme]);

            const fitView = useCallback(() => {
                if (!containerRef.current) return;
                const points = resolvePointsToAbsolute(contourPoints);
                if (points.length === 0) return;
                let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
                points.forEach(p => {
                    const x = params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs;
                    const z = p.zAbs;
                    if(x < minX) minX = x; if(x > maxX) maxX = x;
                    if(z < minZ) minZ = z; if(z > maxZ) maxZ = z;
                });
                const pad = 20;
                
                const isCarousel = params.machineStructure === 'carousel';
                const visWidth = isCarousel ? (maxX - minX) : (maxZ - minZ);
                const visHeight = isCarousel ? (maxZ - minZ) : (maxX - minX);
                
                const width = visWidth + pad * 2;
                const height = visHeight + pad * 2;
                
                if (width <= 0 || height <= 0) return;
                const contW = containerRef.current.clientWidth;
                const contH = containerRef.current.clientHeight;
                if (contW === 0 || contH === 0) return;
                const scaleX = contW / width;
                const scaleY = contH / height;
                let newScale = Math.min(scaleX, scaleY) * 0.8; 
                if (newScale > 10) newScale = 10;
                if (newScale < 0.1) newScale = 0.1;
                
                const midZ = (minZ + maxZ) / 2;
                const midX = (minX + maxX) / 2;
                
                if (isCarousel) {
                    setView({ scale: newScale, panX: contW/2 - midX * newScale, panY: contH/2 + midZ * newScale });
                } else {
                    setView({ scale: newScale, panX: contW/2 - midZ * newScale, panY: contH/2 + midX * newScale });
                }
                
            }, [contourPoints, params.mode, params.machineStructure]);

            useEffect(() => { setTimeout(fitView, 100); }, [mobileTab, params.machineStructure]); 

            const resolvePointsToAbsolute = (pts) => {
                let lastX = 0; let lastZ = 0;
                return pts.map((p, index) => {
                    let valX = parseFloat(p.x); if(isNaN(valX)) valX = 0;
                    let valZ = parseFloat(p.z); if(isNaN(valZ)) valZ = 0;
                    let absX = valX; let absZ = valZ;
                    if (p.mode === 'INC') { absX = lastX + valX; absZ = lastZ + valZ; } else { absX = valX; absZ = valZ; }
                    lastX = absX; lastZ = absZ;
                    let rVal = parseFloat(p.r); if(isNaN(rVal)) rVal = 0;
                    return { ...p, xAbs: absX, zAbs: absZ, rVal };
                });
            };

            const handleAutoStock = () => {
                const absPts = resolvePointsToAbsolute(contourPoints);
                if (absPts.length === 0) return;
                let minZ = Infinity, maxZ = -Infinity;
                let maxD = 0;
                
                absPts.forEach(p => {
                    const x = params.mode === 'DIAMON' ? p.xAbs : p.xAbs * 2; 
                    if (Math.abs(x) > maxD) maxD = Math.abs(x);
                    if (p.zAbs < minZ) minZ = p.zAbs;
                    if (p.zAbs > maxZ) maxZ = p.zAbs;
                });
                
                const margin = parseFloat(params.stockMargin) || 5;
                const stockD = Math.ceil(maxD + margin*2); 
                const stockL = Math.ceil(Math.abs(minZ) + margin); 
                const stockF = 2.0;

                setParams(p => ({
                    ...p,
                    stockDiameter: stockD,
                    stockLength: stockL,
                    stockFace: stockF
                }));
            };

            const generateDefaultStock = () => {
                const absPts = resolvePointsToAbsolute(contourPoints);
                if (absPts.length === 0) return;
                let minZ = Infinity;
                let maxX = 0;
                
                absPts.forEach(p => {
                    const x = params.mode === 'DIAMON' ? p.xAbs/2 : p.xAbs;
                    if (Math.abs(x) > maxX) maxX = Math.abs(x);
                    if (p.zAbs < minZ) minZ = p.zAbs;
                });
                
                const sR = maxX + 5;
                const sL = minZ - 5;
                
                const newStock = [
                     { id: Date.now(), type: 'G0', x: sR, z: 2, r: 0, mode: 'ABS' },
                     { id: Date.now()+1, type: 'G1', x: sR, z: sL, r: 0, mode: 'ABS' },
                     { id: Date.now()+2, type: 'G1', x: 0, z: sL, r: 0, mode: 'ABS' }
                ];
                setStockPoints(newStock);
            };

            // NEW: MANUAL G-CODE PARSER FOR SIMULATION
            const parseManualGCodeToPath = (code, currentParams) => {
                const lines = code.split('\n');
                const path = [];
                // Initialize with safe position
                let currentX = parseFloat(currentParams.safeX) / 2; // Radius
                let currentZ = parseFloat(currentParams.safeZ);
                
                // Track modal states
                let lastMoveType = 'G0'; // Default G0

                // Add start point
                path.push({ x: currentX, z: currentZ, type: 'G0' });

                lines.forEach((line, idx) => {
                    const clean = line.toUpperCase().trim();
                    if (!clean || clean.startsWith(';') || clean.startsWith('(') || clean.startsWith('%')) {
                         // Map non-move lines to the last known position to keep indices synced
                         // But we won't add them to the path array to avoid drawing clutter, 
                         // we will just handle index mapping in the drawing loop or separate map.
                         // For simplicity here, we just ignore drawing them.
                         return;
                    }
                    
                    // Basic parsing
                    const gMatch = clean.match(/G([0-3])/);
                    const type = gMatch ? 'G' + gMatch[1] : lastMoveType; // Use last modal G code
                    
                    const xMatch = clean.match(/[XU]([-]?\d*\.?\d+)/);
                    const zMatch = clean.match(/[ZW]([-]?\d*\.?\d+)/);
                    const rMatch = clean.match(/(?:R|CR=)([-]?\d*\.?\d+)/);
                    
                    let targetX = currentX;
                    let targetZ = currentZ;
                    let hasMove = false;

                    if (xMatch) {
                        const val = parseFloat(xMatch[1]);
                        targetX = currentParams.mode === 'DIAMON' ? val / 2 : val;
                        hasMove = true;
                    }
                    if (zMatch) {
                        targetZ = parseFloat(zMatch[1]);
                        hasMove = true;
                    }
                    
                    // Only update modal state if explicit G code was present
                    if (gMatch) lastMoveType = type;

                    if (hasMove) {
                        if (type === 'G0' || type === 'G1') {
                            path.push({ x: targetX, z: targetZ, type: type, originalLineIdx: idx });
                            currentX = targetX;
                            currentZ = targetZ;
                        } else if (type === 'G2' || type === 'G3') {
                            if (rMatch) {
                                 const r = parseFloat(rMatch[1]);
                                 const p1 = { x: currentX, z: currentZ };
                                 const p2 = { x: targetX, z: targetZ };
                                 
                                 const arc = getArcParams(p1, p2, r, type);
                                 
                                 if (!arc.error) {
                                    const steps = 10;
                                    let sA = Math.atan2(p1.x - arc.cx, p1.z - arc.cz);
                                    let eA = Math.atan2(p2.x - arc.cx, p2.z - arc.cz);
                                    if (type === 'G2' && eA > sA) eA -= 2*Math.PI;
                                    if (type === 'G3' && eA < sA) eA += 2*Math.PI;

                                    for(let j=1; j<=steps; j++) {
                                         const a = sA + (eA - sA) * (j/steps);
                                         path.push({
                                             x: arc.cx + Math.sin(a)*arc.r,
                                             z: arc.cz + Math.cos(a)*arc.r,
                                             type: type,
                                             originalLineIdx: idx
                                         });
                                    }
                                 } else {
                                     path.push({ x: targetX, z: targetZ, type: type, originalLineIdx: idx });
                                 }
                            } else {
                                 path.push({ x: targetX, z: targetZ, type: type, originalLineIdx: idx });
                            }
                            currentX = targetX;
                            currentZ = targetZ;
                        }
                    } else if (gMatch) {
                        // G code change without move (e.g. G1 F0.2)
                         path.push({ x: currentX, z: currentZ, type: type, originalLineIdx: idx });
                    }
                });
                return path;
            };

            const calculatedData = useMemo(() => {
                const absContour = resolvePointsToAbsolute(contourPoints);
                const absStock = resolvePointsToAbsolute(stockPoints);
                const worldPoints = absContour.map(p => ({ ...p, xReal: params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs, zReal: p.zAbs }));
                const stockWorldPoints = absStock.map(p => ({ ...p, xReal: params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs, zReal: p.zAbs }));

                const tipR = parseFloat(params.toolRadius) || 0;
                const allowanceX = parseFloat(params.allowanceX) || 0;
                const allowanceZ = parseFloat(params.allowanceZ) || 0;
                const totalOffset = tipR + Math.max(allowanceX, allowanceZ);
                const retractDist = parseFloat(params.retractDistance) || 2.0; 
                
                let contourSegments = [];
                let rawOffsets = []; 
                let finishOffsetPath = [];
                let stockPathSegments = []; 
                const foundErrors = [];

                for (let i = 0; i < worldPoints.length - 1; i++) {
                    const p1 = worldPoints[i]; const p2 = worldPoints[i+1]; const type = p2.type;
                    if (type === 'G0' || type === 'G1') {
                        contourSegments.push({ type: 'line', p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal}, orig: p2 });
                    } else if (type === 'G2' || type === 'G3') {
                        const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, type);
                        if (arc.error) foundErrors.push(`≈ò√°dek ${i+2}: R√°dius R${p2.r} je p≈ô√≠li≈° mal√Ω.`);
                        else if (arc.r < totalOffset) foundErrors.push(`KOLIZE (≈ò√°dek ${i+2}): R√°dius kontury men≈°√≠ ne≈æ n√°stroj.`);
                        contourSegments.push({ type: 'arc', ...arc, p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal}, dir: type });
                    }
                }
                for (let i = 0; i < stockWorldPoints.length - 1; i++) {
                    const p1 = stockWorldPoints[i]; const p2 = stockWorldPoints[i+1]; const type = p2.type;
                    if (type === 'G0' || type === 'G1') {
                        stockPathSegments.push({ type: 'line', p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal} });
                    } else if (type === 'G2' || type === 'G3') {
                        const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, type);
                        const startAngle = Math.atan2(p1.xReal - arc.cx, p1.zReal - arc.cz);
                        const endAngle = Math.atan2(p2.xReal - arc.cx, p2.zReal - arc.cz);
                        stockPathSegments.push({ type: 'arc', ...arc, dir: type, startAngle, endAngle });
                    }
                }

                let incompleteMachiningCount = 0;
                
                // 1. GENERATE RAW OFFSETS (Skipping impossible arcs)
                for (let i = 0; i < contourSegments.length; i++) {
                    const seg = contourSegments[i];
                    let offSeg = null;
                    if (seg.type === 'line') {
                        const n = getNormal(seg.p1, seg.p2);
                        offSeg = { type: 'line', p1: { x: seg.p1.x + n.x * totalOffset, z: seg.p1.z + n.z * totalOffset }, p2: { x: seg.p2.x + n.x * totalOffset, z: seg.p2.z + n.z * totalOffset } };
                    } else if (seg.type === 'arc') {
                        let rNew = (seg.dir === 'G3') ? seg.r + totalOffset : seg.r - totalOffset;
                        if (rNew <= 1.5) { 
                            incompleteMachiningCount++;
                            offSeg = null; 
                        } else {
                            const startAngle = Math.atan2(seg.p1.x - seg.cx, seg.p1.z - seg.cz);
                            const endAngle = Math.atan2(seg.p2.x - seg.cx, seg.p2.z - seg.cz);
                            offSeg = { type: 'arc', cx: seg.cx, cz: seg.cz, r: rNew, dir: seg.dir, refP1: seg.p1, refP2: seg.p2, startAngle, endAngle, dir: seg.dir };
                        }
                    }
                    if (offSeg) rawOffsets.push(offSeg);
                }
                
                // 2. LOCAL TRIMMING & CONNECTING
                let trimmedOffsetPath = [];
                if (rawOffsets.length > 0) {
                    trimmedOffsetPath.push(JSON.parse(JSON.stringify(rawOffsets[0])));
                    
                    for (let i = 0; i < rawOffsets.length - 1; i++) {
                        let prevOff = trimmedOffsetPath[trimmedOffsetPath.length - 1]; 
                        let nextOff = JSON.parse(JSON.stringify(rawOffsets[i+1])); 
                        
                        let intersection = null;
                        
                        if (prevOff.type === 'line' && nextOff.type === 'line') {
                            intersection = intersectLines(prevOff.p1, prevOff.p2, nextOff.p1, nextOff.p2);
                        } else if (prevOff.type === 'line' && nextOff.type === 'arc') {
                            const ints = intersectLineCircle(prevOff.p1, prevOff.p2, {x:nextOff.cx, z:nextOff.cz}, nextOff.r);
                            if (ints && ints.length > 0) {
                                const d1 = Math.hypot(ints[0].x - prevOff.p2.x, ints[0].z - prevOff.p2.z);
                                const d2 = Math.hypot(ints[1].x - prevOff.p2.x, ints[1].z - prevOff.p2.z);
                                intersection = d1 < d2 ? ints[0] : ints[1];
                            }
                        } else if (prevOff.type === 'arc' && nextOff.type === 'line') {
                            const ints = intersectLineCircle(nextOff.p1, nextOff.p2, {x:prevOff.cx, z:prevOff.cz}, prevOff.r);
                            if (ints && ints.length > 0) {
                                const d1 = Math.hypot(ints[0].x - nextOff.p1.x, ints[0].z - nextOff.p1.z);
                                const d2 = Math.hypot(ints[1].x - nextOff.p1.x, ints[1].z - nextOff.p1.z);
                                intersection = d1 < d2 ? ints[0] : ints[1];
                            }
                        }

                        if (intersection) {
                            if (prevOff.type === 'line') prevOff.p2 = intersection;
                            else prevOff.endAngle = Math.atan2(intersection.x - prevOff.cx, intersection.z - prevOff.cz);
                            if (nextOff.type === 'line') nextOff.p1 = intersection;
                            else nextOff.startAngle = Math.atan2(intersection.x - nextOff.cx, intersection.z - nextOff.cz);
                            trimmedOffsetPath.push(nextOff);
                        } else {
                            // Gap bridging logic
                            let corner = null;
                            if (prevOff.type === 'line' && nextOff.type === 'line') {
                                corner = intersectLinesInfinite(prevOff.p1, prevOff.p2, nextOff.p1, nextOff.p2);
                            }

                            if (corner) {
                                prevOff.p2 = corner;
                                nextOff.p1 = corner;
                            } else {
                                const pStart = (prevOff.type === 'line') ? prevOff.p2 : {x: prevOff.cx + Math.sin(prevOff.endAngle)*prevOff.r, z: prevOff.cz + Math.cos(prevOff.endAngle)*prevOff.r};
                                const pEnd = (nextOff.type === 'line') ? nextOff.p1 : {x: nextOff.cx + Math.sin(nextOff.startAngle)*nextOff.r, z: nextOff.cz + Math.cos(nextOff.startAngle)*nextOff.r};
                                trimmedOffsetPath.push({ type: 'line', p1: pStart, p2: {x: pEnd.x, z: pStart.z} }); 
                                if (Math.abs(pEnd.z - pStart.z) > 0.001) {
                                    trimmedOffsetPath.push({ type: 'line', p1: {x: pEnd.x, z: pStart.z}, p2: pEnd }); 
                                }
                            }
                            trimmedOffsetPath.push(nextOff);
                        }
                    }
                }
                
                // 3. GLOBAL LOOP REMOVAL
                if (trimmedOffsetPath.length > 2) {
                    let loopFound = true;
                    let iterations = 0;
                    while (loopFound && iterations < 5) { 
                        loopFound = false;
                        iterations++;
                        outerLoop:
                        for (let i = 0; i < trimmedOffsetPath.length - 2; i++) {
                            for (let j = i + 2; j < trimmedOffsetPath.length; j++) {
                                const s1 = trimmedOffsetPath[i];
                                const s2 = trimmedOffsetPath[j];
                                if (s1.isDegenerate || s2.isDegenerate) continue;
                                let intersection = null;
                                if (s1.type === 'line' && s2.type === 'line') {
                                    intersection = intersectLines(s1.p1, s1.p2, s2.p1, s2.p2);
                                    if (intersection) {
                                         const tol = 0.5;
                                         const minX1 = Math.min(s1.p1.x, s1.p2.x) - tol; const maxX1 = Math.max(s1.p1.x, s1.p2.x) + tol;
                                         const minZ1 = Math.min(s1.p1.z, s1.p2.z) - tol; const maxZ1 = Math.max(s1.p1.z, s1.p2.z) + tol;
                                         const minX2 = Math.min(s2.p1.x, s2.p2.x) - tol; const maxX2 = Math.max(s2.p1.x, s2.p2.x) + tol;
                                         const minZ2 = Math.min(s2.p1.z, s2.p2.z) - tol; const maxZ2 = Math.max(s2.p1.z, s2.p2.z) + tol;
                                         if (!(intersection.x >= minX1 && intersection.x <= maxX1 && intersection.z >= minZ1 && intersection.z <= maxZ1 &&
                                               intersection.x >= minX2 && intersection.x <= maxX2 && intersection.z >= minZ2 && intersection.z <= maxZ2)) {
                                             intersection = null;
                                         }
                                    }
                                }
                                if (intersection) {
                                    if (s1.type === 'line') s1.p2 = intersection;
                                    else s1.endAngle = Math.atan2(intersection.x - s1.cx, intersection.z - s1.cz); 
                                    if (s2.type === 'line') s2.p1 = intersection;
                                    else s2.startAngle = Math.atan2(intersection.x - s2.cx, intersection.z - s2.cz);
                                    trimmedOffsetPath.splice(i + 1, j - (i + 1));
                                    loopFound = true; 
                                    break outerLoop; 
                                }
                            }
                        }
                    }
                }

                const offsetPath = trimmedOffsetPath; 
                
                if (params.doFinishing) {
                    let finRaw = [];
                    for (let i = 0; i < contourSegments.length; i++) {
                        const seg = contourSegments[i];
                         if (seg.type === 'line') {
                            const n = getNormal(seg.p1, seg.p2);
                            finRaw.push({ type: 'line', p1: { x: seg.p1.x + n.x * tipR, z: seg.p1.z + n.z * tipR }, p2: { x: seg.p2.x + n.x * tipR, z: seg.p2.z + n.z * tipR } });
                        } else if (seg.type === 'arc') {
                            let rNew = (seg.dir === 'G3') ? seg.r + tipR : seg.r - tipR;
                            if (rNew <= 1.5) { } else {
                                const startAngle = Math.atan2(seg.p1.x - seg.cx, seg.p1.z - seg.cz);
                                const endAngle = Math.atan2(seg.p2.x - seg.cx, seg.p2.z - seg.cz);
                                finRaw.push({ type: 'arc', cx: seg.cx, cz: seg.cz, r: rNew, dir: seg.dir, refP1: seg.p1, refP2: seg.p2, startAngle, endAngle });
                            }
                        }
                    }
                    if (finRaw.length > 0) {
                         finishOffsetPath.push(JSON.parse(JSON.stringify(finRaw[0])));
                         for (let i = 0; i < finRaw.length - 1; i++) {
                            let prevOff = finishOffsetPath[finishOffsetPath.length - 1]; 
                            let nextOff = JSON.parse(JSON.stringify(finRaw[i+1])); 
                            let intersection = null;
                            if (prevOff.type === 'line' && nextOff.type === 'line') {
                                intersection = intersectLines(prevOff.p1, prevOff.p2, nextOff.p1, nextOff.p2);
                            } else if (prevOff.type === 'line' && nextOff.type === 'arc') {
                                const ints = intersectLineCircle(prevOff.p1, prevOff.p2, {x:nextOff.cx, z:nextOff.cz}, nextOff.r);
                                if(ints && ints.length > 0) {
                                    const d1 = Math.hypot(ints[0].x - prevOff.p2.x, ints[0].z - prevOff.p2.z);
                                    const d2 = Math.hypot(ints[1].x - prevOff.p2.x, ints[1].z - prevOff.p2.z);
                                    intersection = d1 < d2 ? ints[0] : ints[1];
                                }
                            } else if (prevOff.type === 'arc' && nextOff.type === 'line') {
                                const ints = intersectLineCircle(nextOff.p1, nextOff.p2, {x:prevOff.cx, z:prevOff.cz}, prevOff.r);
                                if(ints && ints.length > 0) {
                                    const d1 = Math.hypot(ints[0].x - nextOff.p1.x, ints[0].z - nextOff.p1.z);
                                    const d2 = Math.hypot(ints[1].x - nextOff.p1.x, ints[1].z - nextOff.p1.z);
                                    intersection = d1 < d2 ? ints[0] : ints[1];
                                }
                            }
                            
                            if (intersection) {
                                if (prevOff.type === 'line') prevOff.p2 = intersection;
                                else prevOff.endAngle = Math.atan2(intersection.x - prevOff.cx, intersection.z - prevOff.cz);
                                if (nextOff.type === 'line') nextOff.p1 = intersection;
                                else nextOff.startAngle = Math.atan2(intersection.x - nextOff.cx, intersection.z - nextOff.cz);
                                finishOffsetPath.push(nextOff);
                            } else {
                                let corner = null;
                                if (prevOff.type === 'line' && nextOff.type === 'line') {
                                    corner = intersectLinesInfinite(prevOff.p1, prevOff.p2, nextOff.p1, nextOff.p2);
                                }
                                if(corner) {
                                    prevOff.p2 = corner;
                                    nextOff.p1 = corner;
                                } else {
                                    const pStart = (prevOff.type === 'line') ? prevOff.p2 : {x: prevOff.cx + Math.sin(prevOff.endAngle)*prevOff.r, z: prevOff.cz + Math.cos(prevOff.endAngle)*prevOff.r};
                                    const pEnd = (nextOff.type === 'line') ? nextOff.p1 : {x: nextOff.cx + Math.sin(nextOff.startAngle)*nextOff.r, z: nextOff.cz + Math.cos(nextOff.startAngle)*nextOff.r};
                                    finishOffsetPath.push({ type: 'line', p1: pStart, p2: {x: pEnd.x, z: pStart.z} });
                                    if (Math.abs(pEnd.z - pStart.z) > 0.001) {
                                        finishOffsetPath.push({ type: 'line', p1: {x: pEnd.x, z: pStart.z}, p2: pEnd }); 
                                    }
                                }
                                finishOffsetPath.push(nextOff);
                            }
                         }
                    }
                    if (finishOffsetPath.length > 2) {
                        let loopFound = true;
                        let iterations = 0;
                        while (loopFound && iterations < 5) { 
                            loopFound = false;
                            iterations++;
                            outerLoopFin:
                            for (let i = 0; i < finishOffsetPath.length - 2; i++) {
                                for (let j = i + 2; j < finishOffsetPath.length; j++) {
                                    const s1 = finishOffsetPath[i];
                                    const s2 = finishOffsetPath[j];
                                    if (s1.isDegenerate || s2.isDegenerate) continue;
                                    let intersection = null;
                                    if (s1.type === 'line' && s2.type === 'line') {
                                        intersection = intersectLines(s1.p1, s1.p2, s2.p1, s2.p2);
                                        if (intersection) {
                                             const tol = 0.5;
                                             const minX1 = Math.min(s1.p1.x, s1.p2.x) - tol; const maxX1 = Math.max(s1.p1.x, s1.p2.x) + tol;
                                             const minZ1 = Math.min(s1.p1.z, s1.p2.z) - tol; const maxZ1 = Math.max(s1.p1.z, s1.p2.z) + tol;
                                             const minX2 = Math.min(s2.p1.x, s2.p2.x) - tol; const maxX2 = Math.max(s2.p1.x, s2.p2.x) + tol;
                                             const minZ2 = Math.min(s2.p1.z, s2.p2.z) - tol; const maxZ2 = Math.max(s2.p1.z, s2.p2.z) + tol;
                                             if (!(intersection.x >= minX1 && intersection.x <= maxX1 && intersection.z >= minZ1 && intersection.z <= maxZ1 &&
                                                   intersection.x >= minX2 && intersection.x <= maxX2 && intersection.z >= minZ2 && intersection.z <= maxZ2)) {
                                                 intersection = null;
                                             }
                                        }
                                    }
                                    if (intersection) {
                                        if (s1.type === 'line') s1.p2 = intersection;
                                        else s1.endAngle = Math.atan2(intersection.x - s1.cx, intersection.z - s1.cz); 
                                        if (s2.type === 'line') s2.p1 = intersection;
                                        else s2.startAngle = Math.atan2(intersection.x - s2.cx, intersection.z - s2.cz);
                                        finishOffsetPath.splice(i + 1, j - (i + 1));
                                        loopFound = true; 
                                        break outerLoopFin;
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (incompleteMachiningCount > 0) foundErrors.push({ type: 'warning', msg: `POZN√ÅMKA: V ${incompleteMachiningCount} m√≠stech nedojde ke kompletn√≠mu obroben√≠.` });
                setErrors(foundErrors);

                const passes = [];
                const step = parseFloat(params.depthOfCut) || 1;
                const sRad = (parseFloat(params.stockDiameter) || 100)/2;
                const stockFace = parseFloat(params.stockFace) || 0;
                
                if (params.roughingStrategy === 'face') {
                    let currentZ = stockFace;
                    const minZPart = -1000;
                    let safe = 0;
                    while (currentZ > minZPart && safe < 500) {
                        currentZ -= step; safe++;
                        let xsEnd = [];
                        offsetPath.forEach(os => {
                            if (os.isDegenerate) return;
                            if (os.type === 'line') {
                                const x = intersectVerticalLineSegment(currentZ, os.p1, os.p2);
                                if (x !== null) xsEnd.push(x);
                            } else if (os.type === 'arc') {
                                const res = intersectVerticalLineArc(currentZ, {x: os.cx, z: os.cz}, os.r);
                                res.forEach(x => {
                                    const angle = Math.atan2(x - os.cx, currentZ - os.cz);
                                    if (isAngleBetween(angle, os.startAngle, os.endAngle, os.dir === 'G2')) xsEnd.push(x);
                                });
                            }
                        });
                        xsEnd.sort((a, b) => a - b); 
                        let xTarget = 0;
                        if (xsEnd.length > 0) {
                            const validXs = xsEnd.filter(x => x < sRad + 1);
                            if (validXs.length > 0) xTarget = validXs[validXs.length - 1]; 
                        } else {
                            let maxOZ = -9999;
                            offsetPath.forEach(p => { 
                                if(p.isDegenerate) return;
                                const z1 = p.type==='line' ? p.p1.z : p.cz + p.r; 
                                const z2 = p.type==='line' ? p.p2.z : p.cz - p.r; 
                                maxOZ = Math.max(maxOZ, z1, z2);
                            });
                            if (currentZ > maxOZ) xTarget = -1; else continue; 
                        }
                        if (xTarget >= sRad - 0.01) continue;
                        passes.push({ type: 'face', z: currentZ, xStart: sRad + 2, xEnd: xTarget });
                        if (currentZ < -200) break; 
                    }
                } else {
                    let currentX = sRad;
                    if (params.stockMode === 'casting' && stockWorldPoints.length > 0) {
                       let maxStockX = -9999;
                       stockWorldPoints.forEach(p => { if (p.xReal > maxStockX) maxStockX = p.xReal; });
                       currentX = maxStockX; 
                    }
                    const cylStockZ = (parseFloat(params.stockLength) || 100) * -1;
                    let safe = 0;
                    while (currentX > -50 && safe < 500) {
                        currentX -= step; safe++;
                        let zsEnd = [];
                        offsetPath.forEach(os => {
                            if(os.isDegenerate) return;
                            if (os.type === 'line') {
                                const z = intersectHorizontalLineSegment(currentX, os.p1, os.p2);
                                if (z !== null) zsEnd.push(z);
                            } else if (os.type === 'arc') {
                                const res = intersectHorizontalLineArc(currentX, {x: os.cx, z: os.cz}, os.r);
                                res.forEach(z => {
                                    const angle = Math.atan2(currentX - os.cx, z - os.cz);
                                    if (isAngleBetween(angle, os.startAngle, os.endAngle, os.dir === 'G2')) zsEnd.push(z);
                                });
                            }
                        });
                        zsEnd.sort((a, b) => b - a);
                        zsEnd = zsEnd.filter((z, i) => i === 0 || Math.abs(z - zsEnd[i-1]) > 0.01);

                        if (zsEnd.length > 0) {
                            let zTarget = zsEnd[0];
                            let zStartCut = allowanceZ;
                            if (params.stockMode === 'casting') {
                                let zsStart = [];
                                stockPathSegments.forEach(ss => {
                                    if (ss.type === 'line') {
                                        const z = intersectHorizontalLineSegment(currentX, ss.p1, ss.p2);
                                        if (z !== null) zsStart.push(z);
                                    } else if (ss.type === 'arc') {
                                        const res = intersectHorizontalLineArc(currentX, {x: ss.cx, z: ss.cz}, ss.r);
                                        res.forEach(z => {
                                            const angle = Math.atan2(currentX - ss.cx, z - ss.cz);
                                            if (isAngleBetween(angle, ss.startAngle, ss.endAngle, ss.dir === 'G2')) zsStart.push(z);
                                        });
                                    }
                                });
                                zsStart.sort((a, b) => b - a);
                                const validStarts = zsStart.filter(z => z > zTarget + 0.01);
                                if (validStarts.length > 0) zStartCut = validStarts[0];
                                else if (zsStart.length === 0) continue; 
                            } else {
                                if (currentX > sRad) continue; 
                                if (zTarget < cylStockZ) zTarget = cylStockZ;
                                zStartCut = stockFace;
                            }
                            if (zStartCut > zTarget) {
                                passes.push({ type: 'long', x: currentX, zStart: zStartCut, zEnd: zTarget });
                            }
                        }
                        let minPartX = 9999;
                        offsetPath.forEach(os => {
                           if(os.isDegenerate) return;
                           if (os.type === 'line') minPartX = Math.min(minPartX, os.p1.x, os.p2.x);
                           else minPartX = Math.min(minPartX, os.cx - os.r); 
                        });
                        if (currentX < minPartX - 1) break; 
                    }
                }

                let simPath = [];
                let totalPathLength = 0;
                let estimatedTimeSeconds = 0;
                
                // Helper to add to path and calculate length/time
                const addToPath = (x1, z1, x2, z2, type) => {
                    const dist = Math.hypot(x2 - x1, z2 - z1);
                    totalPathLength += dist;
                    
                    // Simple Time Estimation Logic
                    if (type === 'G0') {
                        // Rapid traverse assumption: 5000 mm/min
                        estimatedTimeSeconds += (dist / 5000) * 60;
                    } else {
                        // Cutting feed logic
                        // Need RPM. If G96 (const surface speed), RPM varies with X.
                        // RPM = (Vc * 1000) / (PI * D)
                        const feed = parseFloat(params.feed) || 0.1;
                        const speed = parseFloat(params.speed) || 200;
                        
                        let avgX = Math.abs((x1 + x2) / 2); // Radius
                        if (avgX < 1) avgX = 1; // Prevent div by zero
                        const diam = avgX * 2;
                        
                        let rpm = (speed * 1000) / (Math.PI * diam);
                        if (rpm > 2000) rpm = 2000; // Limit
                        
                        const mmPerMin = feed * rpm;
                        if (mmPerMin > 0) {
                            estimatedTimeSeconds += (dist / mmPerMin) * 60;
                        }
                    }
                    return { x: x2, z: z2, type };
                };
                
                if (useManualCode) {
                    // USE MANUAL / AI CODE
                    simPath = parseManualGCodeToPath(manualGCode, params);
                    // Recalculate basic stats for manual code
                    for(let i=0; i<simPath.length-1; i++) {
                        addToPath(simPath[i].x, simPath[i].z, simPath[i+1].x, simPath[i+1].z, simPath[i+1].type);
                    }
                } else {
                    // USE AUTO GENERATED CODE
                    simPath.push({x: params.safeX/2, z: params.safeZ, type: 'G0'});
                    let currentSimX = params.safeX/2;
                    let currentSimZ = params.safeZ;

                    passes.forEach(pass => {
                        const tx = pass.type === 'long' ? (pass.type==='long' ? pass.x : pass.xStart) : pass.xStart; 
                        const tz = pass.type === 'long' ? pass.zStart + 1 : pass.z; 
                        
                        if (Math.abs(currentSimZ - tz) > 0.001) {
                            simPath.push(addToPath(currentSimX, currentSimZ, currentSimX, tz, 'G0'));
                            currentSimZ = tz;
                        }
                        if (Math.abs(currentSimX - tx) > 0.001) {
                             simPath.push(addToPath(currentSimX, currentSimZ, tx, tz, 'G0'));
                             currentSimX = tx;
                        }

                        if (pass.type === 'long') {
                            const xRetract = pass.x + retractDist; 
                            const xCut = pass.x;
                            simPath.push(addToPath(currentSimX, currentSimZ, xCut, pass.zEnd, 'G1'));          
                            simPath.push(addToPath(xCut, pass.zEnd, xRetract, pass.zEnd + retractDist, 'G1'));   
                            simPath.push(addToPath(xRetract, pass.zEnd + retractDist, xRetract, pass.zStart + 1, 'G0'));   
                            currentSimX = xRetract;
                            currentSimZ = pass.zStart + 1;
                        } else {
                            const zRetract = pass.z + retractDist; 
                            const zCut = pass.z;
                            simPath.push(addToPath(currentSimX, currentSimZ, pass.xEnd, zCut, 'G1')); 
                            simPath.push(addToPath(pass.xEnd, zCut, pass.xEnd, zRetract, 'G1')); 
                            simPath.push(addToPath(pass.xEnd, zRetract, pass.xStart, zRetract, 'G0')); 
                            currentSimX = pass.xStart;
                            currentSimZ = zRetract;
                        }
                    });
                    
                    simPath.push(addToPath(currentSimX, currentSimZ, params.safeX/2, params.safeZ, 'G0'));

                    if (params.doFinishing && finishOffsetPath.length > 0) {
                         const startSeg = finishOffsetPath[0];
                         const startX = startSeg.type === 'line' ? startSeg.p1.x : (startSeg.cx + Math.sin(startSeg.startAngle)*startSeg.r);
                         const startZ = startSeg.type === 'line' ? startSeg.p1.z : (startSeg.cz + Math.cos(startSeg.startAngle)*startSeg.r);
                         
                         // Approach
                         const lastPt = simPath[simPath.length-1];
                         simPath.push(addToPath(lastPt.x, lastPt.z, startX + 2, startZ, 'G0')); 
                         simPath.push(addToPath(startX + 2, startZ, startX, startZ, 'G1')); 

                         finishOffsetPath.forEach(seg => {
                             if (seg.isDegenerate) return;
                             const prev = simPath[simPath.length-1];
                             
                             if (seg.type === 'line') {
                                 simPath.push(addToPath(prev.x, prev.z, seg.p2.x, seg.p2.z, 'G1'));
                             } else {
                                 const steps = 10;
                                 let sA = seg.startAngle;
                                 let eA = seg.endAngle;
                                 if (seg.dir === 'G2' && eA > sA) eA -= 2*Math.PI;
                                 if (seg.dir === 'G3' && eA < sA) eA += 2*Math.PI;
                                 
                                 // Add arc length approximate
                                 let lastArcX = prev.x;
                                 let lastArcZ = prev.z;
                                 
                                 for(let j=1; j<=steps; j++) {
                                     const a = sA + (eA - sA) * (j/steps);
                                     const nextX = seg.cx + Math.sin(a)*seg.r;
                                     const nextZ = seg.cz + Math.cos(a)*seg.r;
                                     
                                     // We calculate time for small segments but push them as one arc visually in G-code gen logic, 
                                     // but for sim path we push points.
                                     addToPath(lastArcX, lastArcZ, nextX, nextZ, seg.dir); // Just for stats calc
                                     simPath.push({x: nextX, z: nextZ, type: seg.dir});
                                     lastArcX = nextX;
                                     lastArcZ = nextZ;
                                 }
                             }
                         });
                         const finalPt = simPath[simPath.length-1];
                         simPath.push(addToPath(finalPt.x, finalPt.z, finalPt.x + 2, finalPt.z + 2, 'G0'));
                         const veryLast = simPath[simPath.length-1];
                         simPath.push(addToPath(veryLast.x, veryLast.z, params.safeX/2, params.safeZ, 'G0'));
                    }
                }

                return { worldPoints, stockWorldPoints, offsetPath, finishOffsetPath, stockPathSegments, passes, simPath, retractDist, totalPathLength, estimatedTimeSeconds };
            }, [contourPoints, stockPoints, params, useManualCode, manualGCode]);

            // --- G-Code and Mapping Generation ---
            useEffect(() => {
                let animationFrameId; let startTime;
                const animate = (time) => {
                    if (!startTime) startTime = time;
                    if (simRunning) {
                        setSimProgress(prev => { 
                            // ZPOMALENO z 0.003 na 0.0015
                            const next = prev + 0.0015; 
                            if (next >= 1) { 
                                setSimRunning(false); 
                                return 1; 
                            } 
                            return next; 
                        });
                        animationFrameId = requestAnimationFrame(animate);
                    }
                };
                if (simRunning) animationFrameId = requestAnimationFrame(animate);
                return () => cancelAnimationFrame(animationFrameId);
            }, [simRunning]);

            useEffect(() => {
                // If using manual code, we don't generate standard code
                if (useManualCode) {
                    const lines = manualGCode.split('\n').map((line, idx) => ({ text: line, simIdx: idx }));
                    setGeneratedCode(lines);
                    return;
                }

                const d = new Date();
                const lines = []; 
                const add = (text, simIdx = null) => lines.push({ text, simIdx });
                
                const cmt = (text) => {
                    if (params.controlSystem === 'fanuc') return `( ${text} )`;
                    return `; ${text}`;
                };
                const addCmt = (text) => add(cmt(text), null);
                
                // Block number counter
                let blockNum = 10;
                const N = () => {
                    const s = `N${blockNum} `;
                    blockNum += 10;
                    return s;
                };

                // Helper for lines with block numbers
                const addN = (text, simIdx = null) => {
                    add(`${N()}${text}`, simIdx);
                };

                const note = (cmd, text) => ` ${cmd}${cmt(text)}`; 

                // Konfigurace pro jednotliv√© syst√©my
                let arcR = (r) => `CR=${(parseFloat(r) || 0).toFixed(3)}`; // Default Sinumerik

                if (params.controlSystem === 'sinumerik') {
                    addCmt(`Vygenerovan√Ω k√≥d SINUMERIK 840D`);
                    addCmt(`Datum: ${d.toLocaleDateString()}`);
                    addN(`G18${note('', 'Rovina ZX')}`);
                    addN(`G90${note('', 'Absolutn√≠ programov√°n√≠')}`);
                    addN(`G54${note('', 'Posunut√≠ poƒç√°tku')}`);
                    addN(`G95${note('', 'Posuv na ot√°ƒçku')}`);
                    addN(`G75 Z0${note('', 'N√°jezd do ref. bodu')}`);
                    addN(`G75 X0`);
                    addN(`LIMS=2000${note('', 'Limit ot√°ƒçek')}`);
                    addN(`G96 S${params.speed} ${params.machineType}${note('', 'Konst. ≈ôezn√° rychlost')}`);
                    
                    const diamNote = params.mode === 'DIAMON' ? 'Programov√°n√≠ pr≈Ømƒõru' : 'Programov√°n√≠ polomƒõru';
                    addN(`${params.mode}${note('', diamNote)}`);

                    addN(`T="${params.toolName}" D1 M6${note('', 'V√Ωmƒõna n√°stroje')}`);
                    addN(`M3${note('', 'V≈ôeteno CW')}`);
                    addN(`M8${note('', 'Chlazen√≠ ZAP')}`);

                    arcR = (r) => `CR=${(parseFloat(r) || 0).toFixed(3)}`;
                } else if (params.controlSystem === 'fanuc') {
                    addCmt(`Vygenerovan√Ω k√≥d FANUC`);
                    addCmt(`Datum: ${d.toLocaleDateString()}`);
                    addN(`G21${note('', 'Metrick√Ω vstup')}`);
                    addN(`G40${note('', 'Zru≈°en√≠ kompenzace')}`);
                    addN(`G99${note('', 'Posuv mm/ot')}`);
                    addN(`G18${note('', 'Rovina ZX')}`);
                    addN(`G28 U0 W0${note('', 'Referenƒçn√≠ bod')}`);
                    addN(`G50 S2000${note('', 'Max ot√°ƒçky')}`);
                    addN(`G96 S${params.speed} M3${note('', 'Konst. ≈ôezn√° rychlost')}`);
                    addN(`T0101${note('', 'N√°stroj 1 / Korekce 1')}`);
                    addN(`M8${note('', 'Chlazen√≠ ZAP')}`);
                    arcR = (r) => `R${(parseFloat(r) || 0).toFixed(3)}`;
                } else if (params.controlSystem === 'heidenhain') {
                    addCmt(`Vygenerovan√Ω k√≥d HEIDENHAIN ISO`);
                    addCmt(`Datum: ${d.toLocaleDateString()}`);
                    addN(`G18${note('', 'Rovina ZX')}`);
                    addN(`G90${note('', 'Absolutn√≠')}`);
                    addN(`G71${note('', 'Metrick√Ω syst√©m')}`);
                    addN(`G54${note('', 'Nulov√Ω bod')}`);
                    addN(`G96 S${params.speed} M3${note('', '≈òezn√° rychlost')}`);
                    addN(`T1 M6${note('', 'N√°stroj')}`);
                    addN(`M8`);
                    arcR = (r) => `R${(parseFloat(r) || 0).toFixed(3)}`;
                }
                
                let simCounter = 0; 
                addN(`G0 X${params.safeX} Z${params.safeZ}${note('', 'Rychloposuv')}`, 0); 

                const rDist = calculatedData.retractDist || 2.0;

                addCmt(`--- HRUBOVANI (${params.roughingStrategy === 'face' ? 'CELNI' : 'PODELNE'}) ---`);
                
                calculatedData.passes.forEach((pass, i) => {
                    addCmt(`Pr≈Øchod ${i+1}`);
                    if (pass.type === 'long') {
                        const xVal = params.mode === 'DIAMON' ? (pass.x * 2).toFixed(3) : pass.x.toFixed(3);
                        const xRetract = params.mode === 'DIAMON' ? ((pass.x + rDist) * 2).toFixed(3) : (pass.x + rDist).toFixed(3);
                        simCounter += 1; addN(`G0 X${xRetract} Z${(pass.zStart + 1).toFixed(3)}`, simCounter);
                        simCounter += 1; addN(`G1 X${xVal} F${params.feed}`, simCounter); 
                        simCounter += 1; addN(`G1 Z${pass.zEnd.toFixed(3)}`, simCounter);
                        simCounter += 1; addN(`G1 X${xRetract} Z${(pass.zEnd + rDist).toFixed(3)}`, simCounter);
                        simCounter += 1; addN(`G0 Z${(pass.zStart + 1).toFixed(3)}`, simCounter);
                    } else {
                        const zVal = pass.z.toFixed(3);
                        const zRetract = (pass.z + rDist).toFixed(3);
                        const xStart = params.mode === 'DIAMON' ? (pass.xStart * 2).toFixed(3) : pass.xStart.toFixed(3);
                        const xEnd = params.mode === 'DIAMON' ? (pass.xEnd * 2).toFixed(3) : pass.xEnd.toFixed(3);
                        const xEndRetract = params.mode === 'DIAMON' ? ((pass.xEnd + rDist) * 2).toFixed(3) : (pass.xEnd + rDist).toFixed(3);
                        simCounter += 1; addN(`G0 X${xStart} Z${zRetract}`, simCounter);
                        simCounter += 1; addN(`G1 Z${zVal} F${params.feed}`, simCounter);
                        simCounter += 1; addN(`G1 X${xEnd}`, simCounter);
                        simCounter += 1; addN(`G1 X${xEndRetract} Z${zRetract}`, simCounter);
                        simCounter += 1; addN(`G0 X${xStart}`, simCounter);
                    }
                });

                simCounter += 1;
                addN(`G0 X${params.safeX} Z${params.safeZ}`, simCounter);

                if (params.doFinishing && calculatedData.finishOffsetPath.length > 0) {
                    addCmt(`--- DOKONCOVANI ---`);
                    const startSeg = calculatedData.finishOffsetPath[0];
                    const sX = startSeg.type === 'line' ? startSeg.p1.x : (startSeg.cx + Math.sin(startSeg.startAngle)*startSeg.r);
                    const sZ = startSeg.type === 'line' ? startSeg.p1.z : (startSeg.cz + Math.cos(startSeg.startAngle)*startSeg.r);
                    const sX_out = params.mode === 'DIAMON' ? (sX * 2).toFixed(3) : sX.toFixed(3);
                    simCounter += 1; addN(`G0 X${sX_out} Z${sZ.toFixed(3)}`, simCounter);
                    simCounter += 1; addN(`G1 X${sX_out} Z${sZ.toFixed(3)}`, simCounter); 

                    calculatedData.finishOffsetPath.forEach(seg => {
                        if(seg.isDegenerate) return;
                        if (seg.type === 'line') {
                             const eX = params.mode === 'DIAMON' ? (seg.p2.x * 2).toFixed(3) : seg.p2.x.toFixed(3);
                             simCounter += 1;
                             addN(`G1 X${eX} Z${seg.p2.z.toFixed(3)}`, simCounter);
                        } else {
                             simCounter += 10;
                             const eX = params.mode === 'DIAMON' ? ((seg.cx + Math.sin(seg.endAngle)*seg.r) * 2).toFixed(3) : (seg.cx + Math.sin(seg.endAngle)*seg.r).toFixed(3);
                             const eZ = (seg.cz + Math.cos(seg.endAngle)*seg.r).toFixed(3);
                             addN(`${seg.dir} X${eX} Z${eZ} ${arcR(seg.r)} ${seg.isCornerRoll ? cmt('Obeplut√≠ rohu') : ''}`, simCounter);
                        }
                    });
                    simCounter += 2; 
                    addN(`G0 X${params.safeX} Z${params.safeZ}`, simCounter);
                }

                if (params.controlSystem === 'fanuc') {
                    addN(`M9`);
                    addN(`M5`);
                    addN(`G28 U0 W0`);
                    addN(`M30${note('', 'Konec programu')}`);
                } else if (params.controlSystem === 'heidenhain') {
                    addN(`M9`);
                    addN(`M5`);
                    addN(`M30`);
                } else {
                    addN(`M30${note('', 'Konec programu')}`);
                }
                
                addCmt(`--- KONTURA (Pro referenci) ---`);
                contourPoints.forEach(p => {
                    let line = `${p.type} X${(parseFloat(p.x)||0)} Z${(parseFloat(p.z)||0)}`;
                    if (p.type === 'G2' || p.type === 'G3') line += ` ${arcR(p.r)}`; 
                    addCmt(line); 
                });

                setGeneratedCode(lines);
            }, [calculatedData, params, contourPoints, useManualCode, manualGCode]);

            const handleLineClick = (simIdx) => {
                if (simIdx !== null && calculatedData.simPath.length > 0) {
                    const progress = simIdx / (calculatedData.simPath.length - 1);
                    setSimProgress(progress);
                }
            };
            
            const toggleSimulation = () => {
                if (simRunning) {
                    setSimRunning(false);
                } else {
                    if (simProgress >= 1) {
                        setSimProgress(0);
                    }
                    setSimRunning(true);
                }
            };

            const stopSimulation = () => {
                setSimRunning(false);
                setSimProgress(0);
            };
            
            useEffect(() => {
                if (!codeContainerRef.current) return;
                const activeEl = codeContainerRef.current.querySelector('.code-line.active');
                if (activeEl) {
                    activeEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }, [simProgress]);
            
            const currentSimIdx = Math.floor(simProgress * (calculatedData.simPath.length - 1));
            const activeLineIndex = generatedCode.findIndex(line => line.simIdx !== null && line.simIdx > currentSimIdx);
            const highlightIndex = activeLineIndex === -1 ? generatedCode.findLastIndex(l => l.simIdx !== null) : activeLineIndex;

            const draw = useCallback(() => {
                const canvas = canvasRef.current;
                const container = containerRef.current;
                if (!canvas || !container) return;
                
                const ctx = canvas.getContext('2d');
                const w = container.clientWidth;
                const h = container.clientHeight;
                if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }

                const colors = theme === 'dark' ? {
                    bg: '#111827', grid: '#374151', axis: '#ef4444', stock: '#9ca3af',
                    contour: '#3b82f6', offset: '#a855f7', pass: '#22c55e', finish: '#f472b6', error: '#ef4444', text: '#9ca3af', tool: '#facc15'
                } : {
                    bg: '#ffffff', grid: '#e5e7eb', axis: '#ef4444', stock: '#6b7280',
                    contour: '#2563eb', offset: '#9333ea', pass: '#16a34a', finish: '#db2777', error: '#ef4444', text: '#6b7280', tool: '#fbbf24'
                };

                ctx.fillStyle = colors.bg; ctx.fillRect(0, 0, w, h);
                const toScreen = (x, z) => {
                    if(isNaN(x) || isNaN(z)) return {x:0, y:0};
                    
                    if (params.machineStructure === 'carousel') {
                        return { x: view.panX + x * view.scale, y: view.panY - z * view.scale };
                    } else {
                        return { x: view.panX + z * view.scale, y: view.panY - x * view.scale };
                    }
                };

                ctx.strokeStyle = colors.grid; ctx.lineWidth = 1; ctx.beginPath();
                
                ctx.fillStyle = theme === 'dark' ? '#6b7280' : '#9ca3af';
                ctx.font = "10px sans-serif";
                
                for (let i=-500; i<=500; i+=20) {
                     const p1 = toScreen(-500, i); const p2 = toScreen(500, i);
                     ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                     
                     const p3 = toScreen(i, -500); const p4 = toScreen(i, 500);
                     ctx.moveTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y);
                }
                ctx.stroke();

                for (let i=-500; i<=500; i+=20) {
                    if (i === 0) continue; 

                    const ptHoriz = toScreen(0, i); 
                    
                    if (params.machineStructure === 'carousel') {
                        const ptX = toScreen(i, 0); 
                        ctx.textAlign = "center"; 
                        ctx.textBaseline = "top";
                        ctx.fillText(i.toString(), ptX.x, ptX.y + 2);

                        const ptZ = toScreen(0, i); 
                        ctx.textAlign = "right"; 
                        ctx.textBaseline = "middle";
                        ctx.fillText(i.toString(), ptZ.x - 4, ptZ.y);
                    } else {
                        const ptZ = toScreen(0, i);
                        ctx.textAlign = "center"; 
                        ctx.textBaseline = "top";
                        ctx.fillText(i.toString(), ptZ.x, ptZ.y + 2);

                        const ptX = toScreen(i, 0);
                        ctx.textAlign = "right"; 
                        ctx.textBaseline = "middle";
                        ctx.fillText(i.toString(), ptX.x - 4, ptX.y);
                    }
                }

                const zero = toScreen(0,0);
                ctx.strokeStyle = colors.axis; ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(0, zero.y); ctx.lineTo(w, zero.y);
                ctx.moveTo(zero.x, 0); ctx.lineTo(zero.x, h);
                ctx.stroke();
                ctx.fillStyle = colors.axis; ctx.font = "bold 12px monospace";
                ctx.textAlign = "left"; ctx.textBaseline = "alphabetic";
                
                if (params.machineStructure === 'carousel') {
                    ctx.fillText("X+", w - 20, zero.y + 15); 
                    ctx.fillText("Z+", zero.x + 10, 15);
                } else {
                    ctx.fillText("Z+", w - 20, zero.y + 15); 
                    ctx.fillText("X+", zero.x + 10, 15);
                }
                ctx.fillText("X0 Z0", zero.x + 4, zero.y - 4); 

                if (params.stockMode === 'cylinder') {
                    const sRad = (parseFloat(params.stockDiameter) || 0)/2;
                    const sLen = parseFloat(params.stockLength) || 0;
                    const sFace = parseFloat(params.stockFace) || 0;
                    const s1 = toScreen(sRad, sFace); 
                    const s2 = toScreen(sRad, -sLen); 
                    const s3 = toScreen(0, -sLen);
                    const sStart = toScreen(0, sFace);
                    ctx.fillStyle = theme === 'dark' ? 'rgba(100,100,100,0.1)' : 'rgba(200,200,200,0.3)';
                    ctx.beginPath(); ctx.moveTo(sStart.x, sStart.y); ctx.lineTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.lineTo(s3.x, s3.y); ctx.fill();
                    ctx.strokeStyle = colors.stock; ctx.setLineDash([5, 5]); ctx.beginPath();
                    ctx.moveTo(sStart.x, sStart.y); ctx.lineTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.lineTo(s3.x, s3.y);
                    ctx.stroke(); ctx.setLineDash([]);
                } else if (calculatedData.stockPathSegments.length > 0) {
                    ctx.beginPath();
                    calculatedData.stockPathSegments.forEach((seg, i) => {
                        if (seg.type === 'line') {
                            const p1 = toScreen(seg.p1.x, seg.p1.z); const p2 = toScreen(seg.p2.x, seg.p2.z);
                            if (i === 0) ctx.moveTo(p1.x, p1.y); else ctx.lineTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                        } else if (seg.type === 'arc') {
                             const sa_scr = -seg.startAngle; 
                             const steps = 15;
                             let sA = seg.startAngle;
                             let eA = seg.endAngle;
                             if (seg.dir === 'G2' && eA > sA) eA -= 2*Math.PI;
                             if (seg.dir === 'G3' && eA < sA) eA += 2*Math.PI;
                             
                             for(let j=0; j<=steps; j++) {
                                 const a = sA + (eA - sA) * (j/steps);
                                 const px = seg.cx + Math.sin(a) * seg.r;
                                 const pz = seg.cz + Math.cos(a) * seg.r;
                                 const pt = toScreen(px, pz);
                                 if (j === 0 && i === 0) ctx.moveTo(pt.x, pt.y);
                                 else if (j===0) ctx.moveTo(pt.x, pt.y); 
                                 else ctx.lineTo(pt.x, pt.y);
                             }
                        }
                    });
                    ctx.strokeStyle = colors.stock; ctx.setLineDash([4, 4]); ctx.lineWidth = 1; ctx.stroke(); ctx.setLineDash([]);
                }

                if (calculatedData.worldPoints.length > 0) {
                    ctx.beginPath();
                    const start = toScreen(calculatedData.worldPoints[0].xReal, calculatedData.worldPoints[0].zReal);
                    ctx.moveTo(start.x, start.y);
                    for (let i = 0; i < calculatedData.worldPoints.length - 1; i++) {
                        const p1 = calculatedData.worldPoints[i];
                        const p2 = calculatedData.worldPoints[i+1];
                        const ptEnd = toScreen(p2.xReal, p2.zReal);
                        
                        if (p2.type === 'G0' || p2.type === 'G1') {
                            ctx.lineTo(ptEnd.x, ptEnd.y);
                        } else if (p2.type === 'G2' || p2.type === 'G3') {
                            const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, p2.type);
                            if (!arc.error) {
                                const steps = 20;
                                let sA = Math.atan2(p1.xReal - arc.cx, p1.zReal - arc.cz);
                                let eA = Math.atan2(p2.xReal - arc.cx, p2.zReal - arc.cz);
                                if (p2.type === 'G2' && eA > sA) eA -= 2*Math.PI;
                                if (p2.type === 'G3' && eA < sA) eA += 2*Math.PI;
                                
                                for(let j=1; j<=steps; j++) {
                                    const a = sA + (eA - sA) * (j/steps);
                                    const px = arc.cx + Math.sin(a) * arc.r;
                                    const pz = arc.cz + Math.cos(a) * arc.r;
                                    const pt = toScreen(px, pz);
                                    ctx.lineTo(pt.x, pt.y);
                                }
                            } else {
                                ctx.lineTo(ptEnd.x, ptEnd.y);
                            }
                        }
                    }
                    ctx.strokeStyle = colors.contour; ctx.lineWidth = 3; ctx.stroke();
                }

                if (calculatedData.offsetPath.length > 0) {
                    ctx.beginPath();
                    calculatedData.offsetPath.forEach((seg, i) => {
                        if(seg.isDegenerate) return;
                        if (seg.type === 'line') {
                            const p1 = toScreen(seg.p1.x, seg.p1.z); const p2 = toScreen(seg.p2.x, seg.p2.z);
                            if (i === 0) ctx.moveTo(p1.x, p1.y); else ctx.lineTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                        } else if (seg.type === 'arc') {
                             const center = toScreen(seg.cx, seg.cz);
                             const rScreen = seg.r * view.scale;
                             const counterClockwise = (params.machineStructure === 'lathe') ? (seg.dir !== 'G3') : (seg.dir === 'G3');
                             
                             if(!isNaN(center.x)) {
                                 const startAng = params.machineStructure === 'carousel' ? -seg.startAngle : seg.startAngle + Math.PI/2;
                                 const endAng = params.machineStructure === 'carousel' ? -seg.endAngle : seg.endAngle + Math.PI/2;
                                 
                                 // Simple polyline approximation for offset path to avoid complex angle logic for dashed lines
                                 const steps = 10;
                                 let sA = seg.startAngle;
                                 let eA = seg.endAngle;
                                 if (seg.dir === 'G2' && eA > sA) eA -= 2*Math.PI;
                                 if (seg.dir === 'G3' && eA < sA) eA += 2*Math.PI;
                                 for(let j=0; j<=steps; j++) {
                                    const a = sA + (eA - sA) * (j/steps);
                                    const px = seg.cx + Math.sin(a) * seg.r;
                                    const pz = seg.cz + Math.cos(a) * seg.r;
                                    const pt = toScreen(px, pz);
                                    if(j===0 && i===0) ctx.moveTo(pt.x, pt.y);
                                    else if(j===0) {} 
                                    else ctx.lineTo(pt.x, pt.y);
                                 }
                             }
                        }
                    });
                    ctx.strokeStyle = colors.offset; ctx.lineWidth = 1; ctx.setLineDash([2,2]); ctx.stroke(); ctx.setLineDash([]);
                }
                
                if (params.doFinishing && calculatedData.finishOffsetPath.length > 0) {
                    ctx.beginPath();
                    calculatedData.finishOffsetPath.forEach((seg, i) => {
                        if(seg.isDegenerate) return;
                        if (seg.type === 'line') {
                            const p1 = toScreen(seg.p1.x, seg.p1.z); 
                            const p2 = toScreen(seg.p2.x, seg.p2.z);
                            if (i === 0) ctx.moveTo(p1.x, p1.y);
                            if (i > 0) ctx.lineTo(p1.x, p1.y); 
                            else ctx.moveTo(p1.x, p1.y);
                            
                            ctx.lineTo(p2.x, p2.y);
                        } else if (seg.type === 'arc') {
                            const steps = 15;
                            let sA = seg.startAngle;
                            let eA = seg.endAngle;
                            if (seg.dir === 'G2' && eA > sA) eA -= 2*Math.PI;
                            if (seg.dir === 'G3' && eA < sA) eA += 2*Math.PI;
                            for(let j=0; j<=steps; j++) {
                                const a = sA + (eA - sA) * (j/steps);
                                const px = seg.cx + Math.sin(a) * seg.r;
                                const pz = seg.cz + Math.cos(a) * seg.r;
                                const pt = toScreen(px, pz);
                                if(i===0 && j===0) ctx.moveTo(pt.x, pt.y);
                                else ctx.lineTo(pt.x, pt.y);
                            }
                        }
                    });
                    ctx.strokeStyle = colors.finish; ctx.lineWidth = 2; ctx.stroke();
                }

                ctx.beginPath();
                calculatedData.passes.forEach(pass => {
                    if (pass.type === 'long') {
                        const p1 = toScreen(pass.x, pass.zStart); const p2 = toScreen(pass.x, pass.zEnd);
                        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                    } else {
                        const p1 = toScreen(pass.xStart, pass.z); const p2 = toScreen(pass.xEnd, pass.z);
                        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                    }
                });
                ctx.strokeStyle = colors.pass; ctx.lineWidth = 1.5; ctx.stroke();

                if (calculatedData.simPath.length > 0) {
                    ctx.beginPath();
                    for (let i = 0; i < calculatedData.simPath.length - 1; i++) {
                        const p1 = calculatedData.simPath[i];
                        const p2 = calculatedData.simPath[i+1];
                        if (p2.type === 'G0' || p2.type === 'G1' || p2.type === 'G2' || p2.type === 'G3') {
                            const s = toScreen(p1.x, p1.z);
                            const e = toScreen(p2.x, p2.z);
                            // Draw all moves, including G0 (as dashed red lines)
                            if (Math.abs(s.x - e.x) > 0.1 || Math.abs(s.y - e.y) > 0.1) {
                                ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y);
                            }
                        }
                    }
                    ctx.strokeStyle = theme === 'dark' ? '#ef4444' : '#ef4444'; ctx.lineWidth = 1.5; 
                    ctx.setLineDash([6, 6]); ctx.stroke(); ctx.setLineDash([]);
                }

                if ((simRunning || simProgress > 0) && calculatedData.simPath.length > 0) {
                    const totalPoints = calculatedData.simPath.length;
                    const floatIndex = simProgress * (totalPoints - 1);
                    const idx = Math.floor(floatIndex);
                    const t = floatIndex - idx;
                    const pCurrent = calculatedData.simPath[idx];
                    
                    if (pCurrent) {
                        const pNext = calculatedData.simPath[Math.min(idx + 1, totalPoints - 1)] || pCurrent;
                        const curX = pCurrent.x + (pNext.x - pCurrent.x) * t;
                        const curZ = pCurrent.z + (pNext.z - pCurrent.z) * t;
                        const pt = toScreen(curX, curZ);
                        
                        const tRad = parseFloat(params.toolRadius) || 0.8;
                        const rPix = tRad * view.scale; 

                        ctx.fillStyle = colors.tool; 
                        ctx.strokeStyle = theme === 'dark' ? '#000' : '#000'; 
                        ctx.lineWidth = 1;

                        if (params.toolShape === 'round') {
                            ctx.beginPath();
                            ctx.arc(pt.x, pt.y, rPix, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                        } else if (params.toolShape === 'polygon') {
                            const lenPix = (parseFloat(params.toolLength) || 10) * view.scale;
                            const rotRad = -(parseFloat(params.toolAngle) || 0) * (Math.PI / 180);
                            const tipAng = (parseFloat(params.toolTipAngle) || 90) * (Math.PI / 180);

                            const a1 = rotRad; 
                            const a2 = rotRad - tipAng; 

                            const distToCorner = rPix / Math.sin(tipAng / 2);
                            
                            const bisector = (a1 + a2) / 2;
                            const cornerX = Math.cos(bisector + Math.PI) * distToCorner;
                            const cornerY = Math.sin(bisector + Math.PI) * distToCorner;

                            ctx.save();
                            ctx.translate(pt.x, pt.y); 
                            
                            ctx.beginPath();
                            ctx.moveTo(cornerX, cornerY);
                            
                            const x1 = cornerX + Math.cos(a1) * lenPix;
                            const y1 = cornerY + Math.sin(a1) * lenPix;
                            ctx.lineTo(x1, y1);
                            
                            const x2 = cornerX + Math.cos(a2) * lenPix;
                            const y2 = cornerY + Math.sin(a2) * lenPix;
                            ctx.lineTo(x2, y2);
                            
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            
                            ctx.restore();
                            
                            ctx.beginPath(); ctx.arc(pt.x, pt.y, rPix, 0, Math.PI * 2); ctx.stroke();
                        }
                        
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(pt.x, pt.y, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                if (!simRunning) {
                    const activePoints = editMode === 'contour' ? calculatedData.worldPoints : calculatedData.stockWorldPoints;
                    ctx.font = "bold 11px sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                    if(activePoints) {
                        activePoints.forEach((p, i) => {
                            if (!p) return;
                            const pt = toScreen(p.xReal, p.zReal);
                            
                            const isHovered = (i === hoverPointId);
                            const isDragged = (i === draggedPointId);
                            const radius = (isHovered || isDragged) ? 8 : 4; 

                            ctx.fillStyle = editMode === 'contour' ? colors.contour : colors.pass;
                            if (isHovered || isDragged) ctx.fillStyle = '#f59e0b'; 

                            ctx.beginPath(); 
                            ctx.arc(pt.x, pt.y, radius, 0, Math.PI*2); 
                            ctx.fill();
                            
                            if (!isHovered && !isDragged) {
                                const label = `${i+1}`; 
                                const tx = pt.x + 8; const ty = pt.y - 8;
                                ctx.fillStyle = theme === 'dark' ? '#fbbf24' : '#d97706'; 
                                ctx.fillText(label, tx, ty);
                            }
                        });
                    }
                }

            }, [calculatedData, view, theme, params, editMode, mobileTab, simRunning, simProgress, draggedPointId, hoverPointId]);

            useEffect(() => {
                if (!containerRef.current || !canvasRef.current) return;
                const resizeObserver = new ResizeObserver(() => { draw(); });
                resizeObserver.observe(containerRef.current);
                return () => resizeObserver.disconnect();
            }, [draw]);

            // Handlers ... (same)
            const handleWheel = (e) => { const s = Math.max(0.2, Math.min(view.scale * (1 - Math.sign(e.deltaY)*0.15), 50)); setView(v => ({...v, scale: s})); };
            
            const getPointAt = (clientX, clientY) => {
                if (!canvasRef.current || simRunning) return null;
                const rect = canvasRef.current.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                
                const activePoints = editMode === 'contour' ? calculatedData.worldPoints : calculatedData.stockWorldPoints;
                if (!activePoints) return null;

                const threshold = 15; 
                let closestIdx = null;
                let minD = Infinity;

                const toScreen = (xReal, zReal) => {
                     if (params.machineStructure === 'carousel') {
                        return { x: view.panX + xReal * view.scale, y: view.panY - zReal * view.scale };
                    } else {
                        return { x: view.panX + zReal * view.scale, y: view.panY - xReal * view.scale };
                    }
                };

                for (let i = 0; i < activePoints.length; i++) {
                    const p = activePoints[i];
                    if (!p) continue;
                    const pt = toScreen(p.xReal, p.zReal);
                    const d = Math.hypot(pt.x - x, pt.y - y);
                    if (d < threshold && d < minD) {
                        minD = d;
                        closestIdx = i;
                    }
                }
                return closestIdx;
            };

            const handleInsertAfter = (index) => {
                 pushHistory();
                 const list = editMode === 'contour' ? contourPoints : stockPoints; 
                 const setList = editMode === 'contour' ? setContourPoints : setStockPoints; 
                 const prev = list[index]; 
                 const newPoint = { ...prev, id: Date.now(), z: parseFloat(prev.z) - 5 }; 
                 const newList = [...list]; 
                 newList.splice(index + 1, 0, newPoint); 
                 setList(newList);
                 
                 setActiveTab('editor');
                 setMobileTab('editor');
            };

            const handleMouseDown = (e) => { 
                const pointIdx = getPointAt(e.clientX, e.clientY);
                
                if (addPointMode) {
                    if (pointIdx !== null) {
                        handleInsertAfter(pointIdx);
                        setAddPointMode(false); 
                    }
                    return; 
                }

                if (pointIdx !== null) {
                    pushHistory(); 
                    setDraggedPointId(pointIdx);
                    setIsDragging(true); 
                } else {
                    setIsDragging(true); 
                }
                lastMousePos.current = { x: e.clientX, y: e.clientY }; 
            };

            const handleMouseMove = (e) => {
                const pointIdx = getPointAt(e.clientX, e.clientY);
                
                if (addPointMode) {
                    if (canvasRef.current) canvasRef.current.style.cursor = pointIdx !== null ? 'pointer' : 'copy'; 
                    setHoverPointId(pointIdx);
                    return; 
                }

                if (!isDragging) {
                    setHoverPointId(pointIdx);
                    if (canvasRef.current) canvasRef.current.style.cursor = pointIdx !== null ? 'move' : 'crosshair';
                }

                if (!isDragging) return;

                const dx = e.clientX - lastMousePos.current.x; 
                const dy = e.clientY - lastMousePos.current.y;
                lastMousePos.current = { x: e.clientX, y: e.clientY };

                if (draggedPointId !== null) {
                    let dX_unit = 0;
                    let dZ_unit = 0;

                    if (params.machineStructure === 'carousel') {
                        dX_unit = dx / view.scale;
                        dZ_unit = -dy / view.scale;
                    } else {
                        dZ_unit = dx / view.scale;
                        dX_unit = -dy / view.scale; 
                    }

                    const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                    
                    setList(prev => {
                        const newList = [...prev];
                        const pt = {...newList[draggedPointId]};
                        pt.x = parseFloat(pt.x) + dX_unit;
                        pt.z = parseFloat(pt.z) + dZ_unit;
                        newList[draggedPointId] = pt;
                        return newList;
                    });

                } else {
                    setView(v => ({ ...v, panX: v.panX + dx, panY: v.panY + dy }));
                }
            };
            
            const handleMouseUp = () => {
                 setIsDragging(false);
                 setDraggedPointId(null);
            };

            const handleTouchStart = (e) => {
                if (e.touches.length === 1) {
                    const t = e.touches[0];
                    const pointIdx = getPointAt(t.clientX, t.clientY);

                    if (addPointMode) {
                        if (pointIdx !== null) {
                            handleInsertAfter(pointIdx);
                            setAddPointMode(false);
                        }
                        return;
                    }

                    if (pointIdx !== null) {
                         pushHistory();
                         setDraggedPointId(pointIdx);
                         setIsDragging(true);
                    } else {
                         setIsDragging(true);
                    }
                    lastMousePos.current = { x: t.clientX, y: t.clientY };
                } else if (e.touches.length === 2) {
                    const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    lastPinchDist.current = dist;
                }
            };

            const handleTouchMove = (e) => {
                if (addPointMode) return; 

                if (isDragging && e.touches.length === 1) {
                    const t = e.touches[0];
                    const dx = t.clientX - lastMousePos.current.x;
                    const dy = t.clientY - lastMousePos.current.y;
                    lastMousePos.current = { x: t.clientX, y: t.clientY };

                    if (draggedPointId !== null) {
                         let dX_unit = 0; let dZ_unit = 0;
                         if (params.machineStructure === 'carousel') {
                            dX_unit = dx / view.scale; dZ_unit = -dy / view.scale;
                         } else {
                            dZ_unit = dx / view.scale; dX_unit = -dy / view.scale; 
                         }
                         const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                         setList(prev => {
                            const newList = [...prev];
                            const pt = {...newList[draggedPointId]};
                            pt.x = parseFloat(pt.x) + dX_unit;
                            pt.z = parseFloat(pt.z) + dZ_unit;
                            newList[draggedPointId] = pt;
                            return newList;
                        });
                    } else {
                        setView(v => ({ ...v, panX: v.panX + dx, panY: v.panY + dy }));
                    }
                }
                if (e.touches.length === 2 && lastPinchDist.current) {
                    const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    const zoomFactor = dist / lastPinchDist.current;
                    setView(v => { const newScale = Math.max(0.2, Math.min(v.scale * zoomFactor, 50)); return { ...v, scale: newScale }; });
                    lastPinchDist.current = dist;
                }
            };

            const handleTouchEnd = () => {
                setIsDragging(false);
                setDraggedPointId(null);
                lastPinchDist.current = null;
            };

            const processGCodeString = (text) => {
                pushHistory();
                const lines = text.split('\n'); const newPoints = []; let currentType = 'G1'; let idCounter = Date.now(); let lastX = 100; let lastZ = 0;
                lines.forEach(line => {
                    const clean = line.toUpperCase().trim(); if (!clean || clean.startsWith(';')) return;
                    const gMatch = clean.match(/G([0-3])/); if (gMatch) currentType = 'G' + gMatch[1];
                    const xMatch = clean.match(/X([-]?\d+\.?\d*)/); const zMatch = clean.match(/Z([-]?\d+\.?\d*)/); const rMatch = clean.match(/(?:R|CR=)([-]?\d+\.?\d*)/);
                    if (xMatch || zMatch) {
                        const newX = xMatch ? parseFloat(xMatch[1]) : lastX; const newZ = zMatch ? parseFloat(zMatch[1]) : lastZ;
                        newPoints.push({ id: idCounter++, type: currentType, x: newX, z: newZ, r: rMatch ? parseFloat(rMatch[1]) : 0, mode: 'ABS' });
                        lastX = newX; lastZ = newZ;
                    }
                });
                if (newPoints.length > 0) {
                    if (editMode === 'contour') setContourPoints(newPoints); else setStockPoints(newPoints); 
                    setErrors([]); fitView(); 
                } else alert("Nepoda≈ôilo se rozpoznat ≈æ√°dn√© body v G-k√≥du.");
            };
            
            const parseGCode = () => processGCodeString(gCodeInput);

            const handleCopyGCode = async () => {
                const text = useManualCode ? manualGCode : generatedCode.map(l => l.text).join('\n');
                try {
                    await navigator.clipboard.writeText(text);
                    setCopyFeedback(true);
                    setTimeout(() => setCopyFeedback(false), 2000);
                } catch (err) {
                    console.error("Copy failed", err);
                    alert("Nepoda≈ôilo se zkop√≠rovat k√≥d do schr√°nky.");
                }
            };

            const handleDownload = () => {
                const text = useManualCode ? manualGCode : generatedCode.map(l => l.text).join('\n');
                const blob = new Blob([text], {type: "text/plain"});
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                
                let ext = 'mpf';
                if(params.controlSystem === 'heidenhain') ext = 'h';
                else if(params.controlSystem === 'fanuc') ext = 'nc';
                
                a.download = `program_${new Date().toISOString().slice(0,10)}.${ext}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };
            
            const toggleMode = (id) => { 
                pushHistory();
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                setList(prev => prev.map(p => p.id===id ? {...p, mode: p.mode==='ABS'?'INC':'ABS'} : p));
            };
            
            const updatePoint = (id, f, v) => {
                pushHistory();
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                setList(prev => prev.map(p => p.id===id ? {...p, [f]: v} : p));
            };
            
            const addPoint = () => { 
                pushHistory();
                const list = editMode === 'contour' ? contourPoints : stockPoints; 
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints; 
                const last = list.length > 0 ? list[list.length - 1] : { x: 100, z: 0 }; 
                setList([...list, {id: Date.now(), type:'G1', x:last.x, z: parseFloat(last.z)-10, r:0, mode: 'ABS'}]); 
            };
            
            const insertPoint = (index) => { 
                pushHistory();
                const list = editMode === 'contour' ? contourPoints : stockPoints; 
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints; 
                const prev = list[index]; 
                const newPoint = { ...prev, id: Date.now(), z: parseFloat(prev.z) - 5 }; 
                const newList = [...list]; newList.splice(index + 1, 0, newPoint); 
                setList(newList); 
            };
            
            const removePoint = (id) => { 
                const list = editMode === 'contour' ? contourPoints : stockPoints; 
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints; 
                if (list.length > 1) {
                    pushHistory();
                    setList(list.filter(p=>p.id!==id)); 
                }
            };
            
            const currentPoints = editMode === 'contour' ? contourPoints : stockPoints;

            return (
                <div className="flex flex-col md:flex-row h-full">
                    <div className={`${mobileTab === 'editor' ? 'flex' : 'hidden'} md:flex w-full md:w-96 flex-col border-r shadow-xl z-10 h-full overflow-hidden ${theme === 'dark' ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'}`}>
                        <div className={`p-4 border-b flex justify-between items-center ${theme === 'dark' ? 'bg-gray-900 border-gray-700' : 'bg-gray-100 border-gray-200'}`}>
                            <div className="flex items-center gap-2">
                                <h1 className="font-bold text-lg text-blue-500">Sinumerik CAM <span className="text-xs text-gray-400 font-normal">v1.8</span></h1>
                                <div className="flex gap-1 ml-2">
                                    <button onClick={undo} disabled={past.length===0} className={`p-1 rounded ${past.length===0 ? 'text-gray-300' : 'text-gray-600 hover:bg-gray-200 dark:text-gray-400 dark:hover:bg-gray-700'}`} title="Zpƒõt"><IconUndo /></button>
                                    <button onClick={redo} disabled={future.length===0} className={`p-1 rounded ${future.length===0 ? 'text-gray-300' : 'text-gray-600 hover:bg-gray-200 dark:text-gray-400 dark:hover:bg-gray-700'}`} title="Vp≈ôed"><IconRedo /></button>
                                </div>
                            </div>
                            <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')} className="p-2 rounded hover:bg-gray-700 hover:text-white transition-colors">
                                {theme === 'light' ? <IconMoon /> : <IconSun />}
                            </button>
                        </div>
                        {errors.length > 0 && (
                            <div className="bg-red-50 border-l-4 border-red-500 text-red-700 p-2 text-xs">
                                <div className="font-bold flex gap-2 items-center"><IconWarning /> Nalezeny probl√©my:</div>
                                <ul className="list-disc pl-6 mt-1 space-y-1">{errors.map((e, i) => <li key={i}>{e.msg || e}</li>)}</ul>
                            </div>
                        )}
                        <div className="flex border-b border-gray-200 dark:border-gray-700">
                             {['editor', 'params', 'import', 'AI'].map(tab => (
                                <button key={tab} onClick={() => setActiveTab(tab)} 
                                    className={`flex-1 p-3 text-sm font-medium capitalize ${activeTab===tab ? 'bg-blue-100 text-blue-700' : 'text-gray-500'}`}>
                                    {tab === 'AI' ? (
                                        <div className="flex items-center justify-center gap-1">
                                            <IconVoiceChat /> Chat
                                        </div>
                                    ) : tab}
                                </button>
                            ))}
                        </div>
                         <div className="flex-1 overflow-y-auto p-4 custom-scrollbar pb-20 md:pb-4">
                            {activeTab === 'editor' && (
                                <div className="space-y-3">
                                    <div className="flex gap-2 mb-2 bg-gray-200 p-1 rounded dark:bg-gray-700">
                                        <button onClick={() => setEditMode('contour')} className={`flex-1 flex items-center justify-center gap-2 text-xs py-1.5 rounded font-bold transition-all ${editMode==='contour' ? 'bg-white shadow text-blue-600 dark:bg-gray-600 dark:text-blue-300' : 'text-gray-500 hover:text-gray-700'}`}><IconEdit /> Kontura</button>
                                        <button onClick={() => { setEditMode('stock'); if(stockPoints.length === 0) generateDefaultStock(); }} className={`flex-1 flex items-center justify-center gap-2 text-xs py-1.5 rounded font-bold transition-all ${editMode==='stock' ? 'bg-white shadow text-green-600 dark:bg-gray-600 dark:text-green-300' : 'text-gray-500 hover:text-gray-700'}`}><IconBox /> Polotovar</button>
                                    </div>
                                    <div className="flex gap-1 px-2 text-xs font-bold text-gray-500 mb-1">
                                        <div className="w-6 text-center">#</div>
                                        <div className="w-14">Typ</div>
                                        <div className="w-8 text-center">M√≥d</div>
                                        <div className="w-16 text-center">X/U</div>
                                        <div className="w-16 text-center">Z/W</div>
                                        <div className="w-10 text-center">R</div>
                                    </div>
                                    {currentPoints.map((p, index) => (
                                        <div key={p.id} className={`border rounded p-2 flex flex-wrap gap-1 items-center ${theme === 'dark' ? 'bg-gray-750 border-gray-600' : 'bg-gray-50 border-gray-300'} ${editMode==='stock' ? 'border-l-4 border-l-green-500' : 'border-l-4 border-l-blue-500'}`}>
                                            <div className="w-6 font-mono text-xs text-gray-500 font-bold">{index+1}</div>
                                            <select value={p.type} onChange={(e) => updatePoint(p.id, 'type', e.target.value)} className={`border rounded text-xs px-1 py-1 w-14 ${theme==='dark'?'bg-gray-900 border-gray-600 text-white':'bg-white border-gray-300 text-gray-900'}`}><option>G0</option><option>G1</option><option>G2</option><option>G3</option></select>
                                            <button onClick={() => toggleMode(p.id)} className={`w-8 h-6 flex items-center justify-center rounded text-xs font-bold ${p.mode==='INC' ? 'bg-purple-100 text-purple-700 border border-purple-300' : 'bg-gray-100 text-gray-600 border border-gray-300'}`} title={p.mode === 'INC' ? 'P≈ô√≠r≈Østkovƒõ' : 'Absolutnƒõ'}>{p.mode === 'INC' ? 'INC' : 'ABS'}</button>
                                            <SmartInput type="number" value={p.x} onValueChange={(v) => updatePoint(p.id, 'x', v)} className={`border rounded text-sm w-16 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600 text-white':'bg-white border-gray-300 text-gray-900'}`} placeholder={p.mode==='INC' ? 'U' : 'X'} />
                                            <SmartInput type="number" value={p.z} onValueChange={(v) => updatePoint(p.id, 'z', v)} className={`border rounded text-sm w-16 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600 text-white':'bg-white border-gray-300 text-gray-900'}`} placeholder={p.mode==='INC' ? 'W' : 'Z'} />
                                            {(p.type === 'G2' || p.type === 'G3') && <SmartInput type="number" value={p.r} onValueChange={(v) => updatePoint(p.id, 'r', v)} className={`border rounded text-sm w-10 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600 text-white':'bg-white border-gray-300 text-gray-900'}`} placeholder="R" />}
                                            <div className="flex ml-auto gap-1">
                                                <button onClick={() => insertPoint(index)} className="text-blue-500 hover:text-blue-700 p-1" title="Vlo≈æit ≈ô√°dek za"><IconInsert /></button>
                                                <button onClick={() => removePoint(p.id)} className="text-red-400 hover:text-red-600 p-1" title="Smazat ≈ô√°dek"><IconTrash /></button>
                                            </div>
                                        </div>
                                    ))}
                                    <div className="grid grid-cols-2 gap-2">
                                        <button onClick={addPoint} className={`col-span-2 py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 ${editMode==='stock'?'bg-green-600 hover:bg-green-500':'bg-blue-600 hover:bg-blue-500'}`}><IconPlus /> P≈ôidat bod</button>
                                        <button onClick={handleCopyGCode} className={`py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 transition-all ${copyFeedback ? 'bg-green-600' : 'bg-gray-600 hover:bg-gray-500'}`}><IconClipboard /> {copyFeedback ? "Zkop√≠rov√°no" : "Kop√≠rovat"}</button>
                                        <button onClick={handleDownload} className="py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 bg-purple-600 hover:bg-purple-500"><IconDownload /> Ulo≈æit MPF</button>
                                        <button onClick={handleExportPDF} className="py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 bg-indigo-600 hover:bg-indigo-500"><IconFileText /> Export PDF</button>
                                    </div>
                                </div>
                            )}
                             {activeTab === 'params' && (
                                <div className="space-y-4">
                                    <h3 className={`font-bold border-b pb-1 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Konfigurace</h3>
                                    <div className="flex gap-2 mb-2">
                                        <button onClick={() => setParams({...params, machineStructure: 'lathe'})} className={`flex-1 py-1 text-xs border rounded flex items-center justify-center gap-1 ${params.machineStructure==='lathe' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Soustruh</button>
                                        <button onClick={() => setParams({...params, machineStructure: 'carousel'})} className={`flex-1 py-1 text-xs border rounded flex items-center justify-center gap-1 ${params.machineStructure==='carousel' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Karusel</button>
                                    </div>

                                    <h3 className={`font-bold border-b pb-1 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>≈ò√≠dic√≠ syst√©m</h3>
                                    <div className="flex gap-1 mb-2">
                                        <button onClick={() => setParams({...params, controlSystem: 'sinumerik'})} className={`flex-1 py-1 text-[10px] border rounded flex items-center justify-center gap-1 ${params.controlSystem==='sinumerik' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Sinumerik</button>
                                        <button onClick={() => setParams({...params, controlSystem: 'fanuc'})} className={`flex-1 py-1 text-[10px] border rounded flex items-center justify-center gap-1 ${params.controlSystem==='fanuc' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Fanuc</button>
                                        <button onClick={() => setParams({...params, controlSystem: 'heidenhain'})} className={`flex-1 py-1 text-[10px] border rounded flex items-center justify-center gap-1 ${params.controlSystem==='heidenhain' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Heidenhain</button>
                                    </div>

                                    <h3 className={`font-bold border-b pb-1 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Polotovar</h3>
                                    <div className="flex gap-2 mb-2">
                                        <button onClick={() => setParams({...params, stockMode: 'cylinder'})} className={`flex-1 py-1 text-xs border rounded ${params.stockMode==='cylinder' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>V√°lec</button>
                                        <button onClick={() => { setParams({...params, stockMode: 'casting'}); setActiveTab('editor'); setEditMode('stock'); if(stockPoints.length === 0) generateDefaultStock(); }} className={`flex-1 py-1 text-xs border rounded ${params.stockMode==='casting' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Vlastn√≠ tvar</button>
                                    </div>
                                    {params.stockMode === 'cylinder' ? (
                                        <div className="space-y-2">
                                            <div className="flex items-end gap-2">
                                                <div className="flex-1"><label className="text-xs text-gray-500">Pr≈Ømƒõr (D)</label><SmartInput type="number" value={params.stockDiameter} onValueChange={v=>setParams({...params, stockDiameter:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">D√©lka (Z-)</label><SmartInput type="number" value={params.stockLength} onValueChange={v=>setParams({...params, stockLength:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                            </div>
                                            <div className="flex items-end gap-2">
                                                <div className="flex-1"><label className="text-xs text-gray-500">P≈ô√≠davek ƒçelo (Z+)</label><SmartInput type="number" value={params.stockFace} onValueChange={v=>setParams({...params, stockFace:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">P≈ô√≠davek (pro Auto)</label><SmartInput type="number" value={params.stockMargin} onValueChange={v=>setParams({...params, stockMargin:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                            </div>
                                            <button onClick={handleAutoStock} className="w-full py-1.5 bg-indigo-600 text-white rounded text-xs font-bold flex items-center justify-center gap-1 hover:bg-indigo-500"><IconMagic /> Auto-rozmƒõr</button>
                                        </div>
                                    ) : (
                                        <div className="text-xs text-gray-500 italic p-2 bg-gray-100 rounded dark:bg-gray-800">Pro definici tvarov√©ho polotovaru (odlitku) pou≈æijte p≈ôep√≠naƒç "Polotovar" v z√°lo≈æce <b>Editor</b> a nakreslete jeho tvar.</div>
                                    )}
                                    
                                    <h3 className={`font-bold border-b pb-1 mt-4 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Bezpeƒçn√° poloha (N√°jezd)</h3>
                                    <div className="flex gap-2 mb-2">
                                        <div className="flex-1"><label className="text-xs text-gray-500">X (Pr≈Ømƒõr)</label><SmartInput type="number" value={params.safeX} onValueChange={v=>setParams({...params, safeX:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                        <div className="flex-1"><label className="text-xs text-gray-500">Z</label><SmartInput type="number" value={params.safeZ} onValueChange={v=>setParams({...params, safeZ:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                    </div>

                                    <h3 className={`font-bold border-b pb-1 mt-4 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Hrubov√°n√≠</h3>
                                    
                                    {/* MATERIAL DATABASE */}
                                    <div className={`p-2 rounded mb-2 border ${theme==='dark'?'bg-gray-800 border-gray-600':'bg-blue-50 border-blue-200'}`}>
                                        <div className="flex items-center gap-1 text-xs font-bold mb-1 opacity-70"><IconDatabase /> Datab√°ze materi√°l≈Ø (Rychl√© nastaven√≠)</div>
                                        <div className="grid grid-cols-2 gap-1">
                                            {Object.keys(MATERIALS).map(matKey => (
                                                <button 
                                                    key={matKey}
                                                    onClick={() => setParams(p => ({
                                                        ...p, 
                                                        speed: MATERIALS[matKey].speed,
                                                        feed: MATERIALS[matKey].feed,
                                                        depthOfCut: MATERIALS[matKey].depth
                                                    }))}
                                                    className={`text-[10px] px-2 py-1 rounded border transition-colors ${
                                                        theme==='dark' 
                                                        ? 'bg-gray-700 border-gray-600 hover:bg-gray-600 text-gray-300' 
                                                        : 'bg-white border-gray-300 hover:bg-blue-100 text-gray-700'
                                                    }`}
                                                >
                                                    {MATERIALS[matKey].name}
                                                </button>
                                            ))}
                                        </div>
                                    </div>

                                    <div className="flex gap-2 mb-2">
                                        <button onClick={() => setParams({...params, roughingStrategy: 'longitudinal', toolAngle: 15})} className={`flex-1 py-1 text-xs border rounded flex items-center justify-center gap-1 ${params.roughingStrategy==='longitudinal' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-700'}`}><IconArrowRight /> Pod√©lnƒõ (Z)</button>
                                        <button onClick={() => setParams({...params, roughingStrategy: 'face', toolAngle: -15})} className={`flex-1 py-1 text-xs border rounded flex items-center justify-center gap-1 ${params.roughingStrategy==='face' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-700'}`}><IconArrowDown /> ƒåelnƒõ (X)</button>
                                    </div>
                                    <div className="grid grid-cols-2 gap-2">
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Hloubka (ap)</label><SmartInput type="number" step="0.5" value={params.depthOfCut} onValueChange={v=>setParams({...params, depthOfCut:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Posuv (F)</label><SmartInput type="number" step="0.05" value={params.feed} onValueChange={v=>setParams({...params, feed:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Rychlost (Vc)</label><SmartInput type="number" step="10" value={params.speed} onValueChange={v=>setParams({...params, speed:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Odskok (G1 -> G0)</label><SmartInput type="number" step="0.5" value={params.retractDistance} onValueChange={v=>setParams({...params, retractDistance:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                    </div>
                                    <h3 className={`font-bold border-b pb-1 mt-4 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>N√°stroj</h3>
                                    <div className="grid grid-cols-2 gap-2">
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">R√°dius (R)</label><SmartInput type="number" step="0.1" value={params.toolRadius} onValueChange={v=>setParams({...params, toolRadius:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">P≈ô√≠davek X</label><SmartInput type="number" step="0.1" value={params.allowanceX} onValueChange={v=>setParams({...params, allowanceX:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">P≈ô√≠davek Z</label><SmartInput type="number" step="0.1" value={params.allowanceZ} onValueChange={v=>setParams({...params, allowanceZ:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                    </div>
                                    {/* Tool Shape Selector */}
                                    <div className="mt-2">
                                        <label className="text-xs text-gray-500 mb-1 block">Tvar destiƒçky</label>
                                        <div className="flex gap-1">
                                            <button onClick={() => setParams({...params, toolShape: 'round'})} className={`flex-1 py-1 border rounded flex items-center justify-center gap-1 ${params.toolShape==='round' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`} title="Kulat√°"><IconShapeCircle /></button>
                                            <button onClick={() => setParams({...params, toolShape: 'polygon', toolTipAngle: 90})} className={`flex-1 py-1 border rounded flex items-center justify-center gap-1 ${params.toolShape==='polygon' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`} title="Hranat√°"><IconShapePolygon /></button>
                                        </div>
                                        {params.toolShape === 'polygon' && (
                                            <div className="flex gap-2 mt-2">
                                                <div className="flex-1"><label className="text-xs text-gray-500">D√©lka hrany (L)</label><SmartInput type="number" value={params.toolLength} onValueChange={v=>setParams({...params, toolLength:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">Natoƒçen√≠ (¬∞)</label><SmartInput type="number" value={params.toolAngle} onValueChange={v=>setParams({...params, toolAngle:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">Vrcholov√Ω √∫hel (Œµ)</label><SmartInput type="number" value={params.toolTipAngle} onValueChange={v=>setParams({...params, toolTipAngle:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                            </div>
                                        )}
                                    </div>
                                    <div className="mt-4 pt-2 border-t dark:border-gray-700">
                                        <label className="flex items-center space-x-2 cursor-pointer">
                                            <input type="checkbox" checked={params.doFinishing} onChange={e => setParams({...params, doFinishing: e.target.checked})} className="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600" />
                                            <span className="text-sm font-bold text-gray-700 dark:text-gray-300">Dokonƒçovac√≠ operace (Na ƒçisto)</span>
                                        </label>
                                        <p className="text-xs text-gray-500 mt-1 pl-6">Vygeneruje dr√°hu n√°stroje p≈ôesnƒõ po kontu≈ôe (pouze s korekc√≠ R, bez p≈ô√≠davku).</p>
                                    </div>
                                    
                                    <div className="mt-8 pt-4 border-t dark:border-gray-700 flex justify-center">
                                        <button onClick={handleResetApp} className="text-xs text-red-500 hover:text-red-700 flex items-center gap-1">
                                            <IconRefresh /> Resetovat v≈°e (Vymazat ulo≈æen√©)
                                        </button>
                                    </div>
                                </div>
                            )}
                            {activeTab === 'AI' && (
                                <AiAssistant 
                                    contourPoints={contourPoints} 
                                    stockPoints={stockPoints} 
                                    params={params} 
                                    onUpdateContour={(pts) => {
                                        const newPts = pts.map((p, i) => ({...p, id: p.id || Date.now() + i}));
                                        pushHistory();
                                        setContourPoints(newPts);
                                        setActiveTab('editor');
                                        setEditMode('contour');
                                    }}
                                    onUpdateStock={(pts) => {
                                        const newPts = pts.map((p, i) => ({...p, id: p.id || Date.now() + i}));
                                        pushHistory();
                                        setStockPoints(newPts);
                                        setActiveTab('editor');
                                        setEditMode('stock');
                                        setParams(p => ({...p, stockMode: 'casting'}));
                                    }}
                                    onUpdateParams={(newParams) => {
                                        pushHistory();
                                        setParams(prev => ({...prev, ...newParams}));
                                        setActiveTab('params');
                                    }}
                                    onUpdateGCode={(code) => {
                                        setManualGCode(code);
                                        setUseManualCode(true);
                                        setActiveTab('editor'); 
                                    }}
                                    theme={theme}
                                />
                            )}
                             {activeTab === 'import' && (
                                <div className="flex flex-col h-full">
                                    <textarea className={`flex-1 border p-2 font-mono text-xs mb-2 ${theme==='dark'?'bg-gray-800 text-white border-gray-600':'bg-white text-gray-900 border-gray-300'}`} value={gCodeInput} onChange={e=>setGCodeInput(e.target.value)} placeholder="G1 X... Z..."></textarea>
                                    <button onClick={parseGCode} className="bg-green-600 text-white py-2 rounded">Import</button>
                                </div>
                            )}
                        </div>
                    </div>

                     <div className={`${mobileTab === 'preview' ? 'flex' : 'hidden'} md:flex flex-1 flex-col relative pb-20 md:pb-0 ${theme === 'dark' ? 'bg-gray-900' : 'bg-gray-50'}`}>
                        <div className="absolute top-4 right-4 z-10 flex gap-2">
                            <div className="bg-white p-1 rounded shadow flex gap-1 items-center">
                                <button onClick={toggleSimulation} className={`p-1 rounded hover:bg-green-100 ${simRunning ? 'text-green-600' : 'text-gray-600'}`} title={simRunning ? "Pauza" : "Spustit"}>
                                    {simRunning ? <IconPause /> : <IconPlay />}
                                </button>
                                <button onClick={stopSimulation} className="p-1 rounded hover:bg-red-100 text-gray-600" title="Stop"><IconStop /></button>
                            </div>
                            
                            <div className="bg-white p-1 rounded shadow flex gap-1 items-center">
                                <button 
                                    onClick={() => setAddPointMode(!addPointMode)} 
                                    className={`p-1 rounded hover:bg-blue-100 ${addPointMode ? 'text-blue-600 bg-blue-50' : 'text-gray-600'}`} 
                                    title="Vlo≈æit za bod"
                                >
                                    <IconPlusCircle />
                                </button>
                            </div>

                            <button onClick={fitView} className="bg-white p-2 rounded shadow text-gray-700 hover:text-blue-600" title="Centrovat pohled"><IconTarget /></button>
                        </div>
                        <div ref={containerRef} className={`flex-1 overflow-hidden relative canvas-container`}
                             onWheel={handleWheel} 
                             onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}
                             onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd}>
                            <canvas ref={canvasRef} className="block" />
                        </div>
                        <div ref={codeContainerRef} className={`h-48 border-t flex flex-col ${theme === 'dark' ? 'bg-gray-950 border-gray-700' : 'bg-white border-gray-300'}`}>
                             {/* Control Bar for Code View */}
                             <div className={`p-1 border-b flex justify-between items-center text-xs ${theme === 'dark' ? 'bg-gray-900 border-gray-700' : 'bg-gray-100 border-gray-300'}`}>
                                 <span className="font-bold px-2 text-gray-500">G-CODE</span>
                                 <div className="flex gap-4">
                                     {calculatedData.estimatedTimeSeconds > 0 && (
                                         <div className="flex items-center gap-1 text-gray-500" title="Odhadovan√Ω ƒças obr√°bƒõn√≠">
                                             <IconClock /> <span>{Math.floor(calculatedData.estimatedTimeSeconds/60)}m {Math.round(calculatedData.estimatedTimeSeconds%60)}s</span>
                                             <span className="opacity-50">| {(calculatedData.totalPathLength/1000).toFixed(2)}m</span>
                                         </div>
                                     )}
                                     {useManualCode && manualGCode.includes("CYCLE") && (
                                         <span className="text-orange-500 font-bold flex items-center gap-1"><IconWarning /> Simul√°tor neum√≠ cykly (jen G0/G1)</span>
                                     )}
                                 </div>
                                 <div className="flex gap-2">
                                     <button 
                                        onClick={() => setUseManualCode(false)} 
                                        className={`px-2 py-0.5 rounded transition-colors ${!useManualCode ? (theme==='dark'?'bg-blue-600 text-white':'bg-blue-600 text-white') : 'text-gray-500 hover:bg-gray-200'}`}
                                     >
                                         Auto (Gener√°tor)
                                     </button>
                                     <button 
                                        onClick={() => { setUseManualCode(true); if(!manualGCode) setManualGCode(generatedCode.map(l=>l.text).join('\n')); }} 
                                        className={`px-2 py-0.5 rounded transition-colors ${useManualCode ? 'bg-purple-600 text-white' : 'text-gray-500 hover:bg-gray-200'}`}
                                     >
                                         <span className="flex items-center gap-1"><IconTerminal /> Manu√°l / AI</span>
                                     </button>
                                 </div>
                             </div>

                             {useManualCode ? (
                                 <textarea 
                                    className={`flex-1 w-full p-2 font-mono text-xs resize-none focus:outline-none ${theme === 'dark' ? 'bg-gray-950 text-green-400' : 'bg-white text-gray-800'}`}
                                    value={manualGCode}
                                    onChange={(e) => setManualGCode(e.target.value)}
                                    spellCheck={false}
                                    placeholder="Zde m≈Ø≈æete ps√°t vlastn√≠ G-k√≥d nebo nechat AI vygenerovat program..."
                                 />
                             ) : (
                                 <div className="flex-1 overflow-y-auto font-mono text-xs p-2">
                                    {generatedCode.map((line, idx) => (
                                        <div 
                                            key={idx} 
                                            onClick={() => handleLineClick(line.simIdx)}
                                            className={`code-line whitespace-pre px-2 py-0.5 cursor-pointer ${idx === highlightIndex ? 'active' : ''} ${theme === 'dark' ? 'text-green-300' : 'text-gray-800'}`}
                                        >
                                            {line.text}
                                        </div>
                                    ))}
                                 </div>
                             )}
                        </div>
                    </div>

                    <div className="md:hidden fixed bottom-0 left-0 right-0 h-16 bg-white border-t border-gray-200 flex z-50 safe-pb dark:bg-gray-900 dark:border-gray-700">
                        <button onClick={() => setMobileTab('editor')} className={`flex-1 flex flex-col items-center justify-center ${mobileTab==='editor' ? 'text-blue-600' : 'text-gray-500'}`}>
                            <IconEdit />
                            <span className="text-xs font-bold mt-1">Editor</span>
                        </button>
                        <button onClick={() => setMobileTab('preview')} className={`flex-1 flex flex-col items-center justify-center ${mobileTab==='preview' ? 'text-blue-600' : 'text-gray-500'}`}>
                            <IconEye />
                            <span className="text-xs font-bold mt-1">N√°hled</span>
                        </button>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
>>>>>>> e52642107a8edc8ab34a98eec0d608b52fdb2926
